<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <meta name="referrer" content="no-referrer-when-downgrade">
    

    <title>函数的扩展 | 未来可期的博客</title>
    <meta property="og:title" content="函数的扩展 - 未来可期的博客">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2024-04-24T09:49:04&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2024-04-24T09:49:04&#43;08:00'>
        
    <meta name="Keywords" content="golang,go语言,go语言笔记,未来可期,博客,公众号,小程序">
    <meta name="description" content="函数的扩展">
        
    <meta name="author" content="未来可期">
    <meta property="og:url" content="http://shansec.github.io/post/es6/%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/">
    <link rel="shortcut icon" href='/favicon.ico'  type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
        <link rel="stylesheet" href='/css/douban.css'>
    
        <link rel="stylesheet" href='/css/other.css'>
    
</head>

<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="http://shansec.github.io">
                        未来可期的博客
                    </a>
                
                <p class="description">专注于Go语言(golang)、前端技术</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="http://shansec.github.io">Home</a>
                    
                    <a  href="http://shansec.github.io/archives/" title="归档">归档</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    <style type="text/css">
    .post-toc {
        position: fixed;
        width: 200px;
        margin-left: -210px;
        padding: 5px 10px;
        font-family: Athelas, STHeiti, Microsoft Yahei, serif;
        font-size: 12px;
        border: 1px solid rgba(0, 0, 0, .07);
        border-radius: 5px;
        background-color: rgba(255, 255, 255, 0.98);
        background-clip: padding-box;
        -webkit-box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        word-wrap: break-word;
        white-space: nowrap;
        -webkit-box-sizing: border-box;
        box-sizing: border-box;
        z-index: 999;
        cursor: pointer;
        max-height: 70%;
        overflow-y: auto;
        overflow-x: hidden;
    }

    .post-toc .post-toc-title {
        width: 100%;
        margin: 0 auto;
        font-size: 20px;
        font-weight: 400;
        text-transform: uppercase;
        text-align: center;
    }

    .post-toc .post-toc-content {
        font-size: 15px;
    }

    .post-toc .post-toc-content>nav>ul {
        margin: 10px 0;
    }

    .post-toc .post-toc-content ul {
        padding-left: 20px;
        list-style: square;
        margin: 0.5em;
        line-height: 1.8em;
    }

    .post-toc .post-toc-content ul ul {
        padding-left: 15px;
        display: none;
    }

    @media print,
    screen and (max-width:1057px) {
        .post-toc {
            display: none;
        }
    }
</style>
<div class="post-toc" style="position: absolute; top: 188px;">
    <h2 class="post-toc-title">Table of Contents</h2>
    <div class="post-toc-content">
        <nav id="TableOfContents">
  <ul>
    <li><a href="#函数参数的默认值">函数参数的默认值</a>
      <ul>
        <li><a href="#基本用法">基本用法</a></li>
        <li><a href="#与解构赋值默认值结合使用">与解构赋值默认值结合使用</a></li>
        <li><a href="#参数默认值的位置">参数默认值的位置</a></li>
        <li><a href="#函数的-length-属性">函数的 length 属性</a></li>
        <li><a href="#作用域">作用域</a></li>
        <li><a href="#应用">应用</a></li>
      </ul>
    </li>
    <li><a href="#rest-参数">rest 参数</a></li>
    <li><a href="#严格模式">严格模式</a></li>
    <li><a href="#name-属性">name 属性</a></li>
    <li><a href="#箭头函数">箭头函数</a>
      <ul>
        <li><a href="#基本用法-1">基本用法</a></li>
        <li><a href="#使用注意点">使用注意点</a></li>
        <li><a href="#不适用场合">不适用场合</a></li>
        <li><a href="#嵌套的箭头函数">嵌套的箭头函数</a></li>
      </ul>
    </li>
    <li><a href="#尾调用优化">尾调用优化</a>
      <ul>
        <li><a href="#什么是尾调用">什么是尾调用？</a></li>
        <li><a href="#尾调用优化-1">尾调用优化</a></li>
        <li><a href="#尾递归">尾递归</a></li>
        <li><a href="#递归函数的改写">递归函数的改写</a></li>
        <li><a href="#严格模式-1">严格模式</a></li>
        <li><a href="#尾递归优化的实现">尾递归优化的实现</a></li>
      </ul>
    </li>
    <li><a href="#函数参数的尾逗号">函数参数的尾逗号</a></li>
    <li><a href="#functionprototypetostring">Function.prototype.toString()</a></li>
    <li><a href="#catch-命令的参数省略">catch 命令的参数省略</a></li>
  </ul>
</nav>
    </div>
</div>
<script type="text/javascript">
    $(document).ready(function () {
        var postToc = $(".post-toc");
        if (postToc.length) {
            var leftPos = $("#main").offset().left;
            if (leftPos < 220) {
                postToc.css({ "width": leftPos - 10, "margin-left": (0 - leftPos) })
            }

            var t = postToc.offset().top - 20,
                a = {
                    start: {
                        position: "absolute",
                        top: t
                    },
                    process: {
                        position: "fixed",
                        top: 20
                    },
                };
            $(window).scroll(function () {
                var e = $(window).scrollTop();
                e < t ? postToc.css(a.start) : postToc.css(a.process)
            })
        }

        if ($("#TableOfContents").children().length < 1) {
            $(".post-toc").remove();
        }
    })
</script>
    <article class="post">
        <header>
            <h1 class="post-title">函数的扩展</h1>
        </header>
        
  <time datetime="2024-04-24T01:49:04Z" class="post-meta meta-date dt-published">
    2024-04-24
  </time>


<div class="post-meta meta-category">
  <span>&nbsp;|</span>
  
    <a href='/categories/%E5%89%8D%E7%AB%AF' target="_blank">前端</a>
  
</div>


        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">&nbsp;|
                <span id="busuanzi_value_page_pv"></span> <span>reads</span>
            </span>
        </div>
        
        
        <div class="post-content">
            <h2 id="函数参数的默认值">函数参数的默认值</h2>
<h3 id="基本用法">基本用法</h3>
<p>ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> log(x, y) {
</span></span><span style="display:flex;"><span>  y <span style="color:#000;font-weight:bold">=</span> y <span style="color:#000;font-weight:bold">||</span> <span style="color:#d14">&#39;World&#39;</span>;
</span></span><span style="display:flex;"><span>  console.log(x, y);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>log(<span style="color:#d14">&#39;Hello&#39;</span>) <span style="color:#998;font-style:italic">// Hello World
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>log(<span style="color:#d14">&#39;Hello&#39;</span>, <span style="color:#d14">&#39;China&#39;</span>) <span style="color:#998;font-style:italic">// Hello China
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>log(<span style="color:#d14">&#39;Hello&#39;</span>, <span style="color:#d14">&#39;&#39;</span>) <span style="color:#998;font-style:italic">// Hello World
</span></span></span></code></pre></div><p>上面代码检查函数<code>log()</code>的参数<code>y</code>有没有赋值，如果没有，则指定默认值为<code>World</code>。这种写法的缺点在于，如果参数<code>y</code>赋值了，但是对应的布尔值为<code>false</code>，则该赋值不起作用。就像上面代码的最后一行，参数<code>y</code>等于空字符，结果被改为默认值。</p>
<p>为了避免这个问题，通常需要先判断一下参数<code>y</code>是否被赋值，如果没有，再等于默认值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">typeof</span> y <span style="color:#000;font-weight:bold">===</span> <span style="color:#d14">&#39;undefined&#39;</span>) {
</span></span><span style="display:flex;"><span>  y <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;World&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> log(x, y <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;World&#39;</span>) {
</span></span><span style="display:flex;"><span>  console.log(x, y);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>log(<span style="color:#d14">&#39;Hello&#39;</span>) <span style="color:#998;font-style:italic">// Hello World
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>log(<span style="color:#d14">&#39;Hello&#39;</span>, <span style="color:#d14">&#39;China&#39;</span>) <span style="color:#998;font-style:italic">// Hello China
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>log(<span style="color:#d14">&#39;Hello&#39;</span>, <span style="color:#d14">&#39;&#39;</span>) <span style="color:#998;font-style:italic">// Hello
</span></span></span></code></pre></div><p>可以看到，ES6 的写法比 ES5 简洁许多，而且非常自然。下面是另一个例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> Point(x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>, y <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">this</span>.x <span style="color:#000;font-weight:bold">=</span> x;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">this</span>.y <span style="color:#000;font-weight:bold">=</span> y;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> p <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> Point();
</span></span><span style="display:flex;"><span>p <span style="color:#998;font-style:italic">// { x: 0, y: 0 }
</span></span></span></code></pre></div><p>除了简洁，ES6 的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。</p>
<p>参数变量是默认声明的，所以不能用<code>let</code>或<code>const</code>再次声明。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> foo(x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">5</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">let</span> x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>; <span style="color:#998;font-style:italic">// error
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  <span style="color:#000;font-weight:bold">const</span> x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">2</span>; <span style="color:#998;font-style:italic">// error
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>上面代码中，参数变量<code>x</code>是默认声明的，在函数体中，不能用<code>let</code>或<code>const</code>再次声明，否则会报错。</p>
<p>使用参数默认值时，函数不能有同名参数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 不报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">function</span> foo(x, x, y) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">function</span> foo(x, x, y <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// SyntaxError: Duplicate parameter name not allowed in this context
</span></span></span></code></pre></div><p>另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">99</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> foo(p <span style="color:#000;font-weight:bold">=</span> x <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>) {
</span></span><span style="display:flex;"><span>  console.log(p);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>foo() <span style="color:#998;font-style:italic">// 100
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">100</span>;
</span></span><span style="display:flex;"><span>foo() <span style="color:#998;font-style:italic">// 101
</span></span></span></code></pre></div><p>上面代码中，参数<code>p</code>的默认值是<code>x + 1</code>。这时，每次调用函数<code>foo()</code>，都会重新计算<code>x + 1</code>，而不是默认<code>p</code>等于 100。</p>
<h3 id="与解构赋值默认值结合使用">与解构赋值默认值结合使用</h3>
<p>参数默认值可以与解构赋值的默认值，结合起来使用。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> foo({x, y <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">5</span>}) {
</span></span><span style="display:flex;"><span>  console.log(x, y);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>foo({}) <span style="color:#998;font-style:italic">// undefined 5
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>foo({x<span style="color:#000;font-weight:bold">:</span> <span style="color:#099">1</span>}) <span style="color:#998;font-style:italic">// 1 5
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>foo({x<span style="color:#000;font-weight:bold">:</span> <span style="color:#099">1</span>, y<span style="color:#000;font-weight:bold">:</span> <span style="color:#099">2</span>}) <span style="color:#998;font-style:italic">// 1 2
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>foo() <span style="color:#998;font-style:italic">// TypeError: Cannot read property &#39;x&#39; of undefined
</span></span></span></code></pre></div><p>上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数<code>foo()</code>的参数是一个对象时，变量<code>x</code>和<code>y</code>才会通过解构赋值生成。如果函数<code>foo()</code>调用时没提供参数，变量<code>x</code>和<code>y</code>就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> foo({x, y <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">5</span>} <span style="color:#000;font-weight:bold">=</span> {}) {
</span></span><span style="display:flex;"><span>  console.log(x, y);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>foo() <span style="color:#998;font-style:italic">// undefined 5
</span></span></span></code></pre></div><p>上面代码指定，如果没有提供参数，函数<code>foo</code>的参数默认为一个空对象。</p>
<p>下面是另一个解构赋值默认值的例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> fetch(url, { body <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;&#39;</span>, method <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;GET&#39;</span>, headers <span style="color:#000;font-weight:bold">=</span> {} }) {
</span></span><span style="display:flex;"><span>  console.log(method);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>fetch(<span style="color:#d14">&#39;http://example.com&#39;</span>, {})
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// &#34;GET&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>fetch(<span style="color:#d14">&#39;http://example.com&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面代码中，如果函数<code>fetch()</code>的第二个参数是一个对象，就可以为它的三个属性设置默认值。这种写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> fetch(url, { body <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;&#39;</span>, method <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;GET&#39;</span>, headers <span style="color:#000;font-weight:bold">=</span> {} } <span style="color:#000;font-weight:bold">=</span> {}) {
</span></span><span style="display:flex;"><span>  console.log(method);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>fetch(<span style="color:#d14">&#39;http://example.com&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// &#34;GET&#34;
</span></span></span></code></pre></div><p>上面代码中，函数<code>fetch</code>没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量<code>method</code>才会取到默认值<code>GET</code>。</p>
<p>注意，函数参数的默认值生效以后，参数解构赋值依然会进行。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> f({ a, b <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;world&#39;</span> } <span style="color:#000;font-weight:bold">=</span> { a<span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#39;hello&#39;</span> }) {
</span></span><span style="display:flex;"><span>  console.log(b);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>f() <span style="color:#998;font-style:italic">// world
</span></span></span></code></pre></div><p>上面示例中，函数<code>f()</code>调用时没有参数，所以参数默认值<code>{ a: 'hello' }</code>生效，然后再对这个默认值进行解构赋值，从而触发参数变量<code>b</code>的默认值生效。</p>
<p>作为练习，大家可以思考一下，下面两种函数写法有什么差别？</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 写法一
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">function</span> m1({x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>, y <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>} <span style="color:#000;font-weight:bold">=</span> {}) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> [x, y];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 写法二
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">function</span> m2({x, y} <span style="color:#000;font-weight:bold">=</span> { x<span style="color:#000;font-weight:bold">:</span> <span style="color:#099">0</span>, y<span style="color:#000;font-weight:bold">:</span> <span style="color:#099">0</span> }) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> [x, y];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 函数没有参数的情况
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>m1() <span style="color:#998;font-style:italic">// [0, 0]
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>m2() <span style="color:#998;font-style:italic">// [0, 0]
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// x 和 y 都有值的情况
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>m1({x<span style="color:#000;font-weight:bold">:</span> <span style="color:#099">3</span>, y<span style="color:#000;font-weight:bold">:</span> <span style="color:#099">8</span>}) <span style="color:#998;font-style:italic">// [3, 8]
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>m2({x<span style="color:#000;font-weight:bold">:</span> <span style="color:#099">3</span>, y<span style="color:#000;font-weight:bold">:</span> <span style="color:#099">8</span>}) <span style="color:#998;font-style:italic">// [3, 8]
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// x 有值，y 无值的情况
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>m1({x<span style="color:#000;font-weight:bold">:</span> <span style="color:#099">3</span>}) <span style="color:#998;font-style:italic">// [3, 0]
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>m2({x<span style="color:#000;font-weight:bold">:</span> <span style="color:#099">3</span>}) <span style="color:#998;font-style:italic">// [3, undefined]
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// x 和 y 都无值的情况
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>m1({}) <span style="color:#998;font-style:italic">// [0, 0];
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>m2({}) <span style="color:#998;font-style:italic">// [undefined, undefined]
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>m1({z<span style="color:#000;font-weight:bold">:</span> <span style="color:#099">3</span>}) <span style="color:#998;font-style:italic">// [0, 0]
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>m2({z<span style="color:#000;font-weight:bold">:</span> <span style="color:#099">3</span>}) <span style="color:#998;font-style:italic">// [undefined, undefined]
</span></span></span></code></pre></div><h3 id="参数默认值的位置">参数默认值的位置</h3>
<p>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 例一
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">function</span> f(x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>, y) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> [x, y];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>f() <span style="color:#998;font-style:italic">// [1, undefined]
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>f(<span style="color:#099">2</span>) <span style="color:#998;font-style:italic">// [2, undefined]
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>f(, <span style="color:#099">1</span>) <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>f(<span style="color:#000;font-weight:bold">undefined</span>, <span style="color:#099">1</span>) <span style="color:#998;font-style:italic">// [1, 1]
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 例二
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">function</span> f(x, y <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">5</span>, z) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> [x, y, z];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>f() <span style="color:#998;font-style:italic">// [undefined, 5, undefined]
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>f(<span style="color:#099">1</span>) <span style="color:#998;font-style:italic">// [1, 5, undefined]
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>f(<span style="color:#099">1</span>, ,<span style="color:#099">2</span>) <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>f(<span style="color:#099">1</span>, <span style="color:#000;font-weight:bold">undefined</span>, <span style="color:#099">2</span>) <span style="color:#998;font-style:italic">// [1, 5, 2]
</span></span></span></code></pre></div><p>上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入<code>undefined</code>。</p>
<p>如果传入<code>undefined</code>，将触发该参数等于默认值，<code>null</code>则没有这个效果。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> foo(x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">5</span>, y <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">6</span>) {
</span></span><span style="display:flex;"><span>  console.log(x, y);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>foo(<span style="color:#000;font-weight:bold">undefined</span>, <span style="color:#000;font-weight:bold">null</span>)
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 5 null
</span></span></span></code></pre></div><p>上面代码中，<code>x</code>参数对应<code>undefined</code>，结果触发了默认值，<code>y</code>参数等于<code>null</code>，就没有触发默认值。</p>
<h3 id="函数的-length-属性">函数的 length 属性</h3>
<p>指定了默认值以后，函数的<code>length</code>属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，<code>length</code>属性将失真。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>(<span style="color:#000;font-weight:bold">function</span> (a) {}).length <span style="color:#998;font-style:italic">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>(<span style="color:#000;font-weight:bold">function</span> (a <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">5</span>) {}).length <span style="color:#998;font-style:italic">// 0
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>(<span style="color:#000;font-weight:bold">function</span> (a, b, c <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">5</span>) {}).length <span style="color:#998;font-style:italic">// 2
</span></span></span></code></pre></div><p>上面代码中，<code>length</code>属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了 3 个参数，其中有一个参数<code>c</code>指定了默认值，因此<code>length</code>属性等于<code>3</code>减去<code>1</code>，最后得到<code>2</code>。</p>
<p>这是因为<code>length</code>属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 rest 参数也不会计入<code>length</code>属性。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>(<span style="color:#000;font-weight:bold">function</span>(...args) {}).length <span style="color:#998;font-style:italic">// 0
</span></span></span></code></pre></div><p>如果设置了默认值的参数不是尾参数，那么<code>length</code>属性也不再计入后面的参数了。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>(<span style="color:#000;font-weight:bold">function</span> (a <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>, b, c) {}).length <span style="color:#998;font-style:italic">// 0
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>(<span style="color:#000;font-weight:bold">function</span> (a, b <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>, c) {}).length <span style="color:#998;font-style:italic">// 1
</span></span></span></code></pre></div><h3 id="作用域">作用域</h3>
<p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> f(x, y <span style="color:#000;font-weight:bold">=</span> x) {
</span></span><span style="display:flex;"><span>  console.log(y);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>f(<span style="color:#099">2</span>) <span style="color:#998;font-style:italic">// 2
</span></span></span></code></pre></div><p>上面代码中，参数<code>y</code>的默认值等于变量<code>x</code>。调用函数<code>f</code>时，参数形成一个单独的作用域。在这个作用域里面，默认值变量<code>x</code>指向第一个参数<code>x</code>，而不是全局变量<code>x</code>，所以输出是<code>2</code>。</p>
<p>再看下面的例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> f(y <span style="color:#000;font-weight:bold">=</span> x) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">let</span> x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">2</span>;
</span></span><span style="display:flex;"><span>  console.log(y);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>f() <span style="color:#998;font-style:italic">// 1
</span></span></span></code></pre></div><p>上面代码中，函数<code>f</code>调用时，参数<code>y = x</code>形成一个单独的作用域。这个作用域里面，变量<code>x</code>本身没有定义，所以指向外层的全局变量<code>x</code>。函数调用时，函数体内部的局部变量<code>x</code>影响不到默认值变量<code>x</code>。</p>
<p>如果此时，全局变量<code>x</code>不存在，就会报错。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> f(y <span style="color:#000;font-weight:bold">=</span> x) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">let</span> x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">2</span>;
</span></span><span style="display:flex;"><span>  console.log(y);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>f() <span style="color:#998;font-style:italic">// ReferenceError: x is not defined
</span></span></span></code></pre></div><p>下面这样写，也会报错。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> foo(x <span style="color:#000;font-weight:bold">=</span> x) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>foo() <span style="color:#998;font-style:italic">// ReferenceError: Cannot access &#39;x&#39; before initialization
</span></span></span></code></pre></div><p>上面代码中，参数<code>x = x</code>形成一个单独作用域。实际执行的是<code>let x = x</code>，由于暂时性死区的原因，这行代码会报错。</p>
<p>如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> foo <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;outer&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> bar(func <span style="color:#000;font-weight:bold">=</span> () =&gt; foo) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">let</span> foo <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;inner&#39;</span>;
</span></span><span style="display:flex;"><span>  console.log(func());
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>bar(); <span style="color:#998;font-style:italic">// outer
</span></span></span></code></pre></div><p>上面代码中，函数<code>bar</code>的参数<code>func</code>的默认值是一个匿名函数，返回值为变量<code>foo</code>。函数参数形成的单独作用域里面，并没有定义变量<code>foo</code>，所以<code>foo</code>指向外层的全局变量<code>foo</code>，因此输出<code>outer</code>。</p>
<p>如果写成下面这样，就会报错。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> bar(func <span style="color:#000;font-weight:bold">=</span> () =&gt; foo) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">let</span> foo <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;inner&#39;</span>;
</span></span><span style="display:flex;"><span>  console.log(func());
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>bar() <span style="color:#998;font-style:italic">// ReferenceError: foo is not defined
</span></span></span></code></pre></div><p>上面代码中，匿名函数里面的<code>foo</code>指向函数外层，但是函数外层并没有声明变量<code>foo</code>，所以就报错了。</p>
<p>下面是一个更复杂的例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> foo(x, y <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">function</span>() { x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">2</span>; }) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">var</span> x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">3</span>;
</span></span><span style="display:flex;"><span>  y();
</span></span><span style="display:flex;"><span>  console.log(x);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>foo() <span style="color:#998;font-style:italic">// 3
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>x <span style="color:#998;font-style:italic">// 1
</span></span></span></code></pre></div><p>上面代码中，函数<code>foo</code>的参数形成一个单独作用域。这个作用域里面，首先声明了变量<code>x</code>，然后声明了变量<code>y</code>，<code>y</code>的默认值是一个匿名函数。这个匿名函数内部的变量<code>x</code>，指向同一个作用域的第一个参数<code>x</code>。函数<code>foo</code>内部又声明了一个内部变量<code>x</code>，该变量与第一个参数<code>x</code>由于不是同一个作用域，所以不是同一个变量，因此执行<code>y</code>后，内部变量<code>x</code>和外部全局变量<code>x</code>的值都没变。</p>
<p>如果将<code>var x = 3</code>的<code>var</code>去除，函数<code>foo</code>的内部变量<code>x</code>就指向第一个参数<code>x</code>，与匿名函数内部的<code>x</code>是一致的，所以最后输出的就是<code>2</code>，而外层的全局变量<code>x</code>依然不受影响。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> foo(x, y <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">function</span>() { x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">2</span>; }) {
</span></span><span style="display:flex;"><span>  x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">3</span>;
</span></span><span style="display:flex;"><span>  y();
</span></span><span style="display:flex;"><span>  console.log(x);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>foo() <span style="color:#998;font-style:italic">// 2
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>x <span style="color:#998;font-style:italic">// 1
</span></span></span></code></pre></div><h3 id="应用">应用</h3>
<p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> throwIfMissing() {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">throw</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Error</span>(<span style="color:#d14">&#39;Missing parameter&#39;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> foo(mustBeProvided <span style="color:#000;font-weight:bold">=</span> throwIfMissing()) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> mustBeProvided;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>foo()
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Error: Missing parameter
</span></span></span></code></pre></div><p>上面代码的<code>foo</code>函数，如果调用的时候没有参数，就会调用默认值<code>throwIfMissing</code>函数，从而抛出一个错误。</p>
<p>从上面代码还可以看到，参数<code>mustBeProvided</code>的默认值等于<code>throwIfMissing</code>函数的运行结果（注意函数名<code>throwIfMissing</code>之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行。如果参数已经赋值，默认值中的函数就不会运行。</p>
<p>另外，可以将参数默认值设为<code>undefined</code>，表明这个参数是可以省略的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> foo(optional <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">undefined</span>) { <span style="color:#a61717;background-color:#e3d2d2">···</span> }
</span></span></code></pre></div><h2 id="rest-参数">rest 参数</h2>
<p>ES6 引入 rest 参数（形式为<code>...变量名</code>），用于获取函数的多余参数，这样就不需要使用<code>arguments</code>对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> add(...values) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">let</span> sum <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">for</span> (<span style="color:#000;font-weight:bold">var</span> val <span style="color:#000;font-weight:bold">of</span> values) {
</span></span><span style="display:flex;"><span>    sum <span style="color:#000;font-weight:bold">+=</span> val;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> sum;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add(<span style="color:#099">2</span>, <span style="color:#099">5</span>, <span style="color:#099">3</span>) <span style="color:#998;font-style:italic">// 10
</span></span></span></code></pre></div><p>上面代码的<code>add</code>函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。</p>
<p>下面是一个 rest 参数代替<code>arguments</code>变量的例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// arguments变量的写法
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">function</span> sortNumbers() {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">Array</span>.from(arguments).sort();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// rest参数的写法
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> sortNumbers <span style="color:#000;font-weight:bold">=</span> (...numbers) =&gt; numbers.sort();
</span></span></code></pre></div><p>上面代码的两种写法，比较后可以发现，rest 参数的写法更自然也更简洁。</p>
<p><code>arguments</code>对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用<code>Array.from</code>先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。下面是一个利用 rest 参数改写数组<code>push</code>方法的例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> push(array, ...items) {
</span></span><span style="display:flex;"><span>  items.forEach(<span style="color:#000;font-weight:bold">function</span>(item) {
</span></span><span style="display:flex;"><span>    array.push(item);
</span></span><span style="display:flex;"><span>    console.log(item);
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> a <span style="color:#000;font-weight:bold">=</span> [];
</span></span><span style="display:flex;"><span>push(a, <span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>)
</span></span></code></pre></div><p>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">function</span> f(a, ...b, c) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>函数的<code>length</code>属性，不包括 rest 参数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>(<span style="color:#000;font-weight:bold">function</span>(a) {}).length  <span style="color:#998;font-style:italic">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>(<span style="color:#000;font-weight:bold">function</span>(...a) {}).length  <span style="color:#998;font-style:italic">// 0
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>(<span style="color:#000;font-weight:bold">function</span>(a, ...b) {}).length  <span style="color:#998;font-style:italic">// 1
</span></span></span></code></pre></div><h2 id="严格模式">严格模式</h2>
<p>从 ES5 开始，函数内部可以设定为严格模式。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> doSomething(a, b) {
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#39;use strict&#39;</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// code
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">function</span> doSomething(a, b <span style="color:#000;font-weight:bold">=</span> a) {
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#39;use strict&#39;</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// code
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> doSomething <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">function</span> ({a, b}) {
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#39;use strict&#39;</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// code
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> doSomething <span style="color:#000;font-weight:bold">=</span> (...a) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#39;use strict&#39;</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// code
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> obj <span style="color:#000;font-weight:bold">=</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  doSomething({a, b}) {
</span></span><span style="display:flex;"><span>    <span style="color:#d14">&#39;use strict&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// code
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">function</span> doSomething(value <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">070</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#39;use strict&#39;</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> value;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码中，参数<code>value</code>的默认值是八进制数<code>070</code>，但是严格模式下不能用前缀<code>0</code>表示八进制，所以应该报错。但是实际上，JavaScript 引擎会先成功执行<code>value = 070</code>，然后进入函数体内部，发现需要用严格模式执行，这时才会报错。</p>
<p>虽然可以先解析函数体代码，再执行参数代码，但是这样无疑就增加了复杂性。因此，标准索性禁止了这种用法，只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显式指定严格模式。</p>
<p>两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#d14">&#39;use strict&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> doSomething(a, b <span style="color:#000;font-weight:bold">=</span> a) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// code
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>第二种是把函数包在一个无参数的立即执行函数里面。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> doSomething <span style="color:#000;font-weight:bold">=</span> (<span style="color:#000;font-weight:bold">function</span> () {
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#39;use strict&#39;</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">function</span>(value <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">42</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> value;
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>}());
</span></span></code></pre></div><h2 id="name-属性">name 属性</h2>
<p>函数的<code>name</code>属性，返回该函数的函数名。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> foo() {}
</span></span><span style="display:flex;"><span>foo.name <span style="color:#998;font-style:italic">// &#34;foo&#34;
</span></span></span></code></pre></div><p>这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。</p>
<p>需要注意的是，ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的<code>name</code>属性，会返回空字符串，而 ES6 的<code>name</code>属性会返回实际的函数名。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> f <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">function</span> () {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// ES5
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>f.name <span style="color:#998;font-style:italic">// &#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// ES6
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>f.name <span style="color:#998;font-style:italic">// &#34;f&#34;
</span></span></span></code></pre></div><p>上面代码中，变量<code>f</code>等于一个匿名函数，ES5 和 ES6 的<code>name</code>属性返回的值不一样。</p>
<p>如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的<code>name</code>属性都返回这个具名函数原本的名字。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> bar <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">function</span> baz() {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// ES5
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>bar.name <span style="color:#998;font-style:italic">// &#34;baz&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// ES6
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>bar.name <span style="color:#998;font-style:italic">// &#34;baz&#34;
</span></span></span></code></pre></div><p><code>Function</code>构造函数返回的函数实例，<code>name</code>属性的值为<code>anonymous</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>(<span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Function</span>).name <span style="color:#998;font-style:italic">// &#34;anonymous&#34;
</span></span></span></code></pre></div><p><code>bind</code>返回的函数，<code>name</code>属性值会加上<code>bound</code>前缀。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> foo() {};
</span></span><span style="display:flex;"><span>foo.bind({}).name <span style="color:#998;font-style:italic">// &#34;bound foo&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>(<span style="color:#000;font-weight:bold">function</span>(){}).bind({}).name <span style="color:#998;font-style:italic">// &#34;bound &#34;
</span></span></span></code></pre></div><h2 id="箭头函数">箭头函数</h2>
<h3 id="基本用法-1">基本用法</h3>
<p>ES6 允许使用“箭头”（<code>=&gt;</code>）定义函数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> f <span style="color:#000;font-weight:bold">=</span> v =&gt; v;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 等同于
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">var</span> f <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">function</span> (v) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> v;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> f <span style="color:#000;font-weight:bold">=</span> () =&gt; <span style="color:#099">5</span>;
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 等同于
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">var</span> f <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">function</span> () { <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">5</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> sum <span style="color:#000;font-weight:bold">=</span> (num1, num2) =&gt; num1 <span style="color:#000;font-weight:bold">+</span> num2;
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 等同于
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">var</span> sum <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">function</span>(num1, num2) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> num1 <span style="color:#000;font-weight:bold">+</span> num2;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<code>return</code>语句返回。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> sum <span style="color:#000;font-weight:bold">=</span> (num1, num2) =&gt; { <span style="color:#000;font-weight:bold">return</span> num1 <span style="color:#000;font-weight:bold">+</span> num2; }
</span></span></code></pre></div><p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">let</span> getTempItem <span style="color:#000;font-weight:bold">=</span> id =&gt; { id<span style="color:#000;font-weight:bold">:</span> id, name<span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#34;Temp&#34;</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 不报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">let</span> getTempItem <span style="color:#000;font-weight:bold">=</span> id =&gt; ({ id<span style="color:#000;font-weight:bold">:</span> id, name<span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#34;Temp&#34;</span> });
</span></span></code></pre></div><p>下面是一种特殊情况，虽然可以运行，但会得到错误的结果。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> foo <span style="color:#000;font-weight:bold">=</span> () =&gt; { a<span style="color:#000;font-weight:bold">:</span> <span style="color:#099">1</span> };
</span></span><span style="display:flex;"><span>foo() <span style="color:#998;font-style:italic">// undefined
</span></span></span></code></pre></div><p>上面代码中，原始意图是返回一个对象<code>{ a: 1 }</code>，但是由于引擎认为大括号是代码块，所以执行了一行语句<code>a: 1</code>。这时，<code>a</code>可以被解释为语句的标签，因此实际执行的语句是<code>1;</code>，然后函数就结束了，没有返回值。</p>
<p>如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> fn <span style="color:#000;font-weight:bold">=</span> () =&gt; <span style="color:#000;font-weight:bold">void</span> doesNotReturn();
</span></span></code></pre></div><p>箭头函数可以与变量解构结合使用。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> full <span style="color:#000;font-weight:bold">=</span> ({ first, last }) =&gt; first <span style="color:#000;font-weight:bold">+</span> <span style="color:#d14">&#39; &#39;</span> <span style="color:#000;font-weight:bold">+</span> last;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 等同于
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">function</span> full(person) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> person.first <span style="color:#000;font-weight:bold">+</span> <span style="color:#d14">&#39; &#39;</span> <span style="color:#000;font-weight:bold">+</span> person.last;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>箭头函数使得表达更加简洁。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> isEven <span style="color:#000;font-weight:bold">=</span> n =&gt; n <span style="color:#000;font-weight:bold">%</span> <span style="color:#099">2</span> <span style="color:#000;font-weight:bold">===</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> square <span style="color:#000;font-weight:bold">=</span> n =&gt; n <span style="color:#000;font-weight:bold">*</span> n;
</span></span></code></pre></div><p>上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。</p>
<p>箭头函数的一个用处是简化回调函数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 普通函数写法
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>[<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>].map(<span style="color:#000;font-weight:bold">function</span> (x) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> x <span style="color:#000;font-weight:bold">*</span> x;
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 箭头函数写法
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>[<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>].map(x =&gt; x <span style="color:#000;font-weight:bold">*</span> x);
</span></span></code></pre></div><p>另一个例子是</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 普通函数写法
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">var</span> result <span style="color:#000;font-weight:bold">=</span> values.sort(<span style="color:#000;font-weight:bold">function</span> (a, b) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> a <span style="color:#000;font-weight:bold">-</span> b;
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 箭头函数写法
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">var</span> result <span style="color:#000;font-weight:bold">=</span> values.sort((a, b) =&gt; a <span style="color:#000;font-weight:bold">-</span> b);
</span></span></code></pre></div><p>下面是 rest 参数与箭头函数结合的例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> numbers <span style="color:#000;font-weight:bold">=</span> (...nums) =&gt; nums;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>numbers(<span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>, <span style="color:#099">5</span>)
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// [1,2,3,4,5]
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> headAndTail <span style="color:#000;font-weight:bold">=</span> (head, ...tail) =&gt; [head, tail];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>headAndTail(<span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>, <span style="color:#099">5</span>)
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// [1,[2,3,4,5]]
</span></span></span></code></pre></div><h3 id="使用注意点">使用注意点</h3>
<p>箭头函数有几个使用注意点。</p>
<p>（1）箭头函数没有自己的<code>this</code>对象（详见下文）。</p>
<p>（2）不可以当作构造函数，也就是说，不可以对箭头函数使用<code>new</code>命令，否则会抛出一个错误。</p>
<p>（3）不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p>
<p>（4）不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数。</p>
<p>上面四点中，最重要的是第一点。对于普通函数来说，内部的<code>this</code>指向函数运行时所在的对象，但是这一点对箭头函数不成立。它没有自己的<code>this</code>对象，内部的<code>this</code>就是定义时上层作用域中的<code>this</code>。也就是说，箭头函数内部的<code>this</code>指向是固定的，相比之下，普通函数的<code>this</code>指向是可变的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> foo() {
</span></span><span style="display:flex;"><span>  setTimeout(() =&gt; {
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#d14">&#39;id:&#39;</span>, <span style="color:#000;font-weight:bold">this</span>.id);
</span></span><span style="display:flex;"><span>  }, <span style="color:#099">100</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> id <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">21</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>foo.call({ id<span style="color:#000;font-weight:bold">:</span> <span style="color:#099">42</span> });
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// id: 42
</span></span></span></code></pre></div><p>上面代码中，<code>setTimeout()</code>的参数是一个箭头函数，这个箭头函数的定义生效是在<code>foo</code>函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时<code>this</code>应该指向全局对象<code>window</code>，这时应该输出<code>21</code>。但是，箭头函数导致<code>this</code>总是指向函数定义生效时所在的对象（本例是<code>{id: 42}</code>），所以打印出来的是<code>42</code>。</p>
<p>下面例子是回调函数分别为箭头函数和普通函数，对比它们内部的<code>this</code>指向。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> Timer() {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">this</span>.s1 <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">this</span>.s2 <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// 箭头函数
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  setInterval(() =&gt; <span style="color:#000;font-weight:bold">this</span>.s1<span style="color:#000;font-weight:bold">++</span>, <span style="color:#099">1000</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// 普通函数
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  setInterval(<span style="color:#000;font-weight:bold">function</span> () {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.s2<span style="color:#000;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>  }, <span style="color:#099">1000</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> timer <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> Timer();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>setTimeout(() =&gt; console.log(<span style="color:#d14">&#39;s1: &#39;</span>, timer.s1), <span style="color:#099">3100</span>);
</span></span><span style="display:flex;"><span>setTimeout(() =&gt; console.log(<span style="color:#d14">&#39;s2: &#39;</span>, timer.s2), <span style="color:#099">3100</span>);
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// s1: 3
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// s2: 0
</span></span></span></code></pre></div><p>上面代码中，<code>Timer</code>函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的<code>this</code>绑定定义时所在的作用域（即<code>Timer</code>函数），后者的<code>this</code>指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后，<code>timer.s1</code>被更新了 3 次，而<code>timer.s2</code>一次都没更新。</p>
<p>箭头函数实际上可以让<code>this</code>指向固定化，绑定<code>this</code>使得它不再可变，这种特性很有利于封装回调函数。下面是一个例子，DOM 事件的回调函数封装在一个对象里面。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> handler <span style="color:#000;font-weight:bold">=</span> {
</span></span><span style="display:flex;"><span>  id<span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#39;123456&#39;</span>,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  init<span style="color:#000;font-weight:bold">:</span> <span style="color:#000;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#0086b3">document</span>.addEventListener(<span style="color:#d14">&#39;click&#39;</span>,
</span></span><span style="display:flex;"><span>      event =&gt; <span style="color:#000;font-weight:bold">this</span>.doSomething(event.type), <span style="color:#000;font-weight:bold">false</span>);
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  doSomething<span style="color:#000;font-weight:bold">:</span> <span style="color:#000;font-weight:bold">function</span>(type) {
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#d14">&#39;Handling &#39;</span> <span style="color:#000;font-weight:bold">+</span> type  <span style="color:#000;font-weight:bold">+</span> <span style="color:#d14">&#39; for &#39;</span> <span style="color:#000;font-weight:bold">+</span> <span style="color:#000;font-weight:bold">this</span>.id);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>上面代码的<code>init()</code>方法中，使用了箭头函数，这导致这个箭头函数里面的<code>this</code>，总是指向<code>handler</code>对象。如果回调函数是普通函数，那么运行<code>this.doSomething()</code>这一行会报错，因为此时<code>this</code>指向<code>document</code>对象。</p>
<p>总之，箭头函数根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码块的<code>this</code>。正是因为它没有<code>this</code>，所以也就不能用作构造函数。</p>
<p>下面是 Babel 转箭头函数产生的 ES5 代码，就能清楚地说明<code>this</code>的指向。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// ES6
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">function</span> foo() {
</span></span><span style="display:flex;"><span>  setTimeout(() =&gt; {
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#d14">&#39;id:&#39;</span>, <span style="color:#000;font-weight:bold">this</span>.id);
</span></span><span style="display:flex;"><span>  }, <span style="color:#099">100</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// ES5
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">function</span> foo() {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">var</span> _this <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  setTimeout(<span style="color:#000;font-weight:bold">function</span> () {
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#d14">&#39;id:&#39;</span>, _this.id);
</span></span><span style="display:flex;"><span>  }, <span style="color:#099">100</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码中，转换后的 ES5 版本清楚地说明了，箭头函数里面根本没有自己的<code>this</code>，而是引用外层的<code>this</code>。</p>
<p>请问下面的代码之中，<code>this</code>的指向有几个？</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> foo() {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> () =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> () =&gt; {
</span></span><span style="display:flex;"><span>      <span style="color:#000;font-weight:bold">return</span> () =&gt; {
</span></span><span style="display:flex;"><span>        console.log(<span style="color:#d14">&#39;id:&#39;</span>, <span style="color:#000;font-weight:bold">this</span>.id);
</span></span><span style="display:flex;"><span>      };
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> f <span style="color:#000;font-weight:bold">=</span> foo.call({id<span style="color:#000;font-weight:bold">:</span> <span style="color:#099">1</span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> t1 <span style="color:#000;font-weight:bold">=</span> f.call({id<span style="color:#000;font-weight:bold">:</span> <span style="color:#099">2</span>})()(); <span style="color:#998;font-style:italic">// id: 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">var</span> t2 <span style="color:#000;font-weight:bold">=</span> f().call({id<span style="color:#000;font-weight:bold">:</span> <span style="color:#099">3</span>})(); <span style="color:#998;font-style:italic">// id: 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">var</span> t3 <span style="color:#000;font-weight:bold">=</span> f()().call({id<span style="color:#000;font-weight:bold">:</span> <span style="color:#099">4</span>}); <span style="color:#998;font-style:italic">// id: 1
</span></span></span></code></pre></div><p>答案是<code>this</code>的指向只有一个，就是函数<code>foo</code>的<code>this</code>，这是因为所有的内层函数都是箭头函数，都没有自己的<code>this</code>，它们的<code>this</code>其实都是最外层<code>foo</code>函数的<code>this</code>。所以不管怎么嵌套，<code>t1</code>、<code>t2</code>、<code>t3</code>都输出同样的结果。如果这个例子的所有内层函数都写成普通函数，那么每个函数的<code>this</code>都指向运行时所在的不同对象。</p>
<p>除了<code>this</code>，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：<code>arguments</code>、<code>super</code>、<code>new.target</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> foo() {
</span></span><span style="display:flex;"><span>  setTimeout(() =&gt; {
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#d14">&#39;args:&#39;</span>, arguments);
</span></span><span style="display:flex;"><span>  }, <span style="color:#099">100</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>foo(<span style="color:#099">2</span>, <span style="color:#099">4</span>, <span style="color:#099">6</span>, <span style="color:#099">8</span>)
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// args: [2, 4, 6, 8]
</span></span></span></code></pre></div><p>上面代码中，箭头函数内部的变量<code>arguments</code>，其实是函数<code>foo</code>的<code>arguments</code>变量。</p>
<p>另外，由于箭头函数没有自己的<code>this</code>，所以当然也就不能用<code>call()</code>、<code>apply()</code>、<code>bind()</code>这些方法去改变<code>this</code>的指向。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>(<span style="color:#000;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> [
</span></span><span style="display:flex;"><span>    (() =&gt; <span style="color:#000;font-weight:bold">this</span>.x).bind({ x<span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#39;inner&#39;</span> })()
</span></span><span style="display:flex;"><span>  ];
</span></span><span style="display:flex;"><span>}).call({ x<span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#39;outer&#39;</span> });
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// [&#39;outer&#39;]
</span></span></span></code></pre></div><p>上面代码中，箭头函数没有自己的<code>this</code>，所以<code>bind</code>方法无效，内部的<code>this</code>指向外部的<code>this</code>。</p>
<p>长期以来，JavaScript 语言的<code>this</code>对象一直是一个令人头痛的问题，在对象方法中使用<code>this</code>，必须非常小心。箭头函数”绑定”<code>this</code>，很大程度上解决了这个困扰。</p>
<h3 id="不适用场合">不适用场合</h3>
<p>由于箭头函数使得<code>this</code>从“动态”变成“静态”，下面两个场合不应该使用箭头函数。</p>
<p>第一个场合是定义对象的方法，且该方法内部包括<code>this</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> cat <span style="color:#000;font-weight:bold">=</span> {
</span></span><span style="display:flex;"><span>  lives<span style="color:#000;font-weight:bold">:</span> <span style="color:#099">9</span>,
</span></span><span style="display:flex;"><span>  jumps<span style="color:#000;font-weight:bold">:</span> () =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.lives<span style="color:#000;font-weight:bold">--</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码中，<code>cat.jumps()</code>方法是一个箭头函数，这是错误的。调用<code>cat.jumps()</code>时，如果是普通函数，该方法内部的<code>this</code>指向<code>cat</code>；如果写成上面那样的箭头函数，使得<code>this</code>指向全局对象，因此不会得到预期结果。这是因为对象不构成单独的作用域，导致<code>jumps</code>箭头函数定义时的作用域就是全局作用域。</p>
<p>再看一个例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>globalThis.s <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">21</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> obj <span style="color:#000;font-weight:bold">=</span> {
</span></span><span style="display:flex;"><span>  s<span style="color:#000;font-weight:bold">:</span> <span style="color:#099">42</span>,
</span></span><span style="display:flex;"><span>  m<span style="color:#000;font-weight:bold">:</span> () =&gt; console.log(<span style="color:#000;font-weight:bold">this</span>.s)
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>obj.m() <span style="color:#998;font-style:italic">// 21
</span></span></span></code></pre></div><p>上面例子中，<code>obj.m()</code>使用箭头函数定义。JavaScript 引擎的处理方法是，先在全局空间生成这个箭头函数，然后赋值给<code>obj.m</code>，这导致箭头函数内部的<code>this</code>指向全局对象，所以<code>obj.m()</code>输出的是全局空间的<code>21</code>，而不是对象内部的<code>42</code>。上面的代码实际上等同于下面的代码。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>globalThis.s <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">21</span>;
</span></span><span style="display:flex;"><span>globalThis.m <span style="color:#000;font-weight:bold">=</span> () =&gt; console.log(<span style="color:#000;font-weight:bold">this</span>.s);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> obj <span style="color:#000;font-weight:bold">=</span> {
</span></span><span style="display:flex;"><span>  s<span style="color:#000;font-weight:bold">:</span> <span style="color:#099">42</span>,
</span></span><span style="display:flex;"><span>  m<span style="color:#000;font-weight:bold">:</span> globalThis.m
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>obj.m() <span style="color:#998;font-style:italic">// 21
</span></span></span></code></pre></div><p>由于上面这个原因，对象的属性建议使用传统的写法定义，不要用箭头函数定义。</p>
<p>第二个场合是需要动态<code>this</code>的时候，也不应使用箭头函数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> button <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">document</span>.getElementById(<span style="color:#d14">&#39;press&#39;</span>);
</span></span><span style="display:flex;"><span>button.addEventListener(<span style="color:#d14">&#39;click&#39;</span>, () =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">this</span>.classList.toggle(<span style="color:#d14">&#39;on&#39;</span>);
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><p>上面代码运行时，点击按钮会报错，因为<code>button</code>的监听函数是一个箭头函数，导致里面的<code>this</code>就是全局对象。如果改成普通函数，<code>this</code>就会动态指向被点击的按钮对象。</p>
<p>另外，如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性。</p>
<h3 id="嵌套的箭头函数">嵌套的箭头函数</h3>
<p>箭头函数内部，还可以再使用箭头函数。下面是一个 ES5 语法的多重嵌套函数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> insert(value) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> {into<span style="color:#000;font-weight:bold">:</span> <span style="color:#000;font-weight:bold">function</span> (array) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> {after<span style="color:#000;font-weight:bold">:</span> <span style="color:#000;font-weight:bold">function</span> (afterValue) {
</span></span><span style="display:flex;"><span>      array.splice(array.indexOf(afterValue) <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>, <span style="color:#099">0</span>, value);
</span></span><span style="display:flex;"><span>      <span style="color:#000;font-weight:bold">return</span> array;
</span></span><span style="display:flex;"><span>    }};
</span></span><span style="display:flex;"><span>  }};
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>insert(<span style="color:#099">2</span>).into([<span style="color:#099">1</span>, <span style="color:#099">3</span>]).after(<span style="color:#099">1</span>); <span style="color:#998;font-style:italic">//[1, 2, 3]
</span></span></span></code></pre></div><p>上面这个函数，可以使用箭头函数改写。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> insert <span style="color:#000;font-weight:bold">=</span> (value) =&gt; ({into<span style="color:#000;font-weight:bold">:</span> (array) =&gt; ({after<span style="color:#000;font-weight:bold">:</span> (afterValue) =&gt; {
</span></span><span style="display:flex;"><span>  array.splice(array.indexOf(afterValue) <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>, <span style="color:#099">0</span>, value);
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> array;
</span></span><span style="display:flex;"><span>}})});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>insert(<span style="color:#099">2</span>).into([<span style="color:#099">1</span>, <span style="color:#099">3</span>]).after(<span style="color:#099">1</span>); <span style="color:#998;font-style:italic">//[1, 2, 3]
</span></span></span></code></pre></div><p>下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> pipeline <span style="color:#000;font-weight:bold">=</span> (...funcs) =&gt;
</span></span><span style="display:flex;"><span>  val =&gt; funcs.reduce((a, b) =&gt; b(a), val);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> plus1 <span style="color:#000;font-weight:bold">=</span> a =&gt; a <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> mult2 <span style="color:#000;font-weight:bold">=</span> a =&gt; a <span style="color:#000;font-weight:bold">*</span> <span style="color:#099">2</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> addThenMult <span style="color:#000;font-weight:bold">=</span> pipeline(plus1, mult2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>addThenMult(<span style="color:#099">5</span>)
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 12
</span></span></span></code></pre></div><p>如果觉得上面的写法可读性比较差，也可以采用下面的写法。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> plus1 <span style="color:#000;font-weight:bold">=</span> a =&gt; a <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> mult2 <span style="color:#000;font-weight:bold">=</span> a =&gt; a <span style="color:#000;font-weight:bold">*</span> <span style="color:#099">2</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>mult2(plus1(<span style="color:#099">5</span>))
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 12
</span></span></span></code></pre></div><p>箭头函数还有一个功能，就是可以很方便地改写 λ 演算。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// λ演算的写法
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>fix <span style="color:#000;font-weight:bold">=</span> λf.(λx.f(λv.x(x)(v)))(λx.f(λv.x(x)(v)))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// ES6的写法
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">var</span> fix <span style="color:#000;font-weight:bold">=</span> f =&gt; (x =&gt; f(v =&gt; x(x)(v)))
</span></span><span style="display:flex;"><span>               (x =&gt; f(v =&gt; x(x)(v)));
</span></span></code></pre></div><p>上面两种写法，几乎是一一对应的。由于 λ 演算对于计算机科学非常重要，这使得我们可以用 ES6 作为替代工具，探索计算机科学。</p>
<h2 id="尾调用优化">尾调用优化</h2>
<h3 id="什么是尾调用">什么是尾调用？</h3>
<p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> f(x){
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> g(x);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码中，函数<code>f</code>的最后一步是调用函数<code>g</code>，这就叫尾调用。</p>
<p>以下三种情况，都不属于尾调用。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 情况一
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">function</span> f(x){
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">let</span> y <span style="color:#000;font-weight:bold">=</span> g(x);
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> y;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 情况二
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">function</span> f(x){
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> g(x) <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 情况三
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">function</span> f(x){
</span></span><span style="display:flex;"><span>  g(x);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码中，情况一是调用函数<code>g</code>之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> f(x){
</span></span><span style="display:flex;"><span>  g(x);
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">undefined</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> f(x) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">if</span> (x <span style="color:#000;font-weight:bold">&gt;</span> <span style="color:#099">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> m(x)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> n(x);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码中，函数<code>m</code>和<code>n</code>都属于尾调用，因为它们都是函数<code>f</code>的最后一步操作。</p>
<h3 id="尾调用优化-1">尾调用优化</h3>
<p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p>
<p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数<code>A</code>的内部调用函数<code>B</code>，那么在<code>A</code>的调用帧上方，还会形成一个<code>B</code>的调用帧。等到<code>B</code>运行结束，将结果返回到<code>A</code>，<code>B</code>的调用帧才会消失。如果函数<code>B</code>内部还调用函数<code>C</code>，那就还有一个<code>C</code>的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p>
<p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> f() {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">let</span> m <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">let</span> n <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">2</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> g(m <span style="color:#000;font-weight:bold">+</span> n);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>f();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 等同于
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">function</span> f() {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> g(<span style="color:#099">3</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>f();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 等同于
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>g(<span style="color:#099">3</span>);
</span></span></code></pre></div><p>上面代码中，如果函数<code>g</code>不是尾调用，函数<code>f</code>就需要保存内部变量<code>m</code>和<code>n</code>的值、<code>g</code>的调用位置等信息。但由于调用<code>g</code>之后，函数<code>f</code>就结束了，所以执行到最后一步，完全可以删除<code>f(x)</code>的调用帧，只保留<code>g(3)</code>的调用帧。</p>
<p>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p>
<p>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> addOne(a){
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">var</span> one <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">function</span> inner(b){
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> b <span style="color:#000;font-weight:bold">+</span> one;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> inner(a);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的函数不会进行尾调用优化，因为内层函数<code>inner</code>用到了外层函数<code>addOne</code>的内部变量<code>one</code>。</p>
<p>注意，目前只有 Safari 浏览器支持尾调用优化，Chrome 和 Firefox 都不支持。</p>
<h3 id="尾递归">尾递归</h3>
<p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>
<p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> factorial(n) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">if</span> (n <span style="color:#000;font-weight:bold">===</span> <span style="color:#099">1</span>) <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> n <span style="color:#000;font-weight:bold">*</span> factorial(n <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>factorial(<span style="color:#099">5</span>) <span style="color:#998;font-style:italic">// 120
</span></span></span></code></pre></div><p>上面代码是一个阶乘函数，计算<code>n</code>的阶乘，最多需要保存<code>n</code>个调用记录，复杂度 O(n) 。</p>
<p>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> factorial(n, total) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">if</span> (n <span style="color:#000;font-weight:bold">===</span> <span style="color:#099">1</span>) <span style="color:#000;font-weight:bold">return</span> total;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> factorial(n <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>, n <span style="color:#000;font-weight:bold">*</span> total);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>factorial(<span style="color:#099">5</span>, <span style="color:#099">1</span>) <span style="color:#998;font-style:italic">// 120
</span></span></span></code></pre></div><p>还有一个比较著名的例子，就是计算 Fibonacci 数列，也能充分说明尾递归优化的重要性。</p>
<p>非尾递归的 Fibonacci 数列实现如下。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> Fibonacci (n) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">if</span> ( n <span style="color:#000;font-weight:bold">&lt;=</span> <span style="color:#099">1</span> ) {<span style="color:#000;font-weight:bold">return</span> <span style="color:#099">1</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> Fibonacci(n <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>) <span style="color:#000;font-weight:bold">+</span> Fibonacci(n <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">2</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Fibonacci(<span style="color:#099">10</span>) <span style="color:#998;font-style:italic">// 89
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>Fibonacci(<span style="color:#099">100</span>) <span style="color:#998;font-style:italic">// 超时
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>Fibonacci(<span style="color:#099">500</span>) <span style="color:#998;font-style:italic">// 超时
</span></span></span></code></pre></div><p>尾递归优化过的 Fibonacci 数列实现如下。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> Fibonacci2 (n , ac1 <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span> , ac2 <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">if</span>( n <span style="color:#000;font-weight:bold">&lt;=</span> <span style="color:#099">1</span> ) {<span style="color:#000;font-weight:bold">return</span> ac2};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> Fibonacci2 (n <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>, ac2, ac1 <span style="color:#000;font-weight:bold">+</span> ac2);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Fibonacci2(<span style="color:#099">100</span>) <span style="color:#998;font-style:italic">// 573147844013817200000
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>Fibonacci2(<span style="color:#099">1000</span>) <span style="color:#998;font-style:italic">// 7.0330367711422765e+208
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>Fibonacci2(<span style="color:#099">10000</span>) <span style="color:#998;font-style:italic">// Infinity
</span></span></span></code></pre></div><p>由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 亦是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出（或者层层递归造成的超时），相对节省内存。</p>
<h3 id="递归函数的改写">递归函数的改写</h3>
<p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量<code>total</code>，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算<code>5</code>的阶乘，需要传入两个参数<code>5</code>和<code>1</code>？</p>
<p>两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> tailFactorial(n, total) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">if</span> (n <span style="color:#000;font-weight:bold">===</span> <span style="color:#099">1</span>) <span style="color:#000;font-weight:bold">return</span> total;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> tailFactorial(n <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>, n <span style="color:#000;font-weight:bold">*</span> total);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> factorial(n) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> tailFactorial(n, <span style="color:#099">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>factorial(<span style="color:#099">5</span>) <span style="color:#998;font-style:italic">// 120
</span></span></span></code></pre></div><p>上面代码通过一个正常形式的阶乘函数<code>factorial</code>，调用尾递归函数<code>tailFactorial</code>，看起来就正常多了。</p>
<p>函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> currying(fn, n) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">function</span> (m) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> fn.call(<span style="color:#000;font-weight:bold">this</span>, m, n);
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> tailFactorial(n, total) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">if</span> (n <span style="color:#000;font-weight:bold">===</span> <span style="color:#099">1</span>) <span style="color:#000;font-weight:bold">return</span> total;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> tailFactorial(n <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>, n <span style="color:#000;font-weight:bold">*</span> total);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> factorial <span style="color:#000;font-weight:bold">=</span> currying(tailFactorial, <span style="color:#099">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>factorial(<span style="color:#099">5</span>) <span style="color:#998;font-style:italic">// 120
</span></span></span></code></pre></div><p>上面代码通过柯里化，将尾递归函数<code>tailFactorial</code>变为只接受一个参数的<code>factorial</code>。</p>
<p>第二种方法就简单多了，就是采用 ES6 的函数默认值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> factorial(n, total <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">if</span> (n <span style="color:#000;font-weight:bold">===</span> <span style="color:#099">1</span>) <span style="color:#000;font-weight:bold">return</span> total;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> factorial(n <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>, n <span style="color:#000;font-weight:bold">*</span> total);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>factorial(<span style="color:#099">5</span>) <span style="color:#998;font-style:italic">// 120
</span></span></span></code></pre></div><p>上面代码中，参数<code>total</code>有默认值<code>1</code>，所以调用时不用提供这个值。</p>
<p>总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如 Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。</p>
<h3 id="严格模式-1">严格模式</h3>
<p>ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</p>
<p>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p>
<ul>
<li><code>func.arguments</code>：返回调用时函数的参数。</li>
<li><code>func.caller</code>：返回调用当前函数的那个函数。</li>
</ul>
<p>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> restricted() {
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#39;use strict&#39;</span>;
</span></span><span style="display:flex;"><span>  restricted.caller;    <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  restricted.arguments; <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>restricted();
</span></span></code></pre></div><h3 id="尾递归优化的实现">尾递归优化的实现</h3>
<p>尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。</p>
<p>它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。</p>
<p>下面是一个正常的递归函数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> sum(x, y) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">if</span> (y <span style="color:#000;font-weight:bold">&gt;</span> <span style="color:#099">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> sum(x <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>, y <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>);
</span></span><span style="display:flex;"><span>  } <span style="color:#000;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> x;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sum(<span style="color:#099">1</span>, <span style="color:#099">100000</span>)
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Uncaught RangeError: Maximum call stack size exceeded(…)
</span></span></span></code></pre></div><p>上面代码中，<code>sum</code>是一个递归函数，参数<code>x</code>是需要累加的值，参数<code>y</code>控制递归次数。一旦指定<code>sum</code>递归 100000 次，就会报错，提示超出调用栈的最大次数。</p>
<p>蹦床函数（trampoline）可以将递归执行转为循环执行。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> trampoline(f) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">while</span> (f <span style="color:#000;font-weight:bold">&amp;&amp;</span> f <span style="color:#000;font-weight:bold">instanceof</span> <span style="color:#0086b3">Function</span>) {
</span></span><span style="display:flex;"><span>    f <span style="color:#000;font-weight:bold">=</span> f();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> f;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面就是蹦床函数的一个实现，它接受一个函数<code>f</code>作为参数。只要<code>f</code>执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。</p>
<p>然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> sum(x, y) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">if</span> (y <span style="color:#000;font-weight:bold">&gt;</span> <span style="color:#099">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> sum.bind(<span style="color:#000;font-weight:bold">null</span>, x <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>, y <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>);
</span></span><span style="display:flex;"><span>  } <span style="color:#000;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> x;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码中，<code>sum</code>函数的每次执行，都会返回自身的另一个版本。</p>
<p>现在，使用蹦床函数执行<code>sum</code>，就不会发生调用栈溢出。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>trampoline(sum(<span style="color:#099">1</span>, <span style="color:#099">100000</span>))
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 100001
</span></span></span></code></pre></div><p>蹦床函数并不是真正的尾递归优化，下面的实现才是。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> tco(f) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">var</span> value;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">var</span> active <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">false</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">var</span> accumulated <span style="color:#000;font-weight:bold">=</span> [];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">function</span> accumulator() {
</span></span><span style="display:flex;"><span>    accumulated.push(arguments);
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>active) {
</span></span><span style="display:flex;"><span>      active <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">true</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#000;font-weight:bold">while</span> (accumulated.length) {
</span></span><span style="display:flex;"><span>        value <span style="color:#000;font-weight:bold">=</span> f.apply(<span style="color:#000;font-weight:bold">this</span>, accumulated.shift());
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      active <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">false</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#000;font-weight:bold">return</span> value;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> sum <span style="color:#000;font-weight:bold">=</span> tco(<span style="color:#000;font-weight:bold">function</span>(x, y) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">if</span> (y <span style="color:#000;font-weight:bold">&gt;</span> <span style="color:#099">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> sum(x <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>, y <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> x
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sum(<span style="color:#099">1</span>, <span style="color:#099">100000</span>)
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 100001
</span></span></span></code></pre></div><p>上面代码中，<code>tco</code>函数是尾递归优化的实现，它的奥妙就在于状态变量<code>active</code>。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归<code>sum</code>返回的都是<code>undefined</code>，所以就避免了递归执行；而<code>accumulated</code>数组存放每一轮<code>sum</code>执行的参数，总是有值的，这就保证了<code>accumulator</code>函数内部的<code>while</code>循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。</p>
<h2 id="函数参数的尾逗号">函数参数的尾逗号</h2>
<p>ES2017 <a href="https://github.com/jeffmo/es-trailing-function-commas">允许</a>函数的最后一个参数有尾逗号（trailing comma）。</p>
<p>此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> clownsEverywhere(
</span></span><span style="display:flex;"><span>  param1,
</span></span><span style="display:flex;"><span>  param2
</span></span><span style="display:flex;"><span>) { <span style="color:#998;font-style:italic">/* ... */</span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>clownsEverywhere(
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#39;foo&#39;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#39;bar&#39;</span>
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>上面代码中，如果在<code>param2</code>或<code>bar</code>后面加一个逗号，就会报错。</p>
<p>如果像上面这样，将参数写成多行（即每个参数占据一行），以后修改代码的时候，想为函数<code>clownsEverywhere</code>添加第三个参数，或者调整参数的次序，就势必要在原来最后一个参数后面添加一个逗号。这对于版本管理系统来说，就会显示添加逗号的那一行也发生了变动。这看上去有点冗余，因此新的语法允许定义和调用时，尾部直接有一个逗号。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> clownsEverywhere(
</span></span><span style="display:flex;"><span>  param1,
</span></span><span style="display:flex;"><span>  param2,
</span></span><span style="display:flex;"><span>) { <span style="color:#998;font-style:italic">/* ... */</span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>clownsEverywhere(
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#39;foo&#39;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#39;bar&#39;</span>,
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>这样的规定也使得，函数参数与数组和对象的尾逗号规则，保持一致了。</p>
<h2 id="functionprototypetostring">Function.prototype.toString()</h2>
<p><a href="https://github.com/tc39/Function-prototype-toString-revision">ES2019</a> 对函数实例的<code>toString()</code>方法做出了修改。</p>
<p><code>toString()</code>方法返回函数代码本身，以前会省略注释和空格。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> <span style="color:#998;font-style:italic">/* foo comment */</span> foo () {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>foo.toString()
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// function foo() {}
</span></span></span></code></pre></div><p>上面代码中，函数<code>foo</code>的原始代码包含注释，函数名<code>foo</code>和圆括号之间有空格，但是<code>toString()</code>方法都把它们省略了。</p>
<p>修改后的<code>toString()</code>方法，明确要求返回一模一样的原始代码。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> <span style="color:#998;font-style:italic">/* foo comment */</span> foo () {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>foo.toString()
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// &#34;function /* foo comment */ foo () {}&#34;
</span></span></span></code></pre></div><h2 id="catch-命令的参数省略">catch 命令的参数省略</h2>
<p>JavaScript 语言的<code>try...catch</code>结构，以前明确要求<code>catch</code>命令后面必须跟参数，接受<code>try</code>代码块抛出的错误对象。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>} <span style="color:#000;font-weight:bold">catch</span> (err) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// 处理错误
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>上面代码中，<code>catch</code>命令后面带有参数<code>err</code>。</p>
<p>很多时候，<code>catch</code>代码块可能用不到这个参数。但是，为了保证语法正确，还是必须写。<a href="https://github.com/tc39/proposal-optional-catch-binding">ES2019</a> 做出了改变，允许<code>catch</code>语句省略参数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>} <span style="color:#000;font-weight:bold">catch</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div>
        </div>

        
<div class="post-archive">
    <ul class="post-copyright">
        <li><strong>Author: </strong><a rel="author" href="http://shansec.github.io">未来可期</a></li>
        <li style="word-break:break-all"><strong>Link: </strong><a href="http://shansec.github.io/post/es6/%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/">http://shansec.github.io/post/es6/%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/</a></li>
        <li><strong>License: </strong>This work is under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>. Kindly fulfill the requirements of the aforementioned License when adapting or creating a derivative of this work.</li>
    </ul>
</div>
<br/>



        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/post/es6/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">函数式编程</a></li>
        
        <li><a href="/post/es6/Symbol/">Symbol</a></li>
        
        <li><a href="/post/es6/Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">Set和Map数据结构</a></li>
        
        <li><a href="/post/es6/Reflect/">Reflect</a></li>
        
        <li><a href="/post/es6/Proxy/">Proxy</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='/tags/javaScript' target="_blank">javaScript</a></li>
                
                <li><a href='/tags/es6' target="_blank">es6</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "your github repo"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
    
    

</div>

                    <footer id="footer">
    <div>
        &copy; 2024 <a href="http://shansec.github.io">未来可期的博客 By 未来可期</a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>
<style type="text/css">
div.highlight {
    position: relative;
    margin: 1em 0px;
}

.copy-code {
    display: none;
    position: absolute;
    top: 4px;
    right: 4px;
    color: rgba(255, 255, 255, 0.8);
    background: rgba(78, 78, 78, 0.8);
    border-radius: var(--radius);
    padding: 0 5px;
    font: inherit;
    user-select: none;
    cursor: pointer;
    border: 0;
    --radius: 8px;
}

div.highlight:hover .copy-code,pre:hover .copy-code {
    display: block;
}

</style>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>


    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




    <script src='/js/douban.js'></script>

                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='http://shansec.github.io/search' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="http://shansec.github.io">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>

    <section class="widget">
        <h3 class="widget-title">Latest articles</h3>
<ul class="widget-list">
    
    <li>
        <a href="http://shansec.github.io/post/ts/typescript-%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B/" title="Typescript 数组类型" target="_blank">Typescript 数组类型</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/typescript-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/" title="Typescript 类型系统" target="_blank">Typescript 类型系统</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/typescript-any%E7%B1%BB%E5%9E%8B%E5%92%8Cunknown%E7%B1%BB%E5%9E%8B%E5%92%8Cnever%E7%B1%BB%E5%9E%8B/" title="Typescript Any类型和unknown类型和never类型" target="_blank">Typescript Any类型和unknown类型和never类型</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/typescript-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/" title="Typescript 基本用法" target="_blank">Typescript 基本用法</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/es6/%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E6%89%A9%E5%B1%95/" title="运算符的扩展" target="_blank">运算符的扩展</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/es6/%E8%A3%85%E9%A5%B0%E5%99%A8/" title="装饰器" target="_blank">装饰器</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/es6/%E6%AD%A3%E5%88%99%E7%9A%84%E6%89%A9%E5%B1%95/" title="正则的扩展" target="_blank">正则的扩展</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/es6/%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95/" title="数组的扩展" target="_blank">数组的扩展</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/es6/%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95/" title="数值的扩展" target="_blank">数值的扩展</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/es6/%E5%BC%82%E6%AD%A5%E9%81%8D%E5%8E%86%E5%99%A8/" title="异步遍历器" target="_blank">异步遍历器</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href='/categories/'>Categories</a></h3>
<ul class="widget-list">
    
    <li><a href="http://shansec.github.io/categories/go/">go (43)</a></li>
    
    <li><a href="http://shansec.github.io/categories/%E5%89%8D%E7%AB%AF/">前端 (56)</a></li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href='/tags/'>Tags</a></h3>
<div class="tagcloud">
    
    <a href="http://shansec.github.io/tags/CSS/">CSS</a>
    
    <a href="http://shansec.github.io/tags/HTTP/">HTTP</a>
    
    <a href="http://shansec.github.io/tags/javaScript/">javaScript</a>
    
    <a href="http://shansec.github.io/tags/CSS/">CSS</a>
    
    <a href="http://shansec.github.io/tags/docker/">docker</a>
    
    <a href="http://shansec.github.io/tags/es6/">es6</a>
    
    <a href="http://shansec.github.io/tags/go/">go</a>
    
    <a href="http://shansec.github.io/tags/go-%E5%9F%BA%E7%A1%80/">go 基础</a>
    
    <a href="http://shansec.github.io/tags/go-%E6%A0%87%E5%87%86%E5%BA%93/">go 标准库</a>
    
    <a href="http://shansec.github.io/tags/javaScript/">javaScript</a>
    
    <a href="http://shansec.github.io/tags/jwt/">jwt</a>
    
    <a href="http://shansec.github.io/tags/package/">package</a>
    
    <a href="http://shansec.github.io/tags/pinia/">pinia</a>
    
    <a href="http://shansec.github.io/tags/redis/">redis</a>
    
    <a href="http://shansec.github.io/tags/sql/">sql</a>
    
    <a href="http://shansec.github.io/tags/sqlx/">sqlx</a>
    
    <a href="http://shansec.github.io/tags/typescript/">typescript</a>
    
    <a href="http://shansec.github.io/tags/vue/">vue</a>
    
    <a href="http://shansec.github.io/tags/%E5%AD%98%E5%82%A8/">存储</a>
    
    <a href="http://shansec.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">微信小程序</a>
    
    <a href="http://shansec.github.io/tags/%E6%A0%87%E5%87%86%E5%BA%93/">标准库</a>
    
    <a href="http://shansec.github.io/tags/%E6%A1%86%E6%9E%B6/">框架</a>
    
    <a href="http://shansec.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/">计算机原理</a>
    
</div>
    </section>

    
<section class="widget">
    <h3 class="widget-title">Links</h3>
    <ul class="widget-list">
        
        <li>
            <a target="_blank" href="https://www.liwenzhou.com/" title="李文周的博客">李文周的博客</a>
        </li>
        
    </ul>
</section>


    <section class="widget">
        <h3 class="widget-title">Meta</h3>
        <ul class="widget-list">
            <li><a href="http://shansec.github.io/index.xml">RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>