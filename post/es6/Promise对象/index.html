<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <meta name="referrer" content="no-referrer-when-downgrade">
    

    <title>Promise对象 | 未来可期的博客</title>
    <meta property="og:title" content="Promise对象 - 未来可期的博客">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2024-04-23T10:25:57&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2024-04-23T10:25:57&#43;08:00'>
        
    <meta name="Keywords" content="golang,go语言,go语言笔记,未来可期,博客,公众号,小程序">
    <meta name="description" content="Promise对象">
        
    <meta name="author" content="未来可期">
    <meta property="og:url" content="http://shansec.github.io/post/es6/Promise%E5%AF%B9%E8%B1%A1/">
    <link rel="shortcut icon" href='/favicon.ico'  type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
        <link rel="stylesheet" href='/css/douban.css'>
    
        <link rel="stylesheet" href='/css/other.css'>
    
</head>

<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="http://shansec.github.io">
                        未来可期的博客
                    </a>
                
                <p class="description">专注于Go语言(golang)、前端技术</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="http://shansec.github.io">Home</a>
                    
                    <a  href="http://shansec.github.io/archives/" title="归档">归档</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    <style type="text/css">
    .post-toc {
        position: fixed;
        width: 200px;
        margin-left: -210px;
        padding: 5px 10px;
        font-family: Athelas, STHeiti, Microsoft Yahei, serif;
        font-size: 12px;
        border: 1px solid rgba(0, 0, 0, .07);
        border-radius: 5px;
        background-color: rgba(255, 255, 255, 0.98);
        background-clip: padding-box;
        -webkit-box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        word-wrap: break-word;
        white-space: nowrap;
        -webkit-box-sizing: border-box;
        box-sizing: border-box;
        z-index: 999;
        cursor: pointer;
        max-height: 70%;
        overflow-y: auto;
        overflow-x: hidden;
    }

    .post-toc .post-toc-title {
        width: 100%;
        margin: 0 auto;
        font-size: 20px;
        font-weight: 400;
        text-transform: uppercase;
        text-align: center;
    }

    .post-toc .post-toc-content {
        font-size: 15px;
    }

    .post-toc .post-toc-content>nav>ul {
        margin: 10px 0;
    }

    .post-toc .post-toc-content ul {
        padding-left: 20px;
        list-style: square;
        margin: 0.5em;
        line-height: 1.8em;
    }

    .post-toc .post-toc-content ul ul {
        padding-left: 15px;
        display: none;
    }

    @media print,
    screen and (max-width:1057px) {
        .post-toc {
            display: none;
        }
    }
</style>
<div class="post-toc" style="position: absolute; top: 188px;">
    <h2 class="post-toc-title">Table of Contents</h2>
    <div class="post-toc-content">
        <nav id="TableOfContents">
  <ul>
    <li><a href="#promise-的含义">Promise 的含义</a></li>
    <li><a href="#基本用法">基本用法</a></li>
    <li><a href="#promiseprototypethen">Promise.prototype.then()</a></li>
    <li><a href="#promiseprototypecatch">Promise.prototype.catch()</a></li>
    <li><a href="#promiseprototypefinally">Promise.prototype.finally()</a></li>
    <li><a href="#promiseall">Promise.all()</a></li>
    <li><a href="#promiserace">Promise.race()</a></li>
    <li><a href="#promiseallsettled">Promise.allSettled()</a></li>
    <li><a href="#promiseany">Promise.any()</a></li>
    <li><a href="#promiseresolve">Promise.resolve()</a></li>
    <li><a href="#promisereject">Promise.reject()</a></li>
    <li><a href="#应用">应用</a>
      <ul>
        <li><a href="#加载图片">加载图片</a></li>
        <li><a href="#generator-函数与-promise-的结合">Generator 函数与 Promise 的结合</a></li>
      </ul>
    </li>
    <li><a href="#promisetry">Promise.try()</a></li>
  </ul>
</nav>
    </div>
</div>
<script type="text/javascript">
    $(document).ready(function () {
        var postToc = $(".post-toc");
        if (postToc.length) {
            var leftPos = $("#main").offset().left;
            if (leftPos < 220) {
                postToc.css({ "width": leftPos - 10, "margin-left": (0 - leftPos) })
            }

            var t = postToc.offset().top - 20,
                a = {
                    start: {
                        position: "absolute",
                        top: t
                    },
                    process: {
                        position: "fixed",
                        top: 20
                    },
                };
            $(window).scroll(function () {
                var e = $(window).scrollTop();
                e < t ? postToc.css(a.start) : postToc.css(a.process)
            })
        }

        if ($("#TableOfContents").children().length < 1) {
            $(".post-toc").remove();
        }
    })
</script>
    <article class="post">
        <header>
            <h1 class="post-title">Promise对象</h1>
        </header>
        
  <time datetime="2024-04-23T02:25:57Z" class="post-meta meta-date dt-published">
    2024-04-23
  </time>


<div class="post-meta meta-category">
  <span>&nbsp;|</span>
  
    <a href='/categories/%E5%89%8D%E7%AB%AF' target="_blank">前端</a>
  
</div>


        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">&nbsp;|
                <span id="busuanzi_value_page_pv"></span> <span>reads</span>
            </span>
        </div>
        
        
        <div class="post-content">
            <h2 id="promise-的含义">Promise 的含义</h2>
<p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p>
<p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<p><code>Promise</code>对象有以下两个特点。</p>
<p>（1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>
<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
<p>注意，为了行文方便，本章后面的<code>resolved</code>统一只指<code>fulfilled</code>状态，不包含<code>rejected</code>状态。</p>
<p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p>
<p><code>Promise</code>也有一些缺点。首先，无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。第三，当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
<p>如果某些事件不断地反复发生，一般来说，使用 <a href="https://nodejs.org/api/stream.html">Stream</a> 模式是比部署<code>Promise</code>更好的选择。</p>
<h2 id="基本用法">基本用法</h2>
<p>ES6 规定，<code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。</p>
<p>下面代码创造了一个<code>Promise</code>实例。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> promise <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Promise</span>(<span style="color:#000;font-weight:bold">function</span>(resolve, reject) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ... some code
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">if</span> (<span style="color:#998;font-style:italic">/* 异步操作成功 */</span>){
</span></span><span style="display:flex;"><span>    resolve(value);
</span></span><span style="display:flex;"><span>  } <span style="color:#000;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>    reject(error);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>
<p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>promise.then(<span style="color:#000;font-weight:bold">function</span>(value) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// success
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}, <span style="color:#000;font-weight:bold">function</span>(error) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// failure
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>});
</span></span></code></pre></div><p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。这两个函数都是可选的，不一定要提供。它们都接受<code>Promise</code>对象传出的值作为参数。</p>
<p>下面是一个<code>Promise</code>对象的简单例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> timeout(ms) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Promise</span>((resolve, reject) =&gt; {
</span></span><span style="display:flex;"><span>    setTimeout(resolve, ms, <span style="color:#d14">&#39;done&#39;</span>);
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>timeout(<span style="color:#099">100</span>).then((value) =&gt; {
</span></span><span style="display:flex;"><span>  console.log(value);
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><p>上面代码中，<code>timeout</code>方法返回一个<code>Promise</code>实例，表示一段时间以后才会发生的结果。过了指定的时间（<code>ms</code>参数）以后，<code>Promise</code>实例的状态变为<code>resolved</code>，就会触发<code>then</code>方法绑定的回调函数。</p>
<p>Promise 新建后就会立即执行。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> promise <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Promise</span>(<span style="color:#000;font-weight:bold">function</span>(resolve, reject) {
</span></span><span style="display:flex;"><span>  console.log(<span style="color:#d14">&#39;Promise&#39;</span>);
</span></span><span style="display:flex;"><span>  resolve();
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>promise.then(<span style="color:#000;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>  console.log(<span style="color:#d14">&#39;resolved.&#39;</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>console.log(<span style="color:#d14">&#39;Hi!&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Promise
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Hi!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// resolved
</span></span></span></code></pre></div><p>上面代码中，Promise 新建后立即执行，所以首先输出的是<code>Promise</code>。然后，<code>then</code>方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以<code>resolved</code>最后输出。</p>
<p>下面是异步加载图片的例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> loadImageAsync(url) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Promise</span>(<span style="color:#000;font-weight:bold">function</span>(resolve, reject) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">const</span> image <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> Image();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    image.onload <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>      resolve(image);
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    image.onerror <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>      reject(<span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Error</span>(<span style="color:#d14">&#39;Could not load image at &#39;</span> <span style="color:#000;font-weight:bold">+</span> url));
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    image.src <span style="color:#000;font-weight:bold">=</span> url;
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码中，使用<code>Promise</code>包装了一个图片加载的异步操作。如果加载成功，就调用<code>resolve</code>方法，否则就调用<code>reject</code>方法。</p>
<p>下面是一个用<code>Promise</code>对象实现的 Ajax 操作的例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> getJSON <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">function</span>(url) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">const</span> promise <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Promise</span>(<span style="color:#000;font-weight:bold">function</span>(resolve, reject){
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">const</span> handler <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>      <span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">this</span>.readyState <span style="color:#000;font-weight:bold">!==</span> <span style="color:#099">4</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">this</span>.status <span style="color:#000;font-weight:bold">===</span> <span style="color:#099">200</span>) {
</span></span><span style="display:flex;"><span>        resolve(<span style="color:#000;font-weight:bold">this</span>.response);
</span></span><span style="display:flex;"><span>      } <span style="color:#000;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>        reject(<span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Error</span>(<span style="color:#000;font-weight:bold">this</span>.statusText));
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">const</span> client <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> XMLHttpRequest();
</span></span><span style="display:flex;"><span>    client.open(<span style="color:#d14">&#34;GET&#34;</span>, url);
</span></span><span style="display:flex;"><span>    client.onreadystatechange <span style="color:#000;font-weight:bold">=</span> handler;
</span></span><span style="display:flex;"><span>    client.responseType <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;json&#34;</span>;
</span></span><span style="display:flex;"><span>    client.setRequestHeader(<span style="color:#d14">&#34;Accept&#34;</span>, <span style="color:#d14">&#34;application/json&#34;</span>);
</span></span><span style="display:flex;"><span>    client.send();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> promise;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>getJSON(<span style="color:#d14">&#34;/posts.json&#34;</span>).then(<span style="color:#000;font-weight:bold">function</span>(json) {
</span></span><span style="display:flex;"><span>  console.log(<span style="color:#d14">&#39;Contents: &#39;</span> <span style="color:#000;font-weight:bold">+</span> json);
</span></span><span style="display:flex;"><span>}, <span style="color:#000;font-weight:bold">function</span>(error) {
</span></span><span style="display:flex;"><span>  console.error(<span style="color:#d14">&#39;出错了&#39;</span>, error);
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><p>上面代码中，<code>getJSON</code>是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个<code>Promise</code>对象。需要注意的是，在<code>getJSON</code>内部，<code>resolve</code>函数和<code>reject</code>函数调用时，都带有参数。</p>
<p>如果调用<code>resolve</code>函数和<code>reject</code>函数时带有参数，那么它们的参数会被传递给回调函数。<code>reject</code>函数的参数通常是<code>Error</code>对象的实例，表示抛出的错误；<code>resolve</code>函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> p1 <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Promise</span>(<span style="color:#000;font-weight:bold">function</span> (resolve, reject) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> p2 <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Promise</span>(<span style="color:#000;font-weight:bold">function</span> (resolve, reject) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  resolve(p1);
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><p>上面代码中，<code>p1</code>和<code>p2</code>都是 Promise 的实例，但是<code>p2</code>的<code>resolve</code>方法将<code>p1</code>作为参数，即一个异步操作的结果是返回另一个异步操作。</p>
<p>注意，这时<code>p1</code>的状态就会传递给<code>p2</code>，也就是说，<code>p1</code>的状态决定了<code>p2</code>的状态。如果<code>p1</code>的状态是<code>pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变；如果<code>p1</code>的状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> p1 <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Promise</span>(<span style="color:#000;font-weight:bold">function</span> (resolve, reject) {
</span></span><span style="display:flex;"><span>  setTimeout(() =&gt; reject(<span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Error</span>(<span style="color:#d14">&#39;fail&#39;</span>)), <span style="color:#099">3000</span>)
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> p2 <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Promise</span>(<span style="color:#000;font-weight:bold">function</span> (resolve, reject) {
</span></span><span style="display:flex;"><span>  setTimeout(() =&gt; resolve(p1), <span style="color:#099">1000</span>)
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p2
</span></span><span style="display:flex;"><span>  .then(result =&gt; console.log(result))
</span></span><span style="display:flex;"><span>  .<span style="color:#000;font-weight:bold">catch</span>(error =&gt; console.log(error))
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Error: fail
</span></span></span></code></pre></div><p>上面代码中，<code>p1</code>是一个 Promise，3 秒之后变为<code>rejected</code>。<code>p2</code>的状态在 1 秒之后改变，<code>resolve</code>方法返回的是<code>p1</code>。由于<code>p2</code>返回的是另一个 Promise，导致<code>p2</code>自己的状态无效了，由<code>p1</code>的状态决定<code>p2</code>的状态。所以，后面的<code>then</code>语句都变成针对后者（<code>p1</code>）。又过了 2 秒，<code>p1</code>变为<code>rejected</code>，导致触发<code>catch</code>方法指定的回调函数。</p>
<p>注意，调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Promise</span>((resolve, reject) =&gt; {
</span></span><span style="display:flex;"><span>  resolve(<span style="color:#099">1</span>);
</span></span><span style="display:flex;"><span>  console.log(<span style="color:#099">2</span>);
</span></span><span style="display:flex;"><span>}).then(r =&gt; {
</span></span><span style="display:flex;"><span>  console.log(r);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 2
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 1
</span></span></span></code></pre></div><p>上面代码中，调用<code>resolve(1)</code>以后，后面的<code>console.log(2)</code>还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p>
<p>一般来说，调用<code>resolve</code>或<code>reject</code>以后，Promise 的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，最好在它们前面加上<code>return</code>语句，这样就不会有意外。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Promise</span>((resolve, reject) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> resolve(<span style="color:#099">1</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// 后面的语句不会执行
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  console.log(<span style="color:#099">2</span>);
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><h2 id="promiseprototypethen">Promise.prototype.then()</h2>
<p>Promise 实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，<code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数是<code>rejected</code>状态的回调函数，它们都是可选的。</p>
<p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>getJSON(<span style="color:#d14">&#34;/posts.json&#34;</span>).then(<span style="color:#000;font-weight:bold">function</span>(json) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> json.post;
</span></span><span style="display:flex;"><span>}).then(<span style="color:#000;font-weight:bold">function</span>(post) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>});
</span></span></code></pre></div><p>上面的代码使用<code>then</code>方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>
<p>采用链式的<code>then</code>，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个<code>Promise</code>对象（即有异步操作），这时后一个回调函数，就会等待该<code>Promise</code>对象的状态发生变化，才会被调用。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>getJSON(<span style="color:#d14">&#34;/post/1.json&#34;</span>).then(<span style="color:#000;font-weight:bold">function</span>(post) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> getJSON(post.commentURL);
</span></span><span style="display:flex;"><span>}).then(<span style="color:#000;font-weight:bold">function</span> (comments) {
</span></span><span style="display:flex;"><span>  console.log(<span style="color:#d14">&#34;resolved: &#34;</span>, comments);
</span></span><span style="display:flex;"><span>}, <span style="color:#000;font-weight:bold">function</span> (err){
</span></span><span style="display:flex;"><span>  console.log(<span style="color:#d14">&#34;rejected: &#34;</span>, err);
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><p>上面代码中，第一个<code>then</code>方法指定的回调函数，返回的是另一个<code>Promise</code>对象。这时，第二个<code>then</code>方法指定的回调函数，就会等待这个新的<code>Promise</code>对象状态发生变化。如果变为<code>resolved</code>，就调用第一个回调函数，如果状态变为<code>rejected</code>，就调用第二个回调函数。</p>
<p>如果采用箭头函数，上面的代码可以写得更简洁。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>getJSON(<span style="color:#d14">&#34;/post/1.json&#34;</span>).then(
</span></span><span style="display:flex;"><span>  post =&gt; getJSON(post.commentURL)
</span></span><span style="display:flex;"><span>).then(
</span></span><span style="display:flex;"><span>  comments =&gt; console.log(<span style="color:#d14">&#34;resolved: &#34;</span>, comments),
</span></span><span style="display:flex;"><span>  err =&gt; console.log(<span style="color:#d14">&#34;rejected: &#34;</span>, err)
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><h2 id="promiseprototypecatch">Promise.prototype.catch()</h2>
<p><code>Promise.prototype.catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>getJSON(<span style="color:#d14">&#39;/posts.json&#39;</span>).then(<span style="color:#000;font-weight:bold">function</span>(posts) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}).<span style="color:#000;font-weight:bold">catch</span>(<span style="color:#000;font-weight:bold">function</span>(error) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// 处理 getJSON 和 前一个回调函数运行时发生的错误
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  console.log(<span style="color:#d14">&#39;发生错误！&#39;</span>, error);
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><p>上面代码中，<code>getJSON()</code>方法返回一个 Promise 对象，如果该对象状态变为<code>resolved</code>，则会调用<code>then()</code>方法指定的回调函数；如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch()</code>方法指定的回调函数，处理这个错误。另外，<code>then()</code>方法指定的回调函数，如果运行中抛出错误，也会被<code>catch()</code>方法捕获。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>p.then((val) =&gt; console.log(<span style="color:#d14">&#39;fulfilled:&#39;</span>, val))
</span></span><span style="display:flex;"><span>  .<span style="color:#000;font-weight:bold">catch</span>((err) =&gt; console.log(<span style="color:#d14">&#39;rejected&#39;</span>, err));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 等同于
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>p.then((val) =&gt; console.log(<span style="color:#d14">&#39;fulfilled:&#39;</span>, val))
</span></span><span style="display:flex;"><span>  .then(<span style="color:#000;font-weight:bold">null</span>, (err) =&gt; console.log(<span style="color:#d14">&#34;rejected:&#34;</span>, err));
</span></span></code></pre></div><p>下面是一个例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> promise <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Promise</span>(<span style="color:#000;font-weight:bold">function</span>(resolve, reject) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">throw</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Error</span>(<span style="color:#d14">&#39;test&#39;</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>promise.<span style="color:#000;font-weight:bold">catch</span>(<span style="color:#000;font-weight:bold">function</span>(error) {
</span></span><span style="display:flex;"><span>  console.log(error);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Error: test
</span></span></span></code></pre></div><p>上面代码中，<code>promise</code>抛出一个错误，就被<code>catch()</code>方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 写法一
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> promise <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Promise</span>(<span style="color:#000;font-weight:bold">function</span>(resolve, reject) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">throw</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Error</span>(<span style="color:#d14">&#39;test&#39;</span>);
</span></span><span style="display:flex;"><span>  } <span style="color:#000;font-weight:bold">catch</span>(e) {
</span></span><span style="display:flex;"><span>    reject(e);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>promise.<span style="color:#000;font-weight:bold">catch</span>(<span style="color:#000;font-weight:bold">function</span>(error) {
</span></span><span style="display:flex;"><span>  console.log(error);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 写法二
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> promise <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Promise</span>(<span style="color:#000;font-weight:bold">function</span>(resolve, reject) {
</span></span><span style="display:flex;"><span>  reject(<span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Error</span>(<span style="color:#d14">&#39;test&#39;</span>));
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>promise.<span style="color:#000;font-weight:bold">catch</span>(<span style="color:#000;font-weight:bold">function</span>(error) {
</span></span><span style="display:flex;"><span>  console.log(error);
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><p>比较上面两种写法，可以发现<code>reject()</code>方法的作用，等同于抛出错误。</p>
<p>如果 Promise 状态已经变成<code>resolved</code>，再抛出错误是无效的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> promise <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Promise</span>(<span style="color:#000;font-weight:bold">function</span>(resolve, reject) {
</span></span><span style="display:flex;"><span>  resolve(<span style="color:#d14">&#39;ok&#39;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">throw</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Error</span>(<span style="color:#d14">&#39;test&#39;</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>promise
</span></span><span style="display:flex;"><span>  .then(<span style="color:#000;font-weight:bold">function</span>(value) { console.log(value) })
</span></span><span style="display:flex;"><span>  .<span style="color:#000;font-weight:bold">catch</span>(<span style="color:#000;font-weight:bold">function</span>(error) { console.log(error) });
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// ok
</span></span></span></code></pre></div><p>上面代码中，Promise 在<code>resolve</code>语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。</p>
<p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>getJSON(<span style="color:#d14">&#39;/post/1.json&#39;</span>).then(<span style="color:#000;font-weight:bold">function</span>(post) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> getJSON(post.commentURL);
</span></span><span style="display:flex;"><span>}).then(<span style="color:#000;font-weight:bold">function</span>(comments) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// some code
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}).<span style="color:#000;font-weight:bold">catch</span>(<span style="color:#000;font-weight:bold">function</span>(error) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// 处理前面三个Promise产生的错误
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>});
</span></span></code></pre></div><p>上面代码中，一共有三个 Promise 对象：一个由<code>getJSON()</code>产生，两个由<code>then()</code>产生。它们之中任何一个抛出的错误，都会被最后一个<code>catch()</code>捕获。</p>
<p>一般来说，不要在<code>then()</code>方法里面定义 Reject 状态的回调函数（即<code>then</code>的第二个参数），总是使用<code>catch</code>方法。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// bad
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>promise
</span></span><span style="display:flex;"><span>  .then(<span style="color:#000;font-weight:bold">function</span>(data) {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// success
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  }, <span style="color:#000;font-weight:bold">function</span>(err) {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// error
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// good
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>promise
</span></span><span style="display:flex;"><span>  .then(<span style="color:#000;font-weight:bold">function</span>(data) { <span style="color:#998;font-style:italic">//cb
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// success
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  })
</span></span><span style="display:flex;"><span>  .<span style="color:#000;font-weight:bold">catch</span>(<span style="color:#000;font-weight:bold">function</span>(err) {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// error
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  });
</span></span></code></pre></div><p>上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面<code>then</code>方法执行中的错误，也更接近同步的写法（<code>try/catch</code>）。因此，建议总是使用<code>catch()</code>方法，而不使用<code>then()</code>方法的第二个参数。</p>
<p>跟传统的<code>try/catch</code>代码块不同的是，如果没有使用<code>catch()</code>方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> someAsyncThing <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Promise</span>(<span style="color:#000;font-weight:bold">function</span>(resolve, reject) {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 下面一行会报错，因为x没有声明
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    resolve(x <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">2</span>);
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>someAsyncThing().then(<span style="color:#000;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>  console.log(<span style="color:#d14">&#39;everything is great&#39;</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>setTimeout(() =&gt; { console.log(<span style="color:#099">123</span>) }, <span style="color:#099">2000</span>);
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Uncaught (in promise) ReferenceError: x is not defined
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 123
</span></span></span></code></pre></div><p>上面代码中，<code>someAsyncThing()</code>函数产生的 Promise 对象，内部有语法错误。浏览器运行到这一行，会打印出错误提示<code>ReferenceError: x is not defined</code>，但是不会退出进程、终止脚本执行，2 秒之后还是会输出<code>123</code>。这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</p>
<p>这个脚本放在服务器执行，退出码就是<code>0</code>（即表示执行成功）。不过，Node.js 有一个<code>unhandledRejection</code>事件，专门监听未捕获的<code>reject</code>错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>process.on(<span style="color:#d14">&#39;unhandledRejection&#39;</span>, <span style="color:#000;font-weight:bold">function</span> (err, p) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">throw</span> err;
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><p>上面代码中，<code>unhandledRejection</code>事件的监听函数有两个参数，第一个是错误对象，第二个是报错的 Promise 实例，它可以用来了解发生错误的环境信息。</p>
<p>注意，Node 有计划在未来废除<code>unhandledRejection</code>事件。如果 Promise 内部有未捕获的错误，会直接终止进程，并且进程的退出码不为 0。</p>
<p>再看下面的例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> promise <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Promise</span>(<span style="color:#000;font-weight:bold">function</span> (resolve, reject) {
</span></span><span style="display:flex;"><span>  resolve(<span style="color:#d14">&#39;ok&#39;</span>);
</span></span><span style="display:flex;"><span>  setTimeout(<span style="color:#000;font-weight:bold">function</span> () { <span style="color:#000;font-weight:bold">throw</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Error</span>(<span style="color:#d14">&#39;test&#39;</span>) }, <span style="color:#099">0</span>)
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>promise.then(<span style="color:#000;font-weight:bold">function</span> (value) { console.log(value) });
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// ok
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Uncaught Error: test
</span></span></span></code></pre></div><p>上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。</p>
<p>一般总是建议，Promise 对象后面要跟<code>catch()</code>方法，这样可以处理 Promise 内部发生的错误。<code>catch()</code>方法返回的还是一个 Promise 对象，因此后面还可以接着调用<code>then()</code>方法。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> someAsyncThing <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Promise</span>(<span style="color:#000;font-weight:bold">function</span>(resolve, reject) {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 下面一行会报错，因为x没有声明
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    resolve(x <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">2</span>);
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>someAsyncThing()
</span></span><span style="display:flex;"><span>.<span style="color:#000;font-weight:bold">catch</span>(<span style="color:#000;font-weight:bold">function</span>(error) {
</span></span><span style="display:flex;"><span>  console.log(<span style="color:#d14">&#39;oh no&#39;</span>, error);
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>.then(<span style="color:#000;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>  console.log(<span style="color:#d14">&#39;carry on&#39;</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// oh no [ReferenceError: x is not defined]
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// carry on
</span></span></span></code></pre></div><p>上面代码运行完<code>catch()</code>方法指定的回调函数，会接着运行后面那个<code>then()</code>方法指定的回调函数。如果没有报错，则会跳过<code>catch()</code>方法。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#0086b3">Promise</span>.resolve()
</span></span><span style="display:flex;"><span>.<span style="color:#000;font-weight:bold">catch</span>(<span style="color:#000;font-weight:bold">function</span>(error) {
</span></span><span style="display:flex;"><span>  console.log(<span style="color:#d14">&#39;oh no&#39;</span>, error);
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>.then(<span style="color:#000;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>  console.log(<span style="color:#d14">&#39;carry on&#39;</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// carry on
</span></span></span></code></pre></div><p>上面的代码因为没有报错，跳过了<code>catch()</code>方法，直接执行后面的<code>then()</code>方法。此时，要是<code>then()</code>方法里面报错，就与前面的<code>catch()</code>无关了。</p>
<p><code>catch()</code>方法之中，还能再抛出错误。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> someAsyncThing <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Promise</span>(<span style="color:#000;font-weight:bold">function</span>(resolve, reject) {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 下面一行会报错，因为x没有声明
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    resolve(x <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">2</span>);
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>someAsyncThing().then(<span style="color:#000;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> someOtherAsyncThing();
</span></span><span style="display:flex;"><span>}).<span style="color:#000;font-weight:bold">catch</span>(<span style="color:#000;font-weight:bold">function</span>(error) {
</span></span><span style="display:flex;"><span>  console.log(<span style="color:#d14">&#39;oh no&#39;</span>, error);
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// 下面一行会报错，因为 y 没有声明
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  y <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">2</span>;
</span></span><span style="display:flex;"><span>}).then(<span style="color:#000;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>  console.log(<span style="color:#d14">&#39;carry on&#39;</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// oh no [ReferenceError: x is not defined]
</span></span></span></code></pre></div><p>上面代码中，<code>catch()</code>方法抛出一个错误，因为后面没有别的<code>catch()</code>方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>someAsyncThing().then(<span style="color:#000;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> someOtherAsyncThing();
</span></span><span style="display:flex;"><span>}).<span style="color:#000;font-weight:bold">catch</span>(<span style="color:#000;font-weight:bold">function</span>(error) {
</span></span><span style="display:flex;"><span>  console.log(<span style="color:#d14">&#39;oh no&#39;</span>, error);
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// 下面一行会报错，因为y没有声明
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  y <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">2</span>;
</span></span><span style="display:flex;"><span>}).<span style="color:#000;font-weight:bold">catch</span>(<span style="color:#000;font-weight:bold">function</span>(error) {
</span></span><span style="display:flex;"><span>  console.log(<span style="color:#d14">&#39;carry on&#39;</span>, error);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// oh no [ReferenceError: x is not defined]
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// carry on [ReferenceError: y is not defined]
</span></span></span></code></pre></div><p>上面代码中，第二个<code>catch()</code>方法用来捕获前一个<code>catch()</code>方法抛出的错误。</p>
<h2 id="promiseprototypefinally">Promise.prototype.finally()</h2>
<p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>promise
</span></span><span style="display:flex;"><span>.then(result =&gt; {<span style="color:#a61717;background-color:#e3d2d2">···</span>})
</span></span><span style="display:flex;"><span>.<span style="color:#000;font-weight:bold">catch</span>(error =&gt; {<span style="color:#a61717;background-color:#e3d2d2">···</span>})
</span></span><span style="display:flex;"><span>.<span style="color:#000;font-weight:bold">finally</span>(() =&gt; {<span style="color:#a61717;background-color:#e3d2d2">···</span>});
</span></span></code></pre></div><p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p>
<p>下面是一个例子，服务器使用 Promise 处理请求，然后使用<code>finally</code>方法关掉服务器。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>server.listen(port)
</span></span><span style="display:flex;"><span>  .then(<span style="color:#000;font-weight:bold">function</span> () {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  })
</span></span><span style="display:flex;"><span>  .<span style="color:#000;font-weight:bold">finally</span>(server.stop);
</span></span></code></pre></div><p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p>
<p><code>finally</code>本质上是<code>then</code>方法的特例。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>promise
</span></span><span style="display:flex;"><span>.<span style="color:#000;font-weight:bold">finally</span>(() =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// 语句
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 等同于
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>promise
</span></span><span style="display:flex;"><span>.then(
</span></span><span style="display:flex;"><span>  result =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 语句
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">return</span> result;
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>  error =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 语句
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">throw</span> error;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。</p>
<p>它的实现也很简单。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#0086b3">Promise</span>.prototype.<span style="color:#000;font-weight:bold">finally</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">function</span> (callback) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">let</span> P <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">this</span>.constructor;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">this</span>.then(
</span></span><span style="display:flex;"><span>    value  =&gt; P.resolve(callback()).then(() =&gt; value),
</span></span><span style="display:flex;"><span>    reason =&gt; P.resolve(callback()).then(() =&gt; { <span style="color:#000;font-weight:bold">throw</span> reason })
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>上面代码中，不管前面的 Promise 是<code>fulfilled</code>还是<code>rejected</code>，都会执行回调函数<code>callback</code>。</p>
<p>从上面的实现还可以看到，<code>finally</code>方法总是会返回原来的值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// resolve 的值是 undefined
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#0086b3">Promise</span>.resolve(<span style="color:#099">2</span>).then(() =&gt; {}, () =&gt; {})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// resolve 的值是 2
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#0086b3">Promise</span>.resolve(<span style="color:#099">2</span>).<span style="color:#000;font-weight:bold">finally</span>(() =&gt; {})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// reject 的值是 undefined
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#0086b3">Promise</span>.reject(<span style="color:#099">3</span>).then(() =&gt; {}, () =&gt; {})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// reject 的值是 3
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#0086b3">Promise</span>.reject(<span style="color:#099">3</span>).<span style="color:#000;font-weight:bold">finally</span>(() =&gt; {})
</span></span></code></pre></div><h2 id="promiseall">Promise.all()</h2>
<p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> p <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">Promise</span>.all([p1, p2, p3]);
</span></span></code></pre></div><p>上面代码中，<code>Promise.all()</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，如果不是，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 Promise 实例，再进一步处理。另外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</p>
<p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p>
<p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p>
<p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p>
<p>下面是一个具体的例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 生成一个Promise对象的数组
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> promises <span style="color:#000;font-weight:bold">=</span> [<span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">5</span>, <span style="color:#099">7</span>, <span style="color:#099">11</span>, <span style="color:#099">13</span>].map(<span style="color:#000;font-weight:bold">function</span> (id) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> getJSON(<span style="color:#d14">&#39;/post/&#39;</span> <span style="color:#000;font-weight:bold">+</span> id <span style="color:#000;font-weight:bold">+</span> <span style="color:#d14">&#34;.json&#34;</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0086b3">Promise</span>.all(promises).then(<span style="color:#000;font-weight:bold">function</span> (posts) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}).<span style="color:#000;font-weight:bold">catch</span>(<span style="color:#000;font-weight:bold">function</span>(reason){
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>});
</span></span></code></pre></div><p>上面代码中，<code>promises</code>是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成<code>fulfilled</code>，或者其中有一个变为<code>rejected</code>，才会调用<code>Promise.all</code>方法后面的回调函数。</p>
<p>下面是另一个例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> databasePromise <span style="color:#000;font-weight:bold">=</span> connectDatabase();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> booksPromise <span style="color:#000;font-weight:bold">=</span> databasePromise
</span></span><span style="display:flex;"><span>  .then(findAllBooks);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> userPromise <span style="color:#000;font-weight:bold">=</span> databasePromise
</span></span><span style="display:flex;"><span>  .then(getCurrentUser);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0086b3">Promise</span>.all([
</span></span><span style="display:flex;"><span>  booksPromise,
</span></span><span style="display:flex;"><span>  userPromise
</span></span><span style="display:flex;"><span>])
</span></span><span style="display:flex;"><span>.then(([books, user]) =&gt; pickTopRecommendations(books, user));
</span></span></code></pre></div><p>上面代码中，<code>booksPromise</code>和<code>userPromise</code>是两个异步操作，只有等到它们的结果都返回了，才会触发<code>pickTopRecommendations</code>这个回调函数。</p>
<p>注意，如果作为参数的 Promise 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> p1 <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Promise</span>((resolve, reject) =&gt; {
</span></span><span style="display:flex;"><span>  resolve(<span style="color:#d14">&#39;hello&#39;</span>);
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>.then(result =&gt; result)
</span></span><span style="display:flex;"><span>.<span style="color:#000;font-weight:bold">catch</span>(e =&gt; e);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> p2 <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Promise</span>((resolve, reject) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">throw</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Error</span>(<span style="color:#d14">&#39;报错了&#39;</span>);
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>.then(result =&gt; result)
</span></span><span style="display:flex;"><span>.<span style="color:#000;font-weight:bold">catch</span>(e =&gt; e);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0086b3">Promise</span>.all([p1, p2])
</span></span><span style="display:flex;"><span>.then(result =&gt; console.log(result))
</span></span><span style="display:flex;"><span>.<span style="color:#000;font-weight:bold">catch</span>(e =&gt; console.log(e));
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// [&#34;hello&#34;, Error: 报错了]
</span></span></span></code></pre></div><p>上面代码中，<code>p1</code>会<code>resolved</code>，<code>p2</code>首先会<code>rejected</code>，但是<code>p2</code>有自己的<code>catch</code>方法，该方法返回的是一个新的 Promise 实例，<code>p2</code>指向的实际上是这个实例。该实例执行完<code>catch</code>方法后，也会变成<code>resolved</code>，导致<code>Promise.all()</code>方法参数里面的两个实例都会<code>resolved</code>，因此会调用<code>then</code>方法指定的回调函数，而不会调用<code>catch</code>方法指定的回调函数。</p>
<p>如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> p1 <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Promise</span>((resolve, reject) =&gt; {
</span></span><span style="display:flex;"><span>  resolve(<span style="color:#d14">&#39;hello&#39;</span>);
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>.then(result =&gt; result);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> p2 <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Promise</span>((resolve, reject) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">throw</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Error</span>(<span style="color:#d14">&#39;报错了&#39;</span>);
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>.then(result =&gt; result);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0086b3">Promise</span>.all([p1, p2])
</span></span><span style="display:flex;"><span>.then(result =&gt; console.log(result))
</span></span><span style="display:flex;"><span>.<span style="color:#000;font-weight:bold">catch</span>(e =&gt; console.log(e));
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Error: 报错了
</span></span></span></code></pre></div><h2 id="promiserace">Promise.race()</h2>
<p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> p <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">Promise</span>.race([p1, p2, p3]);
</span></span></code></pre></div><p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p>
<p><code>Promise.race()</code>方法的参数与<code>Promise.all()</code>方法一样，如果不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve()</code>方法，将参数转为 Promise 实例，再进一步处理。</p>
<p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为<code>reject</code>，否则变为<code>resolve</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> p <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">Promise</span>.race([
</span></span><span style="display:flex;"><span>  fetch(<span style="color:#d14">&#39;/resource-that-may-take-a-while&#39;</span>),
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Promise</span>(<span style="color:#000;font-weight:bold">function</span> (resolve, reject) {
</span></span><span style="display:flex;"><span>    setTimeout(() =&gt; reject(<span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Error</span>(<span style="color:#d14">&#39;request timeout&#39;</span>)), <span style="color:#099">5000</span>)
</span></span><span style="display:flex;"><span>  })
</span></span><span style="display:flex;"><span>]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p
</span></span><span style="display:flex;"><span>.then(console.log)
</span></span><span style="display:flex;"><span>.<span style="color:#000;font-weight:bold">catch</span>(console.error);
</span></span></code></pre></div><p>上面代码中，如果 5 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p>
<h2 id="promiseallsettled">Promise.allSettled()</h2>
<p>有时候，我们希望等到一组异步操作都结束了，不管每一个操作是成功还是失败，再进行下一步操作。但是，现有的 Promise 方法很难实现这个要求。</p>
<p><code>Promise.all()</code>方法只适合所有异步操作都成功的情况，如果有一个操作失败，就无法满足要求。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> urls <span style="color:#000;font-weight:bold">=</span> [url_1, url_2, url_3];
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> requests <span style="color:#000;font-weight:bold">=</span> urls.map(x =&gt; fetch(x));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">await</span> <span style="color:#0086b3">Promise</span>.all(requests);
</span></span><span style="display:flex;"><span>  console.log(<span style="color:#d14">&#39;所有请求都成功。&#39;</span>);
</span></span><span style="display:flex;"><span>} <span style="color:#000;font-weight:bold">catch</span> {
</span></span><span style="display:flex;"><span>  console.log(<span style="color:#d14">&#39;至少一个请求失败，其他请求可能还没结束。&#39;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，<code>Promise.all()</code>可以确定所有请求都成功了，但是只要有一个请求失败，它就会报错，而不管另外的请求是否结束。</p>
<p>为了解决这个问题，<a href="https://github.com/tc39/proposal-promise-allSettled">ES2020</a> 引入了<code>Promise.allSettled()</code>方法，用来确定一组异步操作是否都结束了（不管成功或失败）。所以，它的名字叫做”Settled“，包含了”fulfilled“和”rejected“两种情况。</p>
<p><code>Promise.allSettled()</code>方法接受一个数组作为参数，数组的每个成员都是一个 Promise 对象，并返回一个新的 Promise 对象。只有等到参数数组的所有 Promise 对象都发生状态变更（不管是<code>fulfilled</code>还是<code>rejected</code>），返回的 Promise 对象才会发生状态变更。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> promises <span style="color:#000;font-weight:bold">=</span> [
</span></span><span style="display:flex;"><span>  fetch(<span style="color:#d14">&#39;/api-1&#39;</span>),
</span></span><span style="display:flex;"><span>  fetch(<span style="color:#d14">&#39;/api-2&#39;</span>),
</span></span><span style="display:flex;"><span>  fetch(<span style="color:#d14">&#39;/api-3&#39;</span>),
</span></span><span style="display:flex;"><span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">await</span> <span style="color:#0086b3">Promise</span>.allSettled(promises);
</span></span><span style="display:flex;"><span>removeLoadingIndicator();
</span></span></code></pre></div><p>上面示例中，数组<code>promises</code>包含了三个请求，只有等到这三个请求都结束了（不管请求成功还是失败），<code>removeLoadingIndicator()</code>才会执行。</p>
<p>该方法返回的新的 Promise 实例，一旦发生状态变更，状态总是<code>fulfilled</code>，不会变成<code>rejected</code>。状态变成<code>fulfilled</code>后，它的回调函数会接收到一个数组作为参数，该数组的每个成员对应前面数组的每个 Promise 对象。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> resolved <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">Promise</span>.resolve(<span style="color:#099">42</span>);
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> rejected <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">Promise</span>.reject(<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> allSettledPromise <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">Promise</span>.allSettled([resolved, rejected]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>allSettledPromise.then(<span style="color:#000;font-weight:bold">function</span> (results) {
</span></span><span style="display:flex;"><span>  console.log(results);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// [
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">//    { status: &#39;fulfilled&#39;, value: 42 },
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">//    { status: &#39;rejected&#39;, reason: -1 }
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// ]
</span></span></span></code></pre></div><p>上面代码中，<code>Promise.allSettled()</code>的返回值<code>allSettledPromise</code>，状态只可能变成<code>fulfilled</code>。它的回调函数接收到的参数是数组<code>results</code>。该数组的每个成员都是一个对象，对应传入<code>Promise.allSettled()</code>的数组里面的两个 Promise 对象。</p>
<p><code>results</code>的每个成员是一个对象，对象的格式是固定的，对应异步操作的结果。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 异步操作成功时
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>{status<span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#39;fulfilled&#39;</span>, value<span style="color:#000;font-weight:bold">:</span> value}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 异步操作失败时
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>{status<span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#39;rejected&#39;</span>, reason<span style="color:#000;font-weight:bold">:</span> reason}
</span></span></code></pre></div><p>成员对象的<code>status</code>属性的值只可能是字符串<code>fulfilled</code>或字符串<code>rejected</code>，用来区分异步操作是成功还是失败。如果是成功（<code>fulfilled</code>），对象会有<code>value</code>属性，如果是失败（<code>rejected</code>），会有<code>reason</code>属性，对应两种状态时前面异步操作的返回值。</p>
<p>下面是返回值的用法例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> promises <span style="color:#000;font-weight:bold">=</span> [ fetch(<span style="color:#d14">&#39;index.html&#39;</span>), fetch(<span style="color:#d14">&#39;https://does-not-exist/&#39;</span>) ];
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> results <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">await</span> <span style="color:#0086b3">Promise</span>.allSettled(promises);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 过滤出成功的请求
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> successfulPromises <span style="color:#000;font-weight:bold">=</span> results.filter(p =&gt; p.status <span style="color:#000;font-weight:bold">===</span> <span style="color:#d14">&#39;fulfilled&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 过滤出失败的请求，并输出原因
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> errors <span style="color:#000;font-weight:bold">=</span> results
</span></span><span style="display:flex;"><span>  .filter(p =&gt; p.status <span style="color:#000;font-weight:bold">===</span> <span style="color:#d14">&#39;rejected&#39;</span>)
</span></span><span style="display:flex;"><span>  .map(p =&gt; p.reason);
</span></span></code></pre></div><h2 id="promiseany">Promise.any()</h2>
<p>ES2021 引入了<a href="https://github.com/tc39/proposal-promise-any"><code>Promise.any()</code>方法</a>。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#0086b3">Promise</span>.any([
</span></span><span style="display:flex;"><span>  fetch(<span style="color:#d14">&#39;https://v8.dev/&#39;</span>).then(() =&gt; <span style="color:#d14">&#39;home&#39;</span>),
</span></span><span style="display:flex;"><span>  fetch(<span style="color:#d14">&#39;https://v8.dev/blog&#39;</span>).then(() =&gt; <span style="color:#d14">&#39;blog&#39;</span>),
</span></span><span style="display:flex;"><span>  fetch(<span style="color:#d14">&#39;https://v8.dev/docs&#39;</span>).then(() =&gt; <span style="color:#d14">&#39;docs&#39;</span>)
</span></span><span style="display:flex;"><span>]).then((first) =&gt; {  <span style="color:#998;font-style:italic">// 只要有一个 fetch() 请求成功
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  console.log(first);
</span></span><span style="display:flex;"><span>}).<span style="color:#000;font-weight:bold">catch</span>((error) =&gt; { <span style="color:#998;font-style:italic">// 所有三个 fetch() 全部请求失败
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  console.log(error);
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><p>只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</p>
<p><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是<code>Promise.any()</code>不会因为某个 Promise 变成<code>rejected</code>状态而结束，必须等到所有参数 Promise 变成<code>rejected</code>状态才会结束。</p>
<p>下面是<code>Promise()</code>与<code>await</code>命令结合使用的例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> promises <span style="color:#000;font-weight:bold">=</span> [
</span></span><span style="display:flex;"><span>  fetch(<span style="color:#d14">&#39;/endpoint-a&#39;</span>).then(() =&gt; <span style="color:#d14">&#39;a&#39;</span>),
</span></span><span style="display:flex;"><span>  fetch(<span style="color:#d14">&#39;/endpoint-b&#39;</span>).then(() =&gt; <span style="color:#d14">&#39;b&#39;</span>),
</span></span><span style="display:flex;"><span>  fetch(<span style="color:#d14">&#39;/endpoint-c&#39;</span>).then(() =&gt; <span style="color:#d14">&#39;c&#39;</span>),
</span></span><span style="display:flex;"><span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">const</span> first <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">await</span> <span style="color:#0086b3">Promise</span>.any(promises);
</span></span><span style="display:flex;"><span>  console.log(first);
</span></span><span style="display:flex;"><span>} <span style="color:#000;font-weight:bold">catch</span> (error) {
</span></span><span style="display:flex;"><span>  console.log(error);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码中，<code>Promise.any()</code>方法的参数数组包含三个 Promise 操作。其中只要有一个变成<code>fulfilled</code>，<code>Promise.any()</code>返回的 Promise 对象就变成<code>fulfilled</code>。如果所有三个操作都变成<code>rejected</code>，那么<code>await</code>命令就会抛出错误。</p>
<p><code>Promise.any()</code>抛出的错误是一个 AggregateError 实例（详见《对象的扩展》一章），这个 AggregateError 实例对象的<code>errors</code>属性是一个数组，包含了所有成员的错误。</p>
<p>下面是一个例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> resolved <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">Promise</span>.resolve(<span style="color:#099">42</span>);
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> rejected <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">Promise</span>.reject(<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>);
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> alsoRejected <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">Promise</span>.reject(<span style="color:#000;font-weight:bold">Infinity</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0086b3">Promise</span>.any([resolved, rejected, alsoRejected]).then(<span style="color:#000;font-weight:bold">function</span> (result) {
</span></span><span style="display:flex;"><span>  console.log(result); <span style="color:#998;font-style:italic">// 42
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0086b3">Promise</span>.any([rejected, alsoRejected]).<span style="color:#000;font-weight:bold">catch</span>(<span style="color:#000;font-weight:bold">function</span> (results) {
</span></span><span style="display:flex;"><span>  console.log(results <span style="color:#000;font-weight:bold">instanceof</span> AggregateError); <span style="color:#998;font-style:italic">// true
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  console.log(results.errors); <span style="color:#998;font-style:italic">// [-1, Infinity]
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>});
</span></span></code></pre></div><h2 id="promiseresolve">Promise.resolve()</h2>
<p>有时需要将现有对象转为 Promise 对象，<code>Promise.resolve()</code>方法就起到这个作用。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> jsPromise <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">Promise</span>.resolve($.ajax(<span style="color:#d14">&#39;/whatever.json&#39;</span>));
</span></span></code></pre></div><p>上面代码将 jQuery 生成的<code>deferred</code>对象，转为一个新的 Promise 对象。</p>
<p><code>Promise.resolve()</code>等价于下面的写法。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#0086b3">Promise</span>.resolve(<span style="color:#d14">&#39;foo&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 等价于
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Promise</span>(resolve =&gt; resolve(<span style="color:#d14">&#39;foo&#39;</span>))
</span></span></code></pre></div><p><code>Promise.resolve()</code>方法的参数分成四种情况。</p>
<p><strong>（1）参数是一个 Promise 实例</strong></p>
<p>如果参数是 Promise 实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p>
<p><strong>（2）参数是一个</strong>**<code>thenable</code>**<strong>对象</strong></p>
<p><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> thenable <span style="color:#000;font-weight:bold">=</span> {
</span></span><span style="display:flex;"><span>  then<span style="color:#000;font-weight:bold">:</span> <span style="color:#000;font-weight:bold">function</span>(resolve, reject) {
</span></span><span style="display:flex;"><span>    resolve(<span style="color:#099">42</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><code>Promise.resolve()</code>方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> thenable <span style="color:#000;font-weight:bold">=</span> {
</span></span><span style="display:flex;"><span>  then<span style="color:#000;font-weight:bold">:</span> <span style="color:#000;font-weight:bold">function</span>(resolve, reject) {
</span></span><span style="display:flex;"><span>    resolve(<span style="color:#099">42</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> p1 <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">Promise</span>.resolve(thenable);
</span></span><span style="display:flex;"><span>p1.then(<span style="color:#000;font-weight:bold">function</span> (value) {
</span></span><span style="display:flex;"><span>  console.log(value);  <span style="color:#998;font-style:italic">// 42
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>});
</span></span></code></pre></div><p>上面代码中，<code>thenable</code>对象的<code>then()</code>方法执行后，对象<code>p1</code>的状态就变为<code>resolved</code>，从而立即执行最后那个<code>then()</code>方法指定的回调函数，输出42。</p>
<p><strong>（3）参数不是具有</strong>**<code>then()</code>**<strong>方法的对象，或根本就不是对象</strong></p>
<p>如果参数是一个原始值，或者是一个不具有<code>then()</code>方法的对象，则<code>Promise.resolve()</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> p <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">Promise</span>.resolve(<span style="color:#d14">&#39;Hello&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p.then(<span style="color:#000;font-weight:bold">function</span> (s) {
</span></span><span style="display:flex;"><span>  console.log(s)
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Hello
</span></span></span></code></pre></div><p>上面代码生成一个新的 Promise 对象的实例<code>p</code>。由于字符串<code>Hello</code>不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是<code>resolved</code>，所以回调函数会立即执行。<code>Promise.resolve()</code>方法的参数，会同时传给回调函数。</p>
<p><strong>（4）不带有任何参数</strong></p>
<p><code>Promise.resolve()</code>方法允许调用时不带参数，直接返回一个<code>resolved</code>状态的 Promise 对象。</p>
<p>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用<code>Promise.resolve()</code>方法。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> p <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">Promise</span>.resolve();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p.then(<span style="color:#000;font-weight:bold">function</span> () {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>});
</span></span></code></pre></div><p>上面代码的变量<code>p</code>就是一个 Promise 对象。</p>
<p>需要注意的是，立即<code>resolve()</code>的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>setTimeout(<span style="color:#000;font-weight:bold">function</span> () {
</span></span><span style="display:flex;"><span>  console.log(<span style="color:#d14">&#39;three&#39;</span>);
</span></span><span style="display:flex;"><span>}, <span style="color:#099">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0086b3">Promise</span>.resolve().then(<span style="color:#000;font-weight:bold">function</span> () {
</span></span><span style="display:flex;"><span>  console.log(<span style="color:#d14">&#39;two&#39;</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>console.log(<span style="color:#d14">&#39;one&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// one
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// two
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// three
</span></span></span></code></pre></div><p>上面代码中，<code>setTimeout(fn, 0)</code>在下一轮“事件循环”开始时执行，<code>Promise.resolve()</code>在本轮“事件循环”结束时执行，<code>console.log('one')</code>则是立即执行，因此最先输出。</p>
<h2 id="promisereject">Promise.reject()</h2>
<p><code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> p <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">Promise</span>.reject(<span style="color:#d14">&#39;出错了&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 等同于
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> p <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Promise</span>((resolve, reject) =&gt; reject(<span style="color:#d14">&#39;出错了&#39;</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p.then(<span style="color:#000;font-weight:bold">null</span>, <span style="color:#000;font-weight:bold">function</span> (s) {
</span></span><span style="display:flex;"><span>  console.log(s)
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 出错了
</span></span></span></code></pre></div><p>上面代码生成一个 Promise 对象的实例<code>p</code>，状态为<code>rejected</code>，回调函数会立即执行。</p>
<p><code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#0086b3">Promise</span>.reject(<span style="color:#d14">&#39;出错了&#39;</span>)
</span></span><span style="display:flex;"><span>.<span style="color:#000;font-weight:bold">catch</span>(e =&gt; {
</span></span><span style="display:flex;"><span>  console.log(e <span style="color:#000;font-weight:bold">===</span> <span style="color:#d14">&#39;出错了&#39;</span>)
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// true
</span></span></span></code></pre></div><p>上面代码中，<code>Promise.reject()</code>方法的参数是一个字符串，后面<code>catch()</code>方法的参数<code>e</code>就是这个字符串。</p>
<h2 id="应用">应用</h2>
<h3 id="加载图片">加载图片</h3>
<p>我们可以将图片的加载写成一个<code>Promise</code>，一旦加载完成，<code>Promise</code>的状态就发生变化。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> preloadImage <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">function</span> (path) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Promise</span>(<span style="color:#000;font-weight:bold">function</span> (resolve, reject) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">const</span> image <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> Image();
</span></span><span style="display:flex;"><span>    image.onload  <span style="color:#000;font-weight:bold">=</span> resolve;
</span></span><span style="display:flex;"><span>    image.onerror <span style="color:#000;font-weight:bold">=</span> reject;
</span></span><span style="display:flex;"><span>    image.src <span style="color:#000;font-weight:bold">=</span> path;
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="generator-函数与-promise-的结合">Generator 函数与 Promise 的结合</h3>
<p>使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个<code>Promise</code>对象。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> getFoo () {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Promise</span>(<span style="color:#000;font-weight:bold">function</span> (resolve, reject){
</span></span><span style="display:flex;"><span>    resolve(<span style="color:#d14">&#39;foo&#39;</span>);
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> g <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">function</span><span style="color:#000;font-weight:bold">*</span> () {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">const</span> foo <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">yield</span> getFoo();
</span></span><span style="display:flex;"><span>    console.log(foo);
</span></span><span style="display:flex;"><span>  } <span style="color:#000;font-weight:bold">catch</span> (e) {
</span></span><span style="display:flex;"><span>    console.log(e);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> run (generator) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">const</span> it <span style="color:#000;font-weight:bold">=</span> generator();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">function</span> go(result) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> (result.done) <span style="color:#000;font-weight:bold">return</span> result.value;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> result.value.then(<span style="color:#000;font-weight:bold">function</span> (value) {
</span></span><span style="display:flex;"><span>      <span style="color:#000;font-weight:bold">return</span> go(it.next(value));
</span></span><span style="display:flex;"><span>    }, <span style="color:#000;font-weight:bold">function</span> (error) {
</span></span><span style="display:flex;"><span>      <span style="color:#000;font-weight:bold">return</span> go(it.<span style="color:#000;font-weight:bold">throw</span>(error));
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  go(it.next());
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>run(g);
</span></span></code></pre></div><p>上面代码的 Generator 函数<code>g</code>之中，有一个异步操作<code>getFoo</code>，它返回的就是一个<code>Promise</code>对象。函数<code>run</code>用来处理这个<code>Promise</code>对象，并调用下一个<code>next</code>方法。</p>
<h2 id="promisetry">Promise.try()</h2>
<p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数<code>f</code>是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管<code>f</code>是否包含异步操作，都用<code>then</code>方法指定下一步流程，用<code>catch</code>方法处理<code>f</code>抛出的错误。一般就会采用下面的写法。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#0086b3">Promise</span>.resolve().then(f)
</span></span></code></pre></div><p>上面的写法有一个缺点，就是如果<code>f</code>是同步函数，那么它会在本轮事件循环的末尾执行。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> f <span style="color:#000;font-weight:bold">=</span> () =&gt; console.log(<span style="color:#d14">&#39;now&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#0086b3">Promise</span>.resolve().then(f);
</span></span><span style="display:flex;"><span>console.log(<span style="color:#d14">&#39;next&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// next
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// now
</span></span></span></code></pre></div><p>上面代码中，函数<code>f</code>是同步的，但是用 Promise 包装了以后，就变成异步执行了。</p>
<p>那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法。第一种写法是用<code>async</code>函数来写。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> f <span style="color:#000;font-weight:bold">=</span> () =&gt; console.log(<span style="color:#d14">&#39;now&#39;</span>);
</span></span><span style="display:flex;"><span>(<span style="color:#000;font-weight:bold">async</span> () =&gt; f())();
</span></span><span style="display:flex;"><span>console.log(<span style="color:#d14">&#39;next&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// now
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// next
</span></span></span></code></pre></div><p>上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的<code>async</code>函数，因此如果<code>f</code>是同步的，就会得到同步的结果；如果<code>f</code>是异步的，就可以用<code>then</code>指定下一步，就像下面的写法。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>(<span style="color:#000;font-weight:bold">async</span> () =&gt; f())()
</span></span><span style="display:flex;"><span>.then(...)
</span></span></code></pre></div><p>需要注意的是，<code>async () =&gt; f()</code>会吃掉<code>f()</code>抛出的错误。所以，如果想捕获错误，要使用<code>promise.catch</code>方法。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>(<span style="color:#000;font-weight:bold">async</span> () =&gt; f())()
</span></span><span style="display:flex;"><span>.then(...)
</span></span><span style="display:flex;"><span>.<span style="color:#000;font-weight:bold">catch</span>(...)
</span></span></code></pre></div><p>第二种写法是使用<code>new Promise()</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> f <span style="color:#000;font-weight:bold">=</span> () =&gt; console.log(<span style="color:#d14">&#39;now&#39;</span>);
</span></span><span style="display:flex;"><span>(
</span></span><span style="display:flex;"><span>  () =&gt; <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Promise</span>(
</span></span><span style="display:flex;"><span>    resolve =&gt; resolve(f())
</span></span><span style="display:flex;"><span>  )
</span></span><span style="display:flex;"><span>)();
</span></span><span style="display:flex;"><span>console.log(<span style="color:#d14">&#39;next&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// now
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// next
</span></span></span></code></pre></div><p>上面代码也是使用立即执行的匿名函数，执行<code>new Promise()</code>。这种情况下，同步函数也是同步执行的。</p>
<p>鉴于这是一个很常见的需求，所以现在有一个<a href="https://github.com/ljharb/proposal-promise-try">提案</a>，提供<code>Promise.try</code>方法替代上面的写法。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> f <span style="color:#000;font-weight:bold">=</span> () =&gt; console.log(<span style="color:#d14">&#39;now&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#0086b3">Promise</span>.<span style="color:#000;font-weight:bold">try</span>(f);
</span></span><span style="display:flex;"><span>console.log(<span style="color:#d14">&#39;next&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// now
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// next
</span></span></span></code></pre></div><p>事实上，<code>Promise.try</code>存在已久，Promise 库<a href="http://bluebirdjs.com/docs/api/promise.try.html"><code>Bluebird</code></a>、<a href="https://github.com/kriskowal/q/wiki/API-Reference#promisefcallargs"><code>Q</code></a>和<a href="https://github.com/cujojs/when/blob/master/docs/api.md#whentry"><code>when</code></a>，早就提供了这个方法。</p>
<p>由于<code>Promise.try</code>为所有操作提供了统一的处理机制，所以如果想用<code>then</code>方法管理流程，最好都用<code>Promise.try</code>包装一下。这样有<a href="http://cryto.net/~joepie91/blog/2016/05/11/what-is-promise-try-and-why-does-it-matter/">许多好处</a>，其中一点就是可以更好地管理异常。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> getUsername(userId) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> database.users.get({id<span style="color:#000;font-weight:bold">:</span> userId})
</span></span><span style="display:flex;"><span>  .then(<span style="color:#000;font-weight:bold">function</span>(user) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> user.name;
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码中，<code>database.users.get()</code>返回一个 Promise 对象，如果抛出异步错误，可以用<code>catch</code>方法捕获，就像下面这样写。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>database.users.get({id<span style="color:#000;font-weight:bold">:</span> userId})
</span></span><span style="display:flex;"><span>.then(...)
</span></span><span style="display:flex;"><span>.<span style="color:#000;font-weight:bold">catch</span>(...)
</span></span></code></pre></div><p>但是<code>database.users.get()</code>可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用<code>try...catch</code>去捕获。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>  database.users.get({id<span style="color:#000;font-weight:bold">:</span> userId})
</span></span><span style="display:flex;"><span>  .then(...)
</span></span><span style="display:flex;"><span>  .<span style="color:#000;font-weight:bold">catch</span>(...)
</span></span><span style="display:flex;"><span>} <span style="color:#000;font-weight:bold">catch</span> (e) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>上面这样的写法就很笨拙了，这时就可以统一用<code>promise.catch()</code>捕获所有同步和异步的错误。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#0086b3">Promise</span>.<span style="color:#000;font-weight:bold">try</span>(() =&gt; database.users.get({id<span style="color:#000;font-weight:bold">:</span> userId}))
</span></span><span style="display:flex;"><span>  .then(...)
</span></span><span style="display:flex;"><span>  .<span style="color:#000;font-weight:bold">catch</span>(...)
</span></span></code></pre></div><p>事实上，<code>Promise.try</code>就是模拟<code>try</code>代码块，就像<code>promise.catch</code>模拟的是<code>catch</code>代码块。</p>

        </div>

        
<div class="post-archive">
    <ul class="post-copyright">
        <li><strong>Author: </strong><a rel="author" href="http://shansec.github.io">未来可期</a></li>
        <li style="word-break:break-all"><strong>Link: </strong><a href="http://shansec.github.io/post/es6/Promise%E5%AF%B9%E8%B1%A1/">http://shansec.github.io/post/es6/Promise%E5%AF%B9%E8%B1%A1/</a></li>
        <li><strong>License: </strong>This work is under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>. Kindly fulfill the requirements of the aforementioned License when adapting or creating a derivative of this work.</li>
    </ul>
</div>
<br/>



        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/post/es6/Module%E7%9A%84%E8%AF%AD%E6%B3%95/">Module的语法</a></li>
        
        <li><a href="/post/es6/Module%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/">Module的加载实现</a></li>
        
        <li><a href="/post/es6/Mixin/">Mixin</a></li>
        
        <li><a href="/post/es6/let%E5%92%8Cconst%E5%91%BD%E4%BB%A4/">Let和const命令</a></li>
        
        <li><a href="/post/es6/Iterator%E5%92%8Cfor...of%E5%BE%AA%E7%8E%AF/">Iterator和for...of循环</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='/tags/javaScript' target="_blank">javaScript</a></li>
                
                <li><a href='/tags/es6' target="_blank">es6</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "your github repo"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
    
    

</div>

                    <footer id="footer">
    <div>
        &copy; 2024 <a href="http://shansec.github.io">未来可期的博客 By 未来可期</a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>
<style type="text/css">
div.highlight {
    position: relative;
    margin: 1em 0px;
}

.copy-code {
    display: none;
    position: absolute;
    top: 4px;
    right: 4px;
    color: rgba(255, 255, 255, 0.8);
    background: rgba(78, 78, 78, 0.8);
    border-radius: var(--radius);
    padding: 0 5px;
    font: inherit;
    user-select: none;
    cursor: pointer;
    border: 0;
    --radius: 8px;
}

div.highlight:hover .copy-code,pre:hover .copy-code {
    display: block;
}

</style>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>


    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




    <script src='/js/douban.js'></script>

                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='http://shansec.github.io/search' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="http://shansec.github.io">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>

    <section class="widget">
        <h3 class="widget-title">Latest articles</h3>
<ul class="widget-list">
    
    <li>
        <a href="http://shansec.github.io/post/ts/typescript-%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B/" title="Typescript 数组类型" target="_blank">Typescript 数组类型</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/typescript-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/" title="Typescript 类型系统" target="_blank">Typescript 类型系统</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/typescript-any%E7%B1%BB%E5%9E%8B%E5%92%8Cunknown%E7%B1%BB%E5%9E%8B%E5%92%8Cnever%E7%B1%BB%E5%9E%8B/" title="Typescript Any类型和unknown类型和never类型" target="_blank">Typescript Any类型和unknown类型和never类型</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/typescript-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/" title="Typescript 基本用法" target="_blank">Typescript 基本用法</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/es6/%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E6%89%A9%E5%B1%95/" title="运算符的扩展" target="_blank">运算符的扩展</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/es6/%E8%A3%85%E9%A5%B0%E5%99%A8/" title="装饰器" target="_blank">装饰器</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/es6/%E6%AD%A3%E5%88%99%E7%9A%84%E6%89%A9%E5%B1%95/" title="正则的扩展" target="_blank">正则的扩展</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/es6/%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95/" title="数组的扩展" target="_blank">数组的扩展</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/es6/%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95/" title="数值的扩展" target="_blank">数值的扩展</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/es6/%E5%BC%82%E6%AD%A5%E9%81%8D%E5%8E%86%E5%99%A8/" title="异步遍历器" target="_blank">异步遍历器</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href='/categories/'>Categories</a></h3>
<ul class="widget-list">
    
    <li><a href="http://shansec.github.io/categories/go/">go (43)</a></li>
    
    <li><a href="http://shansec.github.io/categories/%E5%89%8D%E7%AB%AF/">前端 (56)</a></li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href='/tags/'>Tags</a></h3>
<div class="tagcloud">
    
    <a href="http://shansec.github.io/tags/CSS/">CSS</a>
    
    <a href="http://shansec.github.io/tags/HTTP/">HTTP</a>
    
    <a href="http://shansec.github.io/tags/javaScript/">javaScript</a>
    
    <a href="http://shansec.github.io/tags/CSS/">CSS</a>
    
    <a href="http://shansec.github.io/tags/docker/">docker</a>
    
    <a href="http://shansec.github.io/tags/es6/">es6</a>
    
    <a href="http://shansec.github.io/tags/go/">go</a>
    
    <a href="http://shansec.github.io/tags/go-%E5%9F%BA%E7%A1%80/">go 基础</a>
    
    <a href="http://shansec.github.io/tags/go-%E6%A0%87%E5%87%86%E5%BA%93/">go 标准库</a>
    
    <a href="http://shansec.github.io/tags/javaScript/">javaScript</a>
    
    <a href="http://shansec.github.io/tags/jwt/">jwt</a>
    
    <a href="http://shansec.github.io/tags/package/">package</a>
    
    <a href="http://shansec.github.io/tags/pinia/">pinia</a>
    
    <a href="http://shansec.github.io/tags/redis/">redis</a>
    
    <a href="http://shansec.github.io/tags/sql/">sql</a>
    
    <a href="http://shansec.github.io/tags/sqlx/">sqlx</a>
    
    <a href="http://shansec.github.io/tags/typescript/">typescript</a>
    
    <a href="http://shansec.github.io/tags/vue/">vue</a>
    
    <a href="http://shansec.github.io/tags/%E5%AD%98%E5%82%A8/">存储</a>
    
    <a href="http://shansec.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">微信小程序</a>
    
    <a href="http://shansec.github.io/tags/%E6%A0%87%E5%87%86%E5%BA%93/">标准库</a>
    
    <a href="http://shansec.github.io/tags/%E6%A1%86%E6%9E%B6/">框架</a>
    
    <a href="http://shansec.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/">计算机原理</a>
    
</div>
    </section>

    
<section class="widget">
    <h3 class="widget-title">Links</h3>
    <ul class="widget-list">
        
        <li>
            <a target="_blank" href="https://www.liwenzhou.com/" title="李文周的博客">李文周的博客</a>
        </li>
        
    </ul>
</section>


    <section class="widget">
        <h3 class="widget-title">Meta</h3>
        <ul class="widget-list">
            <li><a href="http://shansec.github.io/index.xml">RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>