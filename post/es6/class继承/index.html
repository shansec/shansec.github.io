<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <meta name="referrer" content="no-referrer-when-downgrade">
    

    <title>Class继承 | 未来可期的博客</title>
    <meta property="og:title" content="Class继承 - 未来可期的博客">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2024-04-23T09:41:22&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2024-04-23T09:41:22&#43;08:00'>
        
    <meta name="Keywords" content="golang,go语言,go语言笔记,未来可期,博客,公众号,小程序">
    <meta name="description" content="Class继承">
        
    <meta name="author" content="未来可期">
    <meta property="og:url" content="http://shansec.github.io/post/es6/class%E7%BB%A7%E6%89%BF/">
    <link rel="shortcut icon" href='/favicon.ico'  type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
        <link rel="stylesheet" href='/css/douban.css'>
    
        <link rel="stylesheet" href='/css/other.css'>
    
</head>

<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="http://shansec.github.io">
                        未来可期的博客
                    </a>
                
                <p class="description">专注于Go语言(golang)、前端技术</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="http://shansec.github.io">Home</a>
                    
                    <a  href="http://shansec.github.io/archives/" title="归档">归档</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    <style type="text/css">
    .post-toc {
        position: fixed;
        width: 200px;
        margin-left: -210px;
        padding: 5px 10px;
        font-family: Athelas, STHeiti, Microsoft Yahei, serif;
        font-size: 12px;
        border: 1px solid rgba(0, 0, 0, .07);
        border-radius: 5px;
        background-color: rgba(255, 255, 255, 0.98);
        background-clip: padding-box;
        -webkit-box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        word-wrap: break-word;
        white-space: nowrap;
        -webkit-box-sizing: border-box;
        box-sizing: border-box;
        z-index: 999;
        cursor: pointer;
        max-height: 70%;
        overflow-y: auto;
        overflow-x: hidden;
    }

    .post-toc .post-toc-title {
        width: 100%;
        margin: 0 auto;
        font-size: 20px;
        font-weight: 400;
        text-transform: uppercase;
        text-align: center;
    }

    .post-toc .post-toc-content {
        font-size: 15px;
    }

    .post-toc .post-toc-content>nav>ul {
        margin: 10px 0;
    }

    .post-toc .post-toc-content ul {
        padding-left: 20px;
        list-style: square;
        margin: 0.5em;
        line-height: 1.8em;
    }

    .post-toc .post-toc-content ul ul {
        padding-left: 15px;
        display: none;
    }

    @media print,
    screen and (max-width:1057px) {
        .post-toc {
            display: none;
        }
    }
</style>
<div class="post-toc" style="position: absolute; top: 188px;">
    <h2 class="post-toc-title">Table of Contents</h2>
    <div class="post-toc-content">
        <nav id="TableOfContents">
  <ul>
    <li><a href="#简介">简介</a></li>
    <li><a href="#私有属性和私有方法的继承">私有属性和私有方法的继承</a></li>
    <li><a href="#静态属性和静态方法的继承">静态属性和静态方法的继承</a></li>
    <li><a href="#objectgetprototypeof">Object.getPrototypeOf()</a></li>
    <li><a href="#super-关键字">super 关键字</a></li>
    <li><a href="#类的-prototype-属性和__proto__属性">类的 prototype 属性和__proto__属性</a>
      <ul>
        <li><a href="#实例的-proto-属性">实例的 <strong>proto</strong> 属性</a></li>
      </ul>
    </li>
    <li><a href="#原生构造函数的继承">原生构造函数的继承</a></li>
    <li><a href="#mixin-模式的实现">Mixin 模式的实现</a></li>
  </ul>
</nav>
    </div>
</div>
<script type="text/javascript">
    $(document).ready(function () {
        var postToc = $(".post-toc");
        if (postToc.length) {
            var leftPos = $("#main").offset().left;
            if (leftPos < 220) {
                postToc.css({ "width": leftPos - 10, "margin-left": (0 - leftPos) })
            }

            var t = postToc.offset().top - 20,
                a = {
                    start: {
                        position: "absolute",
                        top: t
                    },
                    process: {
                        position: "fixed",
                        top: 20
                    },
                };
            $(window).scroll(function () {
                var e = $(window).scrollTop();
                e < t ? postToc.css(a.start) : postToc.css(a.process)
            })
        }

        if ($("#TableOfContents").children().length < 1) {
            $(".post-toc").remove();
        }
    })
</script>
    <article class="post">
        <header>
            <h1 class="post-title">Class继承</h1>
        </header>
        
  <time datetime="2024-04-23T01:41:22Z" class="post-meta meta-date dt-published">
    2024-04-23
  </time>


<div class="post-meta meta-category">
  <span>&nbsp;|</span>
  
    <a href='/categories/%E5%89%8D%E7%AB%AF' target="_blank">前端</a>
  
</div>


        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">&nbsp;|
                <span id="busuanzi_value_page_pv"></span> <span>reads</span>
            </span>
        </div>
        
        
        <div class="post-content">
            <h1 id="class-的继承">Class 的继承</h1>
<h2 id="简介">简介</h2>
<p>Class 可以通过<code>extends</code>关键字实现继承，让子类继承父类的属性和方法。extends 的写法比 ES5 的原型链继承，要清晰和方便很多。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Point {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> ColorPoint <span style="color:#000;font-weight:bold">extends</span> Point {
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，<code>Point</code>是父类，<code>ColorPoint</code>是子类，它通过<code>extends</code>关键字，继承了<code>Point</code>类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个<code>Point</code>类。</p>
<p>下面，我们在<code>ColorPoint</code>内部加上代码。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Point { <span style="color:#998;font-style:italic">/* ... */</span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> ColorPoint <span style="color:#000;font-weight:bold">extends</span> Point {
</span></span><span style="display:flex;"><span>  constructor(x, y, color) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">super</span>(x, y); <span style="color:#998;font-style:italic">// 调用父类的constructor(x, y)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">this</span>.color <span style="color:#000;font-weight:bold">=</span> color;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  toString() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">this</span>.color <span style="color:#000;font-weight:bold">+</span> <span style="color:#d14">&#39; &#39;</span> <span style="color:#000;font-weight:bold">+</span> <span style="color:#000;font-weight:bold">super</span>.toString(); <span style="color:#998;font-style:italic">// 调用父类的toString()
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，<code>constructor()</code>方法和<code>toString()</code>方法内部，都出现了<code>super</code>关键字。<code>super</code>在这里表示父类的构造函数，用来新建一个父类的实例对象。</p>
<p>ES6 规定，子类必须在<code>constructor()</code>方法中调用<code>super()</code>，否则就会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，添加子类自己的实例属性和方法。如果不调用<code>super()</code>方法，子类就得不到自己的<code>this</code>对象。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Point { <span style="color:#998;font-style:italic">/* ... */</span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> ColorPoint <span style="color:#000;font-weight:bold">extends</span> Point {
</span></span><span style="display:flex;"><span>  constructor() {
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> cp <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> ColorPoint(); <span style="color:#998;font-style:italic">// ReferenceError
</span></span></span></code></pre></div><p>上面代码中，<code>ColorPoint</code>继承了父类<code>Point</code>，但是它的构造函数没有调用<code>super()</code>，导致新建实例时报错。</p>
<p>为什么子类的构造函数，一定要调用<code>super()</code>？原因就在于 ES6 的继承机制，与 ES5 完全不同。ES5 的继承机制，是先创造一个独立的子类的实例对象，然后再将父类的方法添加到这个对象上面，即“实例在前，继承在后”。ES6 的继承机制，则是先将父类的属性和方法，加到一个空的对象上面，然后再将该对象作为子类的实例，即“继承在前，实例在后”。这就是为什么 ES6 的继承必须先调用<code>super()</code>方法，因为这一步会生成一个继承父类的<code>this</code>对象，没有这一步就无法继承父类。</p>
<p>注意，这意味着新建子类实例时，父类的构造函数必定会先运行一次。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Foo {
</span></span><span style="display:flex;"><span>  constructor() {
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#099">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Bar <span style="color:#000;font-weight:bold">extends</span> Foo {
</span></span><span style="display:flex;"><span>  constructor() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">super</span>();
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#099">2</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> bar <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> Bar();
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 2
</span></span></span></code></pre></div><p>上面示例中，子类 Bar 新建实例时，会输出1和2。原因就是子类构造函数调用<code>super()</code>时，会执行一次父类构造函数。</p>
<p>另一个需要注意的地方是，在子类的构造函数中，只有调用<code>super()</code>之后，才可以使用<code>this</code>关键字，否则会报错。这是因为子类实例的构建，必须先完成父类的继承，只有<code>super()</code>方法才能让子类实例继承父类。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Point {
</span></span><span style="display:flex;"><span>  constructor(x, y) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.x <span style="color:#000;font-weight:bold">=</span> x;
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.y <span style="color:#000;font-weight:bold">=</span> y;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> ColorPoint <span style="color:#000;font-weight:bold">extends</span> Point {
</span></span><span style="display:flex;"><span>  constructor(x, y, color) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.color <span style="color:#000;font-weight:bold">=</span> color; <span style="color:#998;font-style:italic">// ReferenceError
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">super</span>(x, y);
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.color <span style="color:#000;font-weight:bold">=</span> color; <span style="color:#998;font-style:italic">// 正确
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码中，子类的<code>constructor()</code>方法没有调用<code>super()</code>之前，就使用<code>this</code>关键字，结果报错，而放在<code>super()</code>之后就是正确的。</p>
<p>如果子类没有定义<code>constructor()</code>方法，这个方法会默认添加，并且里面会调用<code>super()</code>。也就是说，不管有没有显式定义，任何一个子类都有<code>constructor()</code>方法。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> ColorPoint <span style="color:#000;font-weight:bold">extends</span> Point {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 等同于
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">class</span> ColorPoint <span style="color:#000;font-weight:bold">extends</span> Point {
</span></span><span style="display:flex;"><span>  constructor(...args) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">super</span>(...args);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>有了子类的定义，就可以生成子类的实例了。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> cp <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> ColorPoint(<span style="color:#099">25</span>, <span style="color:#099">8</span>, <span style="color:#d14">&#39;green&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cp <span style="color:#000;font-weight:bold">instanceof</span> ColorPoint <span style="color:#998;font-style:italic">// true
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>cp <span style="color:#000;font-weight:bold">instanceof</span> Point <span style="color:#998;font-style:italic">// true
</span></span></span></code></pre></div><p>上面示例中，实例对象<code>cp</code>同时是<code>ColorPoint</code>和<code>Point</code>两个类的实例，这与 ES5 的行为完全一致。</p>
<h2 id="私有属性和私有方法的继承">私有属性和私有方法的继承</h2>
<p>父类所有的属性和方法，都会被子类继承，除了私有的属性和方法。</p>
<p>子类无法继承父类的私有属性，或者说，私有属性只能在定义它的 class 里面使用。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Foo {
</span></span><span style="display:flex;"><span>  <span style="color:#a61717;background-color:#e3d2d2">#</span>p <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a61717;background-color:#e3d2d2">#</span>m() {
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#d14">&#39;hello&#39;</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Bar <span style="color:#000;font-weight:bold">extends</span> Foo {
</span></span><span style="display:flex;"><span>  constructor() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">super</span>();
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#000;font-weight:bold">this</span>.<span style="color:#a61717;background-color:#e3d2d2">#</span>p); <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">this</span>.<span style="color:#a61717;background-color:#e3d2d2">#</span>m(); <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，子类 Bar 调用父类 Foo 的私有属性或私有方法，都会报错。</p>
<p>如果父类定义了私有属性的读写方法，子类就可以通过这些方法，读写私有属性。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Foo {
</span></span><span style="display:flex;"><span>  <span style="color:#a61717;background-color:#e3d2d2">#</span>p <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>  getP() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">this</span>.<span style="color:#a61717;background-color:#e3d2d2">#</span>p;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Bar <span style="color:#000;font-weight:bold">extends</span> Foo {
</span></span><span style="display:flex;"><span>  constructor() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">super</span>();
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#000;font-weight:bold">this</span>.getP()); <span style="color:#998;font-style:italic">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，<code>getP()</code>是父类用来读取私有属性的方法，通过该方法，子类就可以读到父类的私有属性。</p>
<h2 id="静态属性和静态方法的继承">静态属性和静态方法的继承</h2>
<p>父类的静态属性和静态方法，也会被子类继承。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">static</span> hello() {
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#d14">&#39;hello world&#39;</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>B.hello()  <span style="color:#998;font-style:italic">// hello world
</span></span></span></code></pre></div><p>上面代码中，<code>hello()</code>是<code>A</code>类的静态方法，<code>B</code>继承<code>A</code>，也继承了<code>A</code>的静态方法。</p>
<p>注意，静态属性是通过软拷贝实现继承的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A { <span style="color:#000;font-weight:bold">static</span> foo <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">100</span>; }
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>  constructor() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">super</span>();
</span></span><span style="display:flex;"><span>    B.foo<span style="color:#000;font-weight:bold">--</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> b <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> B();
</span></span><span style="display:flex;"><span>B.foo <span style="color:#998;font-style:italic">// 99
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>A.foo <span style="color:#998;font-style:italic">// 100
</span></span></span></code></pre></div><p>上面示例中，<code>foo</code>是 A 类的静态属性，B 类继承了 A 类，因此也继承了这个属性。但是，在 B 类内部操作<code>B.foo</code>这个静态属性，影响不到<code>A.foo</code>，原因就是 B 类继承静态属性时，会采用浅拷贝，拷贝父类静态属性的值，因此<code>A.foo</code>和<code>B.foo</code>是两个彼此独立的属性。</p>
<p>但是，由于这种拷贝是浅拷贝，如果父类的静态属性的值是一个对象，那么子类的静态属性也会指向这个对象，因为浅拷贝只会拷贝对象的内存地址。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">static</span> foo <span style="color:#000;font-weight:bold">=</span> { n<span style="color:#000;font-weight:bold">:</span> <span style="color:#099">100</span> };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>  constructor() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">super</span>();
</span></span><span style="display:flex;"><span>    B.foo.n<span style="color:#000;font-weight:bold">--</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> b <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> B();
</span></span><span style="display:flex;"><span>B.foo.n <span style="color:#998;font-style:italic">// 99
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>A.foo.n <span style="color:#998;font-style:italic">// 99
</span></span></span></code></pre></div><p>上面示例中，<code>A.foo</code>的值是一个对象，浅拷贝导致<code>B.foo</code>和<code>A.foo</code>指向同一个对象。所以，子类<code>B</code>修改这个对象的属性值，会影响到父类<code>A</code>。</p>
<h2 id="objectgetprototypeof">Object.getPrototypeOf()</h2>
<p><code>Object.getPrototypeOf()</code>方法可以用来从子类上获取父类。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Point { <span style="color:#998;font-style:italic">/*...*/</span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> ColorPoint <span style="color:#000;font-weight:bold">extends</span> Point { <span style="color:#998;font-style:italic">/*...*/</span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0086b3">Object</span>.getPrototypeOf(ColorPoint) <span style="color:#000;font-weight:bold">===</span> Point
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// true
</span></span></span></code></pre></div><p>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p>
<h2 id="super-关键字">super 关键字</h2>
<p><code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p>
<p>第一种情况，<code>super</code>作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次<code>super()</code>函数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>  constructor() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">super</span>();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码中，子类<code>B</code>的构造函数之中的<code>super()</code>，代表调用父类的构造函数。这是必须的，否则报错。</p>
<p>调用<code>super()</code>的作用是形成子类的<code>this</code>对象，把父类的实例属性和方法放到这个<code>this</code>对象上面。子类在调用<code>super()</code>之前，是没有<code>this</code>对象的，任何对<code>this</code>的操作都要放在<code>super()</code>的后面。</p>
<p>注意，这里的<code>super</code>虽然代表了父类的构造函数，但是因为返回的是子类的<code>this</code>（即子类的实例对象），所以<code>super</code>内部的<code>this</code>代表子类的实例，而不是父类的实例，这里的<code>super()</code>相当于<code>A.prototype.constructor.call(this)</code>（在子类的<code>this</code>上运行父类的构造函数）。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  constructor() {
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#000;font-weight:bold">new</span>.target.name);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>  constructor() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">super</span>();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">new</span> A() <span style="color:#998;font-style:italic">// A
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">new</span> B() <span style="color:#998;font-style:italic">// B
</span></span></span></code></pre></div><p>上面示例中，<code>new.target</code>指向当前正在执行的函数。可以看到，在<code>super()</code>执行时（<code>new B()</code>），它指向的是子类<code>B</code>的构造函数，而不是父类<code>A</code>的构造函数。也就是说，<code>super()</code>内部的<code>this</code>指向的是<code>B</code>。</p>
<p>不过，由于<code>super()</code>在子类构造方法中执行时，子类的属性和方法还没有绑定到<code>this</code>，所以如果存在同名属性，此时拿到的是父类的属性。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  name <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;A&#39;</span>;
</span></span><span style="display:flex;"><span>  constructor() {
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#d14">&#39;My name is &#39;</span> <span style="color:#000;font-weight:bold">+</span> <span style="color:#000;font-weight:bold">this</span>.name);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>  name <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;B&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> b <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> B(); <span style="color:#998;font-style:italic">// My name is A
</span></span></span></code></pre></div><p>上面示例中，最后一行输出的是<code>A</code>，而不是<code>B</code>，原因就在于<code>super()</code>执行时，<code>B</code>的<code>name</code>属性还没有绑定到<code>this</code>，所以<code>this.name</code>拿到的是<code>A</code>类的<code>name</code>属性。</p>
<p>作为函数时，<code>super()</code>只能用在子类的构造函数之中，用在其他地方就会报错。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>  m() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">super</span>(); <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码中，<code>super()</code>用在<code>B</code>类的<code>m</code>方法之中，就会造成语法错误。</p>
<p>第二种情况，<code>super</code>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  p() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">2</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>  constructor() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">super</span>();
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#000;font-weight:bold">super</span>.p()); <span style="color:#998;font-style:italic">// 2
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> b <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> B();
</span></span></code></pre></div><p>上面代码中，子类<code>B</code>当中的<code>super.p()</code>，就是将<code>super</code>当作一个对象使用。这时，<code>super</code>在普通方法之中，指向<code>A.prototype</code>，所以<code>super.p()</code>就相当于<code>A.prototype.p()</code>。</p>
<p>这里需要注意，由于<code>super</code>指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过<code>super</code>调用的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  constructor() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.p <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">2</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>  get m() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">super</span>.p;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> b <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> B();
</span></span><span style="display:flex;"><span>b.m <span style="color:#998;font-style:italic">// undefined
</span></span></span></code></pre></div><p>上面代码中，<code>p</code>是父类<code>A</code>实例的属性，<code>super.p</code>就引用不到它。</p>
<p>如果属性定义在父类的原型对象上，<code>super</code>就可以取到。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {}
</span></span><span style="display:flex;"><span>A.prototype.x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">2</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>  constructor() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">super</span>();
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#000;font-weight:bold">super</span>.x) <span style="color:#998;font-style:italic">// 2
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> b <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> B();
</span></span></code></pre></div><p>上面代码中，属性<code>x</code>是定义在<code>A.prototype</code>上面的，所以<code>super.x</code>可以取到它的值。</p>
<p>ES6 规定，在子类普通方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类实例。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  constructor() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  print() {
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#000;font-weight:bold">this</span>.x);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>  constructor() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">super</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">2</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  m() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">super</span>.print();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> b <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> B();
</span></span><span style="display:flex;"><span>b.m() <span style="color:#998;font-style:italic">// 2
</span></span></span></code></pre></div><p>上面代码中，<code>super.print()</code>虽然调用的是<code>A.prototype.print()</code>，但是<code>A.prototype.print()</code>内部的<code>this</code>指向子类<code>B</code>的实例，导致输出的是<code>2</code>，而不是<code>1</code>。也就是说，实际上执行的是<code>super.print.call(this)</code>。</p>
<p>由于<code>this</code>指向子类实例，所以如果通过<code>super</code>对某个属性赋值，这时<code>super</code>就是<code>this</code>，赋值的属性会变成子类实例的属性。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  constructor() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>  constructor() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">super</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">super</span>.x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">3</span>;
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#000;font-weight:bold">super</span>.x); <span style="color:#998;font-style:italic">// undefined
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    console.log(<span style="color:#000;font-weight:bold">this</span>.x); <span style="color:#998;font-style:italic">// 3
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> b <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> B();
</span></span></code></pre></div><p>上面代码中，<code>super.x</code>赋值为<code>3</code>，这时等同于对<code>this.x</code>赋值为<code>3</code>。而当读取<code>super.x</code>的时候，读的是<code>A.prototype.x</code>，所以返回<code>undefined</code>。</p>
<p>如果<code>super</code>作为对象，用在静态方法之中，这时<code>super</code>将指向父类，而不是父类的原型对象。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Parent {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">static</span> myMethod(msg) {
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#d14">&#39;static&#39;</span>, msg);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  myMethod(msg) {
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#d14">&#39;instance&#39;</span>, msg);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Child <span style="color:#000;font-weight:bold">extends</span> Parent {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">static</span> myMethod(msg) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">super</span>.myMethod(msg);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  myMethod(msg) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">super</span>.myMethod(msg);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Child.myMethod(<span style="color:#099">1</span>); <span style="color:#998;font-style:italic">// static 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> child <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> Child();
</span></span><span style="display:flex;"><span>child.myMethod(<span style="color:#099">2</span>); <span style="color:#998;font-style:italic">// instance 2
</span></span></span></code></pre></div><p>上面代码中，<code>super</code>在静态方法之中指向父类，在普通方法之中指向父类的原型对象。</p>
<p>另外，在子类的静态方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类的实例。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  constructor() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">static</span> print() {
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#000;font-weight:bold">this</span>.x);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>  constructor() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">super</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">2</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">static</span> m() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">super</span>.print();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>B.x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">3</span>;
</span></span><span style="display:flex;"><span>B.m() <span style="color:#998;font-style:italic">// 3
</span></span></span></code></pre></div><p>上面代码中，静态方法<code>B.m</code>里面，<code>super.print</code>指向父类的静态方法。这个方法里面的<code>this</code>指向的是<code>B</code>，而不是<code>B</code>的实例。</p>
<p>注意，使用<code>super</code>的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>  constructor() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">super</span>();
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#000;font-weight:bold">super</span>); <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码中，<code>console.log(super)</code>当中的<code>super</code>，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明<code>super</code>的数据类型，就不会报错。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>  constructor() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">super</span>();
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#000;font-weight:bold">super</span>.valueOf() <span style="color:#000;font-weight:bold">instanceof</span> B); <span style="color:#998;font-style:italic">// true
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> b <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> B();
</span></span></code></pre></div><p>上面代码中，<code>super.valueOf()</code>表明<code>super</code>是一个对象，因此就不会报错。同时，由于<code>super</code>使得<code>this</code>指向<code>B</code>的实例，所以<code>super.valueOf()</code>返回的是一个<code>B</code>的实例。</p>
<p>最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用<code>super</code>关键字。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> obj <span style="color:#000;font-weight:bold">=</span> {
</span></span><span style="display:flex;"><span>  toString() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#d14">&#34;MyObject: &#34;</span> <span style="color:#000;font-weight:bold">+</span> <span style="color:#000;font-weight:bold">super</span>.toString();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>obj.toString(); <span style="color:#998;font-style:italic">// MyObject: [object Object]
</span></span></span></code></pre></div><h2 id="类的-prototype-属性和__proto__属性">类的 prototype 属性和__proto__属性</h2>
<p>大多数浏览器的 ES5 实现之中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的<code>prototype</code>属性。Class 作为构造函数的语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p>
<p>（1）子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</p>
<p>（2）子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>B.__proto__ <span style="color:#000;font-weight:bold">===</span> A <span style="color:#998;font-style:italic">// true
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>B.prototype.__proto__ <span style="color:#000;font-weight:bold">===</span> A.prototype <span style="color:#998;font-style:italic">// true
</span></span></span></code></pre></div><p>上面代码中，子类<code>B</code>的<code>__proto__</code>属性指向父类<code>A</code>，子类<code>B</code>的<code>prototype</code>属性的<code>__proto__</code>属性指向父类<code>A</code>的<code>prototype</code>属性。</p>
<p>这样的结果是因为，类的继承是按照下面的模式实现的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// B 的实例继承 A 的实例
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#0086b3">Object</span>.setPrototypeOf(B.prototype, A.prototype);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// B 继承 A 的静态属性
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#0086b3">Object</span>.setPrototypeOf(B, A);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> b <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> B();
</span></span></code></pre></div><p>《对象的扩展》一章给出过<code>Object.setPrototypeOf</code>方法的实现。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#0086b3">Object</span>.setPrototypeOf <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">function</span> (obj, proto) {
</span></span><span style="display:flex;"><span>  obj.__proto__ <span style="color:#000;font-weight:bold">=</span> proto;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> obj;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>因此，就得到了上面的结果。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#0086b3">Object</span>.setPrototypeOf(B.prototype, A.prototype);
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 等同于
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>B.prototype.__proto__ <span style="color:#000;font-weight:bold">=</span> A.prototype;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0086b3">Object</span>.setPrototypeOf(B, A);
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 等同于
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>B.__proto__ <span style="color:#000;font-weight:bold">=</span> A;
</span></span></code></pre></div><p>这两条继承链，可以这样理解：作为一个对象，子类（<code>B</code>）的原型（<code>__proto__</code>属性）是父类（<code>A</code>）；作为一个构造函数，子类（<code>B</code>）的原型对象（<code>prototype</code>属性）是父类的原型对象（<code>prototype</code>属性）的实例。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>B.prototype <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">Object</span>.create(A.prototype);
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 等同于
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>B.prototype.__proto__ <span style="color:#000;font-weight:bold">=</span> A.prototype;
</span></span></code></pre></div><p><code>extends</code>关键字后面可以跟多种类型的值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码的<code>A</code>，只要是一个有<code>prototype</code>属性的函数，就能被<code>B</code>继承。由于函数都有<code>prototype</code>属性（除了<code>Function.prototype</code>函数），因此<code>A</code>可以是任意函数。</p>
<p>下面，讨论两种情况。第一种，子类继承<code>Object</code>类。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A <span style="color:#000;font-weight:bold">extends</span> <span style="color:#0086b3">Object</span> {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>A.__proto__ <span style="color:#000;font-weight:bold">===</span> <span style="color:#0086b3">Object</span> <span style="color:#998;font-style:italic">// true
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>A.prototype.__proto__ <span style="color:#000;font-weight:bold">===</span> <span style="color:#0086b3">Object</span>.prototype <span style="color:#998;font-style:italic">// true
</span></span></span></code></pre></div><p>这种情况下，<code>A</code>其实就是构造函数<code>Object</code>的复制，<code>A</code>的实例就是<code>Object</code>的实例。</p>
<p>第二种情况，不存在任何继承。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>A.__proto__ <span style="color:#000;font-weight:bold">===</span> <span style="color:#0086b3">Function</span>.prototype <span style="color:#998;font-style:italic">// true
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>A.prototype.__proto__ <span style="color:#000;font-weight:bold">===</span> <span style="color:#0086b3">Object</span>.prototype <span style="color:#998;font-style:italic">// true
</span></span></span></code></pre></div><p>这种情况下，<code>A</code>作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承<code>Function.prototype</code>。但是，<code>A</code>调用后返回一个空对象（即<code>Object</code>实例），所以<code>A.prototype.__proto__</code>指向构造函数（<code>Object</code>）的<code>prototype</code>属性。</p>
<h3 id="实例的-proto-属性">实例的 <strong>proto</strong> 属性</h3>
<p>子类实例的<code>__proto__</code>属性的<code>__proto__</code>属性，指向父类实例的<code>__proto__</code>属性。也就是说，子类的原型的原型，是父类的原型。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> p1 <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> Point(<span style="color:#099">2</span>, <span style="color:#099">3</span>);
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> p2 <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> ColorPoint(<span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#d14">&#39;red&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p2.__proto__ <span style="color:#000;font-weight:bold">===</span> p1.__proto__ <span style="color:#998;font-style:italic">// false
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>p2.__proto__.__proto__ <span style="color:#000;font-weight:bold">===</span> p1.__proto__ <span style="color:#998;font-style:italic">// true
</span></span></span></code></pre></div><p>上面代码中，<code>ColorPoint</code>继承了<code>Point</code>，导致前者原型的原型是后者的原型。</p>
<p>因此，通过子类实例的<code>__proto__.__proto__</code>属性，可以修改父类实例的行为。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>p2.__proto__.__proto__.printName <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">function</span> () {
</span></span><span style="display:flex;"><span>  console.log(<span style="color:#d14">&#39;Ha&#39;</span>);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p1.printName() <span style="color:#998;font-style:italic">// &#34;Ha&#34;
</span></span></span></code></pre></div><p>上面代码在<code>ColorPoint</code>的实例<code>p2</code>上向<code>Point</code>类添加方法，结果影响到了<code>Point</code>的实例<code>p1</code>。</p>
<h2 id="原生构造函数的继承">原生构造函数的继承</h2>
<p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。</p>
<ul>
<li>Boolean()</li>
<li>Number()</li>
<li>String()</li>
<li>Array()</li>
<li>Date()</li>
<li>Function()</li>
<li>RegExp()</li>
<li>Error()</li>
<li>Object()</li>
</ul>
<p>以前，这些原生构造函数是无法继承的，比如，不能自己定义一个<code>Array</code>的子类。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> MyArray() {
</span></span><span style="display:flex;"><span>  <span style="color:#0086b3">Array</span>.apply(<span style="color:#000;font-weight:bold">this</span>, arguments);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>MyArray.prototype <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">Object</span>.create(<span style="color:#0086b3">Array</span>.prototype, {
</span></span><span style="display:flex;"><span>  constructor<span style="color:#000;font-weight:bold">:</span> {
</span></span><span style="display:flex;"><span>    value<span style="color:#000;font-weight:bold">:</span> MyArray,
</span></span><span style="display:flex;"><span>    writable<span style="color:#000;font-weight:bold">:</span> <span style="color:#000;font-weight:bold">true</span>,
</span></span><span style="display:flex;"><span>    configurable<span style="color:#000;font-weight:bold">:</span> <span style="color:#000;font-weight:bold">true</span>,
</span></span><span style="display:flex;"><span>    enumerable<span style="color:#000;font-weight:bold">:</span> <span style="color:#000;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><p>上面代码定义了一个继承 Array 的<code>MyArray</code>类。但是，这个类的行为与<code>Array</code>完全不一致。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> colors <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> MyArray();
</span></span><span style="display:flex;"><span>colors[<span style="color:#099">0</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;red&#34;</span>;
</span></span><span style="display:flex;"><span>colors.length  <span style="color:#998;font-style:italic">// 0
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>colors.length <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>colors[<span style="color:#099">0</span>]  <span style="color:#998;font-style:italic">// &#34;red&#34;
</span></span></span></code></pre></div><p>之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过<code>Array.apply()</code>或者分配给原型对象都不行。原生构造函数会忽略<code>apply</code>方法传入的<code>this</code>，也就是说，原生构造函数的<code>this</code>无法绑定，导致拿不到内部属性。</p>
<p>ES5 是先新建子类的实例对象<code>this</code>，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，<code>Array</code>构造函数有一个内部属性<code>[[DefineOwnProperty]]</code>，用来定义新属性时，更新<code>length</code>属性，这个内部属性无法在子类获取，导致子类的<code>length</code>属性行为不正常。</p>
<p>下面的例子中，我们想让一个普通对象继承<code>Error</code>对象。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> e <span style="color:#000;font-weight:bold">=</span> {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0086b3">Object</span>.getOwnPropertyNames(<span style="color:#0086b3">Error</span>.call(e))
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// [ &#39;stack&#39; ]
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#0086b3">Object</span>.getOwnPropertyNames(e)
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// []
</span></span></span></code></pre></div><p>上面代码中，我们想通过<code>Error.call(e)</code>这种写法，让普通对象<code>e</code>具有<code>Error</code>对象的实例属性。但是，<code>Error.call()</code>完全忽略传入的第一个参数，而是返回一个新对象，<code>e</code>本身没有任何变化。这证明了<code>Error.call(e)</code>这种写法，无法继承原生构造函数。</p>
<p>ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象<code>this</code>，然后再用子类的构造函数修饰<code>this</code>，使得父类的所有行为都可以继承。下面是一个继承<code>Array</code>的例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> MyArray <span style="color:#000;font-weight:bold">extends</span> <span style="color:#0086b3">Array</span> {
</span></span><span style="display:flex;"><span>  constructor(...args) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">super</span>(...args);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> arr <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> MyArray();
</span></span><span style="display:flex;"><span>arr[<span style="color:#099">0</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">12</span>;
</span></span><span style="display:flex;"><span>arr.length <span style="color:#998;font-style:italic">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>arr.length <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>arr[<span style="color:#099">0</span>] <span style="color:#998;font-style:italic">// undefined
</span></span></span></code></pre></div><p>上面代码定义了一个<code>MyArray</code>类，继承了<code>Array</code>构造函数，因此就可以从<code>MyArray</code>生成数组的实例。这意味着，ES6 可以自定义原生数据结构（比如<code>Array</code>、<code>String</code>等）的子类，这是 ES5 无法做到的。</p>
<p>上面这个例子也说明，<code>extends</code>关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> VersionedArray <span style="color:#000;font-weight:bold">extends</span> <span style="color:#0086b3">Array</span> {
</span></span><span style="display:flex;"><span>  constructor() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">super</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.history <span style="color:#000;font-weight:bold">=</span> [[]];
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  commit() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.history.push(<span style="color:#000;font-weight:bold">this</span>.slice());
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  revert() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.splice(<span style="color:#099">0</span>, <span style="color:#000;font-weight:bold">this</span>.length, ...<span style="color:#000;font-weight:bold">this</span>.history[<span style="color:#000;font-weight:bold">this</span>.history.length <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>]);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> x <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> VersionedArray();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x.push(<span style="color:#099">1</span>);
</span></span><span style="display:flex;"><span>x.push(<span style="color:#099">2</span>);
</span></span><span style="display:flex;"><span>x <span style="color:#998;font-style:italic">// [1, 2]
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>x.history <span style="color:#998;font-style:italic">// [[]]
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>x.commit();
</span></span><span style="display:flex;"><span>x.history <span style="color:#998;font-style:italic">// [[], [1, 2]]
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>x.push(<span style="color:#099">3</span>);
</span></span><span style="display:flex;"><span>x <span style="color:#998;font-style:italic">// [1, 2, 3]
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>x.history <span style="color:#998;font-style:italic">// [[], [1, 2]]
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>x.revert();
</span></span><span style="display:flex;"><span>x <span style="color:#998;font-style:italic">// [1, 2]
</span></span></span></code></pre></div><p>上面代码中，<code>VersionedArray</code>会通过<code>commit</code>方法，将自己的当前状态生成一个版本快照，存入<code>history</code>属性。<code>revert</code>方法用来将数组重置为最新一次保存的版本。除此之外，<code>VersionedArray</code>依然是一个普通数组，所有原生的数组方法都可以在它上面调用。</p>
<p>下面是一个自定义<code>Error</code>子类的例子，可以用来定制报错时的行为。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> ExtendableError <span style="color:#000;font-weight:bold">extends</span> <span style="color:#0086b3">Error</span> {
</span></span><span style="display:flex;"><span>  constructor(message) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">super</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.message <span style="color:#000;font-weight:bold">=</span> message;
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.stack <span style="color:#000;font-weight:bold">=</span> (<span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Error</span>()).stack;
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.name <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">this</span>.constructor.name;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> MyError <span style="color:#000;font-weight:bold">extends</span> ExtendableError {
</span></span><span style="display:flex;"><span>  constructor(m) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">super</span>(m);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> myerror <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> MyError(<span style="color:#d14">&#39;ll&#39;</span>);
</span></span><span style="display:flex;"><span>myerror.message <span style="color:#998;font-style:italic">// &#34;ll&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>myerror <span style="color:#000;font-weight:bold">instanceof</span> <span style="color:#0086b3">Error</span> <span style="color:#998;font-style:italic">// true
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>myerror.name <span style="color:#998;font-style:italic">// &#34;MyError&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>myerror.stack
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Error
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">//     at MyError.ExtendableError
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">//     ...
</span></span></span></code></pre></div><p>注意，继承<code>Object</code>的子类，有一个<a href="http://stackoverflow.com/questions/36203614/super-does-not-pass-arguments-when-instantiating-a-class-extended-from-object">行为差异</a>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> NewObj <span style="color:#000;font-weight:bold">extends</span> <span style="color:#0086b3">Object</span>{
</span></span><span style="display:flex;"><span>  constructor(){
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">super</span>(...arguments);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> o <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> NewObj({attr<span style="color:#000;font-weight:bold">:</span> <span style="color:#000;font-weight:bold">true</span>});
</span></span><span style="display:flex;"><span>o.attr <span style="color:#000;font-weight:bold">===</span> <span style="color:#000;font-weight:bold">true</span>  <span style="color:#998;font-style:italic">// false
</span></span></span></code></pre></div><p>上面代码中，<code>NewObj</code>继承了<code>Object</code>，但是无法通过<code>super</code>方法向父类<code>Object</code>传参。这是因为 ES6 改变了<code>Object</code>构造函数的行为，一旦发现<code>Object</code>方法不是通过<code>new Object()</code>这种形式调用，ES6 规定<code>Object</code>构造函数会忽略参数。</p>
<h2 id="mixin-模式的实现">Mixin 模式的实现</h2>
<p>Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> a <span style="color:#000;font-weight:bold">=</span> {
</span></span><span style="display:flex;"><span>  a<span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#39;a&#39;</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> b <span style="color:#000;font-weight:bold">=</span> {
</span></span><span style="display:flex;"><span>  b<span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#39;b&#39;</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> c <span style="color:#000;font-weight:bold">=</span> {...a, ...b}; <span style="color:#998;font-style:italic">// {a: &#39;a&#39;, b: &#39;b&#39;}
</span></span></span></code></pre></div><p>上面代码中，<code>c</code>对象是<code>a</code>对象和<code>b</code>对象的合成，具有两者的接口。</p>
<p>下面是一个更完备的实现，将多个类的接口“混入”（mix in）另一个类。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> mix(...mixins) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">class</span> Mix {
</span></span><span style="display:flex;"><span>    constructor() {
</span></span><span style="display:flex;"><span>      <span style="color:#000;font-weight:bold">for</span> (<span style="color:#000;font-weight:bold">let</span> mixin <span style="color:#000;font-weight:bold">of</span> mixins) {
</span></span><span style="display:flex;"><span>        copyProperties(<span style="color:#000;font-weight:bold">this</span>, <span style="color:#000;font-weight:bold">new</span> mixin()); <span style="color:#998;font-style:italic">// 拷贝实例属性
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">for</span> (<span style="color:#000;font-weight:bold">let</span> mixin <span style="color:#000;font-weight:bold">of</span> mixins) {
</span></span><span style="display:flex;"><span>    copyProperties(Mix, mixin); <span style="color:#998;font-style:italic">// 拷贝静态属性
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    copyProperties(Mix.prototype, mixin.prototype); <span style="color:#998;font-style:italic">// 拷贝原型属性
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> Mix;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> copyProperties(target, source) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">for</span> (<span style="color:#000;font-weight:bold">let</span> key <span style="color:#000;font-weight:bold">of</span> Reflect.ownKeys(source)) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> ( key <span style="color:#000;font-weight:bold">!==</span> <span style="color:#d14">&#39;constructor&#39;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#000;font-weight:bold">&amp;&amp;</span> key <span style="color:#000;font-weight:bold">!==</span> <span style="color:#d14">&#39;prototype&#39;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#000;font-weight:bold">&amp;&amp;</span> key <span style="color:#000;font-weight:bold">!==</span> <span style="color:#d14">&#39;name&#39;</span>
</span></span><span style="display:flex;"><span>    ) {
</span></span><span style="display:flex;"><span>      <span style="color:#000;font-weight:bold">let</span> desc <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">Object</span>.getOwnPropertyDescriptor(source, key);
</span></span><span style="display:flex;"><span>      <span style="color:#0086b3">Object</span>.defineProperty(target, key, desc);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码的<code>mix</code>函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> DistributedEdit <span style="color:#000;font-weight:bold">extends</span> mix(Loggable, Serializable) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div>
        </div>

        
<div class="post-archive">
    <ul class="post-copyright">
        <li><strong>Author: </strong><a rel="author" href="http://shansec.github.io">未来可期</a></li>
        <li style="word-break:break-all"><strong>Link: </strong><a href="http://shansec.github.io/post/es6/class%E7%BB%A7%E6%89%BF/">http://shansec.github.io/post/es6/class%E7%BB%A7%E6%89%BF/</a></li>
        <li><strong>License: </strong>This work is under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>. Kindly fulfill the requirements of the aforementioned License when adapting or creating a derivative of this work.</li>
    </ul>
</div>
<br/>



        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/post/es6/class%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">Class的基本语法</a></li>
        
        <li><a href="/post/es6/async%E5%87%BD%E6%95%B0/">Async函数</a></li>
        
        <li><a href="/post/es6/ArrayBuffer/">ArrayBuffer</a></li>
        
        <li><a href="/post/blog/JavaScript-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E5%AD%97/">JavaScript 中如何判断变量是否为数字</a></li>
        
        <li><a href="/post/blog/%E4%B8%83%E4%B8%AA-Vue-%E9%A1%B9%E7%9B%AE%E7%94%A8%E5%BE%97%E4%B8%8A%E7%9A%84-JavaScript-%E5%BA%93%E5%88%86%E4%BA%AB/">七个 Vue 项目用得上的 JavaScript 库分享</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='/tags/javaScript' target="_blank">javaScript</a></li>
                
                <li><a href='/tags/es6' target="_blank">es6</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "your github repo"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
    
    

</div>

                    <footer id="footer">
    <div>
        &copy; 2024 <a href="http://shansec.github.io">未来可期的博客 By 未来可期</a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>
<style type="text/css">
div.highlight {
    position: relative;
    margin: 1em 0px;
}

.copy-code {
    display: none;
    position: absolute;
    top: 4px;
    right: 4px;
    color: rgba(255, 255, 255, 0.8);
    background: rgba(78, 78, 78, 0.8);
    border-radius: var(--radius);
    padding: 0 5px;
    font: inherit;
    user-select: none;
    cursor: pointer;
    border: 0;
    --radius: 8px;
}

div.highlight:hover .copy-code,pre:hover .copy-code {
    display: block;
}

</style>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>


    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




    <script src='/js/douban.js'></script>

                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='http://shansec.github.io/search' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="http://shansec.github.io">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>

    <section class="widget">
        <h3 class="widget-title">Latest articles</h3>
<ul class="widget-list">
    
    <li>
        <a href="http://shansec.github.io/post/ts/Typescript-interface/" title="Typescript Interface" target="_blank">Typescript Interface</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/typescript-%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B/" title="Typescript 函数类型" target="_blank">Typescript 函数类型</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/typescript-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B/" title="Typescript 对象类型" target="_blank">Typescript 对象类型</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/typescript-%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B/" title="Typescript 数组类型" target="_blank">Typescript 数组类型</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/typescript-%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B/" title="Typescript 数组类型" target="_blank">Typescript 数组类型</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/typescript-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/" title="Typescript 类型系统" target="_blank">Typescript 类型系统</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/typescript-any%E7%B1%BB%E5%9E%8B%E5%92%8Cunknown%E7%B1%BB%E5%9E%8B%E5%92%8Cnever%E7%B1%BB%E5%9E%8B/" title="Typescript Any类型和unknown类型和never类型" target="_blank">Typescript Any类型和unknown类型和never类型</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/typescript-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/" title="Typescript 基本用法" target="_blank">Typescript 基本用法</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/es6/%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E6%89%A9%E5%B1%95/" title="运算符的扩展" target="_blank">运算符的扩展</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/es6/%E8%A3%85%E9%A5%B0%E5%99%A8/" title="装饰器" target="_blank">装饰器</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href='/categories/'>Categories</a></h3>
<ul class="widget-list">
    
    <li><a href="http://shansec.github.io/categories/go/">go (43)</a></li>
    
    <li><a href="http://shansec.github.io/categories/%E5%89%8D%E7%AB%AF/">前端 (60)</a></li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href='/tags/'>Tags</a></h3>
<div class="tagcloud">
    
    <a href="http://shansec.github.io/tags/CSS/">CSS</a>
    
    <a href="http://shansec.github.io/tags/HTTP/">HTTP</a>
    
    <a href="http://shansec.github.io/tags/javaScript/">javaScript</a>
    
    <a href="http://shansec.github.io/tags/CSS/">CSS</a>
    
    <a href="http://shansec.github.io/tags/docker/">docker</a>
    
    <a href="http://shansec.github.io/tags/es6/">es6</a>
    
    <a href="http://shansec.github.io/tags/go/">go</a>
    
    <a href="http://shansec.github.io/tags/go-%E5%9F%BA%E7%A1%80/">go 基础</a>
    
    <a href="http://shansec.github.io/tags/go-%E6%A0%87%E5%87%86%E5%BA%93/">go 标准库</a>
    
    <a href="http://shansec.github.io/tags/javaScript/">javaScript</a>
    
    <a href="http://shansec.github.io/tags/jwt/">jwt</a>
    
    <a href="http://shansec.github.io/tags/package/">package</a>
    
    <a href="http://shansec.github.io/tags/pinia/">pinia</a>
    
    <a href="http://shansec.github.io/tags/redis/">redis</a>
    
    <a href="http://shansec.github.io/tags/sql/">sql</a>
    
    <a href="http://shansec.github.io/tags/sqlx/">sqlx</a>
    
    <a href="http://shansec.github.io/tags/typescript/">typescript</a>
    
    <a href="http://shansec.github.io/tags/vue/">vue</a>
    
    <a href="http://shansec.github.io/tags/%E5%AD%98%E5%82%A8/">存储</a>
    
    <a href="http://shansec.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">微信小程序</a>
    
    <a href="http://shansec.github.io/tags/%E6%A0%87%E5%87%86%E5%BA%93/">标准库</a>
    
    <a href="http://shansec.github.io/tags/%E6%A1%86%E6%9E%B6/">框架</a>
    
    <a href="http://shansec.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/">计算机原理</a>
    
</div>
    </section>

    
<section class="widget">
    <h3 class="widget-title">Links</h3>
    <ul class="widget-list">
        
        <li>
            <a target="_blank" href="https://www.liwenzhou.com/" title="李文周的博客">李文周的博客</a>
        </li>
        
    </ul>
</section>


    <section class="widget">
        <h3 class="widget-title">Meta</h3>
        <ul class="widget-list">
            <li><a href="http://shansec.github.io/index.xml">RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>