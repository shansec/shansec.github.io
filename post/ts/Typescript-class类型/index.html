<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <meta name="referrer" content="no-referrer-when-downgrade">
    

    <title>Typescript Class类型 | 未来可期的博客</title>
    <meta property="og:title" content="Typescript Class类型 - 未来可期的博客">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2024-06-25T12:15:48&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2024-06-25T12:15:48&#43;08:00'>
        
    <meta name="Keywords" content="golang,go语言,go语言笔记,未来可期,博客,公众号,小程序">
    <meta name="description" content="Typescript Class类型">
        
    <meta name="author" content="未来可期">
    <meta property="og:url" content="http://shansec.github.io/post/ts/Typescript-class%E7%B1%BB%E5%9E%8B/">
    <link rel="shortcut icon" href='/favicon.ico'  type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
        <link rel="stylesheet" href='/css/douban.css'>
    
        <link rel="stylesheet" href='/css/other.css'>
    
</head>

<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="http://shansec.github.io">
                        未来可期的博客
                    </a>
                
                <p class="description">专注于Go语言(golang)、前端技术</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="http://shansec.github.io">Home</a>
                    
                    <a  href="http://shansec.github.io/archives/" title="归档">归档</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    <style type="text/css">
    .post-toc {
        position: fixed;
        width: 200px;
        margin-left: -210px;
        padding: 5px 10px;
        font-family: Athelas, STHeiti, Microsoft Yahei, serif;
        font-size: 12px;
        border: 1px solid rgba(0, 0, 0, .07);
        border-radius: 5px;
        background-color: rgba(255, 255, 255, 0.98);
        background-clip: padding-box;
        -webkit-box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        word-wrap: break-word;
        white-space: nowrap;
        -webkit-box-sizing: border-box;
        box-sizing: border-box;
        z-index: 999;
        cursor: pointer;
        max-height: 70%;
        overflow-y: auto;
        overflow-x: hidden;
    }

    .post-toc .post-toc-title {
        width: 100%;
        margin: 0 auto;
        font-size: 20px;
        font-weight: 400;
        text-transform: uppercase;
        text-align: center;
    }

    .post-toc .post-toc-content {
        font-size: 15px;
    }

    .post-toc .post-toc-content>nav>ul {
        margin: 10px 0;
    }

    .post-toc .post-toc-content ul {
        padding-left: 20px;
        list-style: square;
        margin: 0.5em;
        line-height: 1.8em;
    }

    .post-toc .post-toc-content ul ul {
        padding-left: 15px;
        display: none;
    }

    @media print,
    screen and (max-width:1057px) {
        .post-toc {
            display: none;
        }
    }
</style>
<div class="post-toc" style="position: absolute; top: 188px;">
    <h2 class="post-toc-title">Table of Contents</h2>
    <div class="post-toc-content">
        <nav id="TableOfContents">
  <ul>
    <li><a href="#简介">简介</a>
      <ul>
        <li><a href="#属性的类型">属性的类型</a></li>
        <li><a href="#readonly-修饰符">readonly 修饰符</a></li>
        <li><a href="#方法的类型">方法的类型</a></li>
        <li><a href="#存取器方法">存取器方法</a></li>
        <li><a href="#属性索引">属性索引</a></li>
      </ul>
    </li>
    <li><a href="#类的-interface-接口">类的 interface 接口</a>
      <ul>
        <li><a href="#implements-关键字">implements 关键字</a></li>
        <li><a href="#实现多个接口">实现多个接口</a></li>
        <li><a href="#类与接口的合并">类与接口的合并</a></li>
      </ul>
    </li>
    <li><a href="#class-类型">Class 类型</a>
      <ul>
        <li><a href="#实例类型">实例类型</a></li>
        <li><a href="#类的自身类型"><strong>类的自身类型</strong></a></li>
        <li><a href="#结构类型原则">结构类型原则</a></li>
      </ul>
    </li>
    <li><a href="#类的继承">类的继承</a></li>
    <li><a href="#可访问性修饰符">可访问性修饰符</a>
      <ul>
        <li><a href="#public">public</a></li>
        <li><a href="#private">private</a></li>
        <li><a href="#protected">protected</a></li>
        <li><a href="#实例属性的简写形式">实例属性的简写形式</a></li>
      </ul>
    </li>
    <li><a href="#静态成员">静态成员</a></li>
    <li><a href="#泛型类">泛型类</a></li>
    <li><a href="#抽象类抽象成员">抽象类，抽象成员</a></li>
    <li><a href="#this-问题">this 问题</a></li>
  </ul>
</nav>
    </div>
</div>
<script type="text/javascript">
    $(document).ready(function () {
        var postToc = $(".post-toc");
        if (postToc.length) {
            var leftPos = $("#main").offset().left;
            if (leftPos < 220) {
                postToc.css({ "width": leftPos - 10, "margin-left": (0 - leftPos) })
            }

            var t = postToc.offset().top - 20,
                a = {
                    start: {
                        position: "absolute",
                        top: t
                    },
                    process: {
                        position: "fixed",
                        top: 20
                    },
                };
            $(window).scroll(function () {
                var e = $(window).scrollTop();
                e < t ? postToc.css(a.start) : postToc.css(a.process)
            })
        }

        if ($("#TableOfContents").children().length < 1) {
            $(".post-toc").remove();
        }
    })
</script>
    <article class="post">
        <header>
            <h1 class="post-title">Typescript Class类型</h1>
        </header>
        
  <time datetime="2024-06-25T04:15:48Z" class="post-meta meta-date dt-published">
    2024-06-25
  </time>


<div class="post-meta meta-category">
  <span>&nbsp;|</span>
  
    <a href='/categories/%E5%89%8D%E7%AB%AF' target="_blank">前端</a>
  
</div>


        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">&nbsp;|
                <span id="busuanzi_value_page_pv"></span> <span>reads</span>
            </span>
        </div>
        
        
        <div class="post-content">
            <h2 id="简介">简介</h2>
<p>类（class）是面向对象编程的基本构件，封装了属性和方法，TypeScript 给予了全面支持。</p>
<h3 id="属性的类型">属性的类型</h3>
<p>类的属性可以在顶层声明，也可以在构造方法内部声明。</p>
<p>对于顶层声明的属性，可以在声明时同时给出类型。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Point {
</span></span><span style="display:flex;"><span>  x:<span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>  y:<span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面声明中，属性<code>x</code>和<code>y</code>的类型都是<code>number</code>。</p>
<p>如果不给出类型，TypeScript 会认为<code>x</code>和<code>y</code>的类型都是<code>any</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Point {
</span></span><span style="display:flex;"><span>  x;
</span></span><span style="display:flex;"><span>  y;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，<code>x</code>和<code>y</code>的类型都是<code>any</code>。</p>
<p>如果声明时给出初值，可以不写类型，TypeScript 会自行推断属性的类型。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Point {
</span></span><span style="display:flex;"><span>  x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>  y <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，属性<code>x</code>和<code>y</code>的类型都会被推断为 number。</p>
<p>TypeScript 有一个配置项<code>strictPropertyInitialization</code>，只要打开（默认是打开的），就会检查属性是否设置了初值，如果没有就报错。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 打开 strictPropertyInitialization
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">class</span> Point {
</span></span><span style="display:flex;"><span>  x: <span style="color:#458;font-weight:bold">number</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  y: <span style="color:#458;font-weight:bold">number</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>上面示例中，如果类的顶层属性不赋值，就会报错。如果不希望出现报错，可以使用非空断言。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Point {
</span></span><span style="display:flex;"><span>  x<span style="color:#000;font-weight:bold">!:</span> <span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>  y<span style="color:#000;font-weight:bold">!:</span> <span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，属性<code>x</code>和<code>y</code>没有初值，但是属性名后面添加了感叹号，表示这两个属性肯定不会为空，所以 TypeScript 就不报错了，详见《类型断言》一章。</p>
<h3 id="readonly-修饰符">readonly 修饰符</h3>
<p>属性名前面加上 readonly 修饰符，就表示该属性是只读的。实例对象不能修改这个属性。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">readonly</span> id <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;foo&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> a <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> A();
</span></span><span style="display:flex;"><span>a.id <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;bar&#39;</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，<code>id</code>属性前面有 readonly 修饰符，实例对象修改这个属性就会报错。</p>
<p>readonly 属性的初始值，可以写在顶层属性，也可以写在构造方法里面。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">readonly</span> id:<span style="color:#458;font-weight:bold">string</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">constructor</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.id <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;bar&#39;</span>; <span style="color:#998;font-style:italic">// 正确
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，构造方法内部设置只读属性的初值，这是可以的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">readonly</span> id:<span style="color:#458;font-weight:bold">string</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;foo&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">constructor</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.id <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;bar&#39;</span>; <span style="color:#998;font-style:italic">// 正确
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，构造方法修改只读属性的值也是可以的。或者说，如果两个地方都设置了只读属性的值，以构造方法为准。在其他方法修改只读属性都会报错。</p>
<h3 id="方法的类型">方法的类型</h3>
<p>类的方法就是普通函数，类型声明方式与函数一致。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Point {
</span></span><span style="display:flex;"><span>  x:<span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>  y:<span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">constructor</span>(x:<span style="color:#458;font-weight:bold">number</span>, y:<span style="color:#458;font-weight:bold">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.x <span style="color:#000;font-weight:bold">=</span> x;
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.y <span style="color:#000;font-weight:bold">=</span> y;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  add(point:<span style="color:#458;font-weight:bold">Point</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">new</span> Point(
</span></span><span style="display:flex;"><span>      <span style="color:#000;font-weight:bold">this</span>.x <span style="color:#000;font-weight:bold">+</span> point.x,
</span></span><span style="display:flex;"><span>      <span style="color:#000;font-weight:bold">this</span>.y <span style="color:#000;font-weight:bold">+</span> point.y
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，构造方法<code>constructor()</code>和普通方法<code>add()</code>都注明了参数类型，但是省略了返回值类型，因为 TypeScript 可以自己推断出来。</p>
<p>类的方法跟普通函数一样，可以使用参数默认值，以及函数重载。</p>
<p>下面是参数默认值的例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Point {
</span></span><span style="display:flex;"><span>  x: <span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>  y: <span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">constructor</span>(x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>, y <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.x <span style="color:#000;font-weight:bold">=</span> x;
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.y <span style="color:#000;font-weight:bold">=</span> y;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，如果新建实例时，不提供属性<code>x</code>和<code>y</code>的值，它们都等于默认值<code>0</code>。</p>
<p>下面是函数重载的例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Point {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">constructor</span>(x:<span style="color:#458;font-weight:bold">number</span>, y:<span style="color:#458;font-weight:bold">string</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">constructor</span>(s:<span style="color:#458;font-weight:bold">string</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">constructor</span>(xs:<span style="color:#458;font-weight:bold">number</span><span style="color:#000;font-weight:bold">|</span><span style="color:#458;font-weight:bold">string</span>, y?:<span style="color:#458;font-weight:bold">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，构造方法可以接受一个参数，也可以接受两个参数，采用函数重载进行类型声明。</p>
<p>另外，构造方法不能声明返回值类型，否则报错，因为它总是返回实例对象。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">constructor</span>()<span style="color:#000;font-weight:bold">:</span><span style="color:#458;font-weight:bold">object</span> { <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，构造方法声明了返回值类型<code>object</code>，导致报错。</p>
<h3 id="存取器方法">存取器方法</h3>
<p>存取器（accessor）是特殊的类方法，包括取值器（getter）和存值器（setter）两种方法。</p>
<p>它们用于读写某个属性，取值器用来读取属性，存值器用来写入属性。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> C {
</span></span><span style="display:flex;"><span>  _name <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;&#39;</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">get</span> name() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">this</span>._name;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">set</span> name(value) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>._name <span style="color:#000;font-weight:bold">=</span> value;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，<code>get name()</code>是取值器，其中<code>get</code>是关键词，<code>name</code>是属性名。外部读取<code>name</code>属性时，实例对象会自动调用这个方法，该方法的返回值就是<code>name</code>属性的值。</p>
<p><code>set name()</code>是存值器，其中<code>set</code>是关键词，<code>name</code>是属性名。外部写入<code>name</code>属性时，实例对象会自动调用这个方法，并将所赋的值作为函数参数传入。</p>
<p>TypeScript 对存取器有以下规则。</p>
<p>（1）如果某个属性只有<code>get</code>方法，没有<code>set</code>方法，那么该属性自动成为只读属性。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> C {
</span></span><span style="display:flex;"><span>  _name <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;foo&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">get</span> name() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">this</span>._name;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> c <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> C();
</span></span><span style="display:flex;"><span>c.name <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;bar&#39;</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，<code>name</code>属性没有<code>set</code>方法，对该属性赋值就会报错。</p>
<p>（2）TypeScript 5.1 版之前，<code>set</code>方法的参数类型，必须兼容<code>get</code>方法的返回值类型，否则报错。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// TypeScript 5.1 版之前
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">class</span> C {
</span></span><span style="display:flex;"><span>  _name <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;&#39;</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">get</span> name()<span style="color:#000;font-weight:bold">:</span><span style="color:#458;font-weight:bold">string</span> {  <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">this</span>._name;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">set</span> name(value:<span style="color:#458;font-weight:bold">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>._name <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">String</span>(value);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，<code>get</code>方法的返回值类型是字符串，与<code>set</code>方法的参数类型<code>number</code>不兼容，导致报错。改成下面这样，就不会报错。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> C {
</span></span><span style="display:flex;"><span>  _name <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;&#39;</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">get</span> name()<span style="color:#000;font-weight:bold">:</span><span style="color:#458;font-weight:bold">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">this</span>._name;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">set</span> name(value:<span style="color:#458;font-weight:bold">number</span><span style="color:#000;font-weight:bold">|</span><span style="color:#458;font-weight:bold">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>._name <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">String</span>(value);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，<code>set</code>方法的参数类型（<code>number|string</code>）兼容<code>get</code>方法的返回值类型（<code>string</code>），这是允许的。</p>
<p>TypeScript 5.1 版做出了<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html#unrelated-types-for-getters-and-setters">改变</a>，现在两者可以不兼容。</p>
<p>（3）<code>get</code>方法与<code>set</code>方法的可访问性必须一致，要么都为公开方法，要么都为私有方法。</p>
<h3 id="属性索引">属性索引</h3>
<p>类允许定义属性索引。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> MyClass {
</span></span><span style="display:flex;"><span>  [s:<span style="color:#458;font-weight:bold">string</span>]<span style="color:#000;font-weight:bold">:</span> <span style="color:#000;font-weight:bold">boolean</span> <span style="color:#000;font-weight:bold">|</span>
</span></span><span style="display:flex;"><span>    ((s:<span style="color:#458;font-weight:bold">string</span>) <span style="color:#000;font-weight:bold">=&gt;</span> <span style="color:#000;font-weight:bold">boolean</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">get</span>(s:<span style="color:#458;font-weight:bold">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">this</span>[s] <span style="color:#000;font-weight:bold">as</span> <span style="color:#000;font-weight:bold">boolean</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，<code>[s:string]</code>表示所有属性名类型为字符串的属性，它们的属性值要么是布尔值，要么是返回布尔值的函数。</p>
<p>注意，由于类的方法是一种特殊属性（属性值为函数的属性），所以属性索引的类型定义也涵盖了方法。如果一个对象同时定义了属性索引和方法，那么前者必须包含后者的类型。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> MyClass {
</span></span><span style="display:flex;"><span>  [s:<span style="color:#458;font-weight:bold">string</span>]<span style="color:#000;font-weight:bold">:</span> <span style="color:#000;font-weight:bold">boolean</span>;
</span></span><span style="display:flex;"><span>  f() { <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">true</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，属性索引的类型里面不包括方法，导致后面的方法<code>f()</code>定义直接报错。正确的写法是下面这样。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> MyClass {
</span></span><span style="display:flex;"><span>  [s:<span style="color:#458;font-weight:bold">string</span>]<span style="color:#000;font-weight:bold">:</span> <span style="color:#000;font-weight:bold">boolean</span> <span style="color:#000;font-weight:bold">|</span> (() <span style="color:#000;font-weight:bold">=&gt;</span> <span style="color:#000;font-weight:bold">boolean</span>);
</span></span><span style="display:flex;"><span>  f() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">true</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>属性存取器视同属性。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> MyClass {
</span></span><span style="display:flex;"><span>  [s:<span style="color:#458;font-weight:bold">string</span>]<span style="color:#000;font-weight:bold">:</span> <span style="color:#000;font-weight:bold">boolean</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">get</span> isInstance() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">true</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，属性<code>inInstance</code>的读取器虽然是一个函数方法，但是视同属性，所以属性索引虽然没有涉及方法类型，但是不会报错。</p>
<h2 id="类的-interface-接口">类的 interface 接口</h2>
<h3 id="implements-关键字">implements 关键字</h3>
<p>interface 接口或 type 别名，可以用对象的形式，为 class 指定一组检查条件。然后，类使用 implements 关键字，表示当前类满足这些外部类型条件的限制。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">interface</span> Country {
</span></span><span style="display:flex;"><span>  name:<span style="color:#458;font-weight:bold">string</span>;
</span></span><span style="display:flex;"><span>  capital:<span style="color:#458;font-weight:bold">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 或者
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">type</span> Country <span style="color:#000;font-weight:bold">=</span> {
</span></span><span style="display:flex;"><span>  name:<span style="color:#458;font-weight:bold">string</span>;
</span></span><span style="display:flex;"><span>  capital:<span style="color:#458;font-weight:bold">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> MyCountry <span style="color:#000;font-weight:bold">implements</span> Country {
</span></span><span style="display:flex;"><span>  name <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;&#39;</span>;
</span></span><span style="display:flex;"><span>  capital <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，<code>interface</code>或<code>type</code>都可以定义一个对象类型。类<code>MyCountry</code>使用<code>implements</code>关键字，表示该类的实例对象满足这个外部类型。</p>
<p>interface 只是指定检查条件，如果不满足这些条件就会报错。它并不能代替 class 自身的类型声明。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">interface</span> A {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">get</span>(name:<span style="color:#458;font-weight:bold">string</span>)<span style="color:#000;font-weight:bold">:</span> <span style="color:#000;font-weight:bold">boolean</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">implements</span> A {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">get</span>(s) { <span style="color:#998;font-style:italic">// s 的类型是 any
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">true</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，类<code>B</code>实现了接口<code>A</code>，但是后者并不能代替<code>B</code>的类型声明。因此，<code>B</code>的<code>get()</code>方法的参数<code>s</code>的类型是<code>any</code>，而不是<code>string</code>。<code>B</code>类依然需要声明参数<code>s</code>的类型。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">implements</span> A {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">get</span>(s:<span style="color:#458;font-weight:bold">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">true</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>下面是另一个例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">interface</span> A {
</span></span><span style="display:flex;"><span>  x: <span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>  y?: <span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">implements</span> A {
</span></span><span style="display:flex;"><span>  x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> b <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> B();
</span></span><span style="display:flex;"><span>b.y <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">10</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，接口<code>A</code>有一个可选属性<code>y</code>，类<code>B</code>没有声明这个属性，所以可以通过类型检查。但是，如果给<code>B</code>的实例对象的属性<code>y</code>赋值，就会报错。所以，<code>B</code>类还是需要声明可选属性<code>y</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">implements</span> A {
</span></span><span style="display:flex;"><span>  x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>  y?: <span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>同理，类可以定义接口没有声明的方法和属性。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">interface</span> Point {
</span></span><span style="display:flex;"><span>  x: <span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>  y: <span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> MyPoint <span style="color:#000;font-weight:bold">implements</span> Point {
</span></span><span style="display:flex;"><span>  x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>  y <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>  z:<span style="color:#458;font-weight:bold">number</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，<code>MyPoint</code>类实现了<code>Point</code>接口，但是内部还定义了一个额外的属性<code>z</code>，这是允许的，表示除了满足接口给出的条件，类还有额外的条件。</p>
<p><code>implements</code>关键字后面，不仅可以是接口，也可以是另一个类。这时，后面的类将被当作接口。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Car {
</span></span><span style="display:flex;"><span>  id:<span style="color:#458;font-weight:bold">number</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>  move()<span style="color:#000;font-weight:bold">:</span><span style="color:#000;font-weight:bold">void</span> {};
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> MyCar <span style="color:#000;font-weight:bold">implements</span> Car {
</span></span><span style="display:flex;"><span>  id <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">2</span>; <span style="color:#998;font-style:italic">// 不可省略
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  move()<span style="color:#000;font-weight:bold">:</span><span style="color:#000;font-weight:bold">void</span> {};   <span style="color:#998;font-style:italic">// 不可省略
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>上面示例中，<code>implements</code>后面是类<code>Car</code>，这时 TypeScript 就把<code>Car</code>视为一个接口，要求<code>MyCar</code>实现<code>Car</code>里面的每一个属性和方法，否则就会报错。所以，这时不能因为<code>Car</code>类已经实现过一次，而在<code>MyCar</code>类省略属性或方法。</p>
<p>注意，interface 描述的是类的对外接口，也就是实例的公开属性和公开方法，不能定义私有的属性和方法。这是因为 TypeScript 设计者认为，私有属性是类的内部实现，接口作为模板，不应该涉及类的内部代码写法。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">interface</span> Foo {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">private</span> member<span style="color:#000;font-weight:bold">:</span>{}; <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>上面示例中，接口<code>Foo</code>有一个私有属性，结果就报错了。</p>
<h3 id="实现多个接口">实现多个接口</h3>
<p>类可以实现多个接口（其实是接受多重限制），每个接口之间使用逗号分隔。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Car <span style="color:#000;font-weight:bold">implements</span> MotorVehicle, Flyable, Swimmable {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>上面示例中，<code>Car</code>类同时实现了<code>MotorVehicle</code>、<code>Flyable</code>、<code>Swimmable</code>三个接口。这意味着，它必须部署这三个接口声明的所有属性和方法，满足它们的所有条件。</p>
<p>但是，同时实现多个接口并不是一个好的写法，容易使得代码难以管理，可以使用两种方法替代。</p>
<p>第一种方法是类的继承。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Car <span style="color:#000;font-weight:bold">implements</span> MotorVehicle {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> SecretCar <span style="color:#000;font-weight:bold">extends</span> Car <span style="color:#000;font-weight:bold">implements</span> Flyable, Swimmable {
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，<code>Car</code>类实现了<code>MotorVehicle</code>，而<code>SecretCar</code>类继承了<code>Car</code>类，然后再实现<code>Flyable</code>和<code>Swimmable</code>两个接口，相当于<code>SecretCar</code>类同时实现了三个接口。</p>
<p>第二种方法是接口的继承。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">interface</span> A {
</span></span><span style="display:flex;"><span>  a:<span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">interface</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>  b:<span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，接口<code>B</code>继承了接口<code>A</code>，类只要实现接口<code>B</code>，就相当于实现<code>A</code>和<code>B</code>两个接口。</p>
<p>前一个例子可以用接口继承改写。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">interface</span> MotorVehicle {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">interface</span> Flyable {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">interface</span> Swimmable {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">interface</span> SuperCar <span style="color:#000;font-weight:bold">extends</span> MotoVehicle,Flyable, Swimmable {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> SecretCar <span style="color:#000;font-weight:bold">implements</span> SuperCar {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>上面示例中，类<code>SecretCar</code>通过<code>SuperCar</code>接口，就间接实现了多个接口。</p>
<p>注意，发生多重实现时（即一个接口同时实现多个接口），不同接口不能有互相冲突的属性。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">interface</span> Flyable {
</span></span><span style="display:flex;"><span>  foo:<span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">interface</span> Swimmable {
</span></span><span style="display:flex;"><span>  foo:<span style="color:#458;font-weight:bold">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，属性<code>foo</code>在两个接口里面的类型不同，如果同时实现这两个接口，就会报错。</p>
<h3 id="类与接口的合并">类与接口的合并</h3>
<p>TypeScript 不允许两个同名的类，但是如果一个类和一个接口同名，那么接口会被合并进类。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  x:<span style="color:#458;font-weight:bold">number</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">interface</span> A {
</span></span><span style="display:flex;"><span>  y:<span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> a <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> A();
</span></span><span style="display:flex;"><span>a.y <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">10</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>a.x <span style="color:#998;font-style:italic">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>a.y <span style="color:#998;font-style:italic">// 10
</span></span></span></code></pre></div><p>上面示例中，类<code>A</code>与接口<code>A</code>同名，后者会被合并进前者的类型定义。</p>
<p>注意，合并进类的非空属性（上例的<code>y</code>），如果在赋值之前读取，会返回<code>undefined</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  x:<span style="color:#458;font-weight:bold">number</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">interface</span> A {
</span></span><span style="display:flex;"><span>  y:<span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> a <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> A();
</span></span><span style="display:flex;"><span>a.y <span style="color:#998;font-style:italic">// undefined
</span></span></span></code></pre></div><p>上面示例中，根据类型定义，<code>y</code>应该是一个非空属性。但是合并后，<code>y</code>有可能是<code>undefined</code>。</p>
<h2 id="class-类型">Class 类型</h2>
<h3 id="实例类型">实例类型</h3>
<p>TypeScript 的类本身就是一种类型，但是它代表该类的实例类型，而不是 class 的自身类型。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Color {
</span></span><span style="display:flex;"><span>  name:<span style="color:#458;font-weight:bold">string</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">constructor</span>(name:<span style="color:#458;font-weight:bold">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.name <span style="color:#000;font-weight:bold">=</span> name;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> green:<span style="color:#458;font-weight:bold">Color</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> Color(<span style="color:#d14">&#39;green&#39;</span>);
</span></span></code></pre></div><p>上面示例中，定义了一个类<code>Color</code>。它的类名就代表一种类型，实例对象<code>green</code>就属于该类型。</p>
<p>对于引用实例对象的变量来说，既可以声明类型为 Class，也可以声明类型为 Interface，因为两者都代表实例对象的类型。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">interface</span> MotorVehicle {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Car <span style="color:#000;font-weight:bold">implements</span> MotorVehicle {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 写法一
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> c1:<span style="color:#458;font-weight:bold">Car</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> Car();
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 写法二
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> c2:<span style="color:#458;font-weight:bold">MotorVehicle</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> Car();
</span></span></code></pre></div><p>上面示例中，变量的类型可以写成类<code>Car</code>，也可以写成接口<code>MotorVehicle</code>。它们的区别是，如果类<code>Car</code>有接口<code>MotoVehicle</code>没有的属性和方法，那么只有变量<code>c1</code>可以调用这些属性和方法。</p>
<p>作为类型使用时，类名只能表示实例的类型，不能表示类的自身类型。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Point {
</span></span><span style="display:flex;"><span>  x:<span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>  y:<span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">constructor</span>(x:<span style="color:#458;font-weight:bold">number</span>, y:<span style="color:#458;font-weight:bold">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.x <span style="color:#000;font-weight:bold">=</span> x;
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.y <span style="color:#000;font-weight:bold">=</span> y;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 错误
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">function</span> createPoint(
</span></span><span style="display:flex;"><span>  PointClass:<span style="color:#458;font-weight:bold">Point</span>,
</span></span><span style="display:flex;"><span>  x: <span style="color:#458;font-weight:bold">number</span>,
</span></span><span style="display:flex;"><span>  y: <span style="color:#458;font-weight:bold">number</span>
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">new</span> PointClass(x, y);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，函数<code>createPoint()</code>的第一个参数<code>PointClass</code>，需要传入 Point 这个类，但是如果把参数的类型写成<code>Point</code>就会报错，因为<code>Point</code>描述的是实例类型，而不是 Class 的自身类型。</p>
<p><strong>由于类名作为类型使用，实际上代表一个对象，因此可以把类看作为对象类型起名。事实上，TypeScript 有三种方法可以为对象类型起名：type、interface 和 class。</strong></p>
<h3 id="类的自身类型"><strong>类的自身类型</strong></h3>
<p>要获得一个类的自身类型，一个简便的方法就是使用 typeof 运算符。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> createPoint(
</span></span><span style="display:flex;"><span>  PointClass:<span style="color:#458;font-weight:bold">typeof</span> Point,
</span></span><span style="display:flex;"><span>  x:<span style="color:#458;font-weight:bold">number</span>,
</span></span><span style="display:flex;"><span>  y:<span style="color:#458;font-weight:bold">number</span>
</span></span><span style="display:flex;"><span>)<span style="color:#000;font-weight:bold">:</span>Point {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">new</span> PointClass(x, y);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，<code>createPoint()</code>的第一个参数<code>PointClass</code>是<code>Point</code>类自身，要声明这个参数的类型，简便的方法就是使用<code>typeof Point</code>。因为<code>Point</code>类是一个值，<code>typeof Point</code>返回这个值的类型。注意，<code>createPoint()</code>的返回值类型是<code>Point</code>，代表实例类型。</p>
<p>JavaScript 语言中，类只是构造函数的一种语法糖，本质上是构造函数的另一种写法。所以，类的自身类型可以写成构造函数的形式。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> createPoint(
</span></span><span style="display:flex;"><span>  PointClass: <span style="color:#458;font-weight:bold">new</span> (x:<span style="color:#458;font-weight:bold">number</span>, y:<span style="color:#458;font-weight:bold">number</span>) <span style="color:#000;font-weight:bold">=&gt;</span> Point,
</span></span><span style="display:flex;"><span>  x: <span style="color:#458;font-weight:bold">number</span>,
</span></span><span style="display:flex;"><span>  y: <span style="color:#458;font-weight:bold">number</span>
</span></span><span style="display:flex;"><span>)<span style="color:#000;font-weight:bold">:</span>Point {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">new</span> PointClass(x, y);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，参数<code>PointClass</code>的类型写成了一个构造函数，这时就可以把<code>Point</code>类传入。</p>
<p>构造函数也可以写成对象形式，所以参数<code>PointClass</code>的类型还有另一种写法。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> createPoint(
</span></span><span style="display:flex;"><span>  PointClass<span style="color:#000;font-weight:bold">:</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">new</span> (x:<span style="color:#458;font-weight:bold">number</span>, y:<span style="color:#458;font-weight:bold">number</span>)<span style="color:#000;font-weight:bold">:</span> Point
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>  x: <span style="color:#458;font-weight:bold">number</span>,
</span></span><span style="display:flex;"><span>  y: <span style="color:#458;font-weight:bold">number</span>
</span></span><span style="display:flex;"><span>)<span style="color:#000;font-weight:bold">:</span>Point {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">new</span> PointClass(x, y);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>根据上面的写法，可以把构造函数提取出来，单独定义一个接口（interface），这样可以大大提高代码的通用性。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">interface</span> PointConstructor {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">new</span>(x:<span style="color:#458;font-weight:bold">number</span>, y:<span style="color:#458;font-weight:bold">number</span>)<span style="color:#000;font-weight:bold">:</span>Point;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> createPoint(
</span></span><span style="display:flex;"><span>  PointClass: <span style="color:#458;font-weight:bold">PointConstructor</span>,
</span></span><span style="display:flex;"><span>  x: <span style="color:#458;font-weight:bold">number</span>,
</span></span><span style="display:flex;"><span>  y: <span style="color:#458;font-weight:bold">number</span>
</span></span><span style="display:flex;"><span>)<span style="color:#000;font-weight:bold">:</span>Point {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">new</span> PointClass(x, y);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>总结一下，类的自身类型就是一个构造函数，可以单独定义一个接口来表示。</p>
<h3 id="结构类型原则">结构类型原则</h3>
<p>Class 也遵循“结构类型原则”。一个对象只要满足 Class 的实例结构，就跟该 Class 属于同一个类型。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Foo {
</span></span><span style="display:flex;"><span>  id<span style="color:#000;font-weight:bold">!:</span><span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> fn(arg:<span style="color:#458;font-weight:bold">Foo</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> bar <span style="color:#000;font-weight:bold">=</span> {
</span></span><span style="display:flex;"><span>  id: <span style="color:#458;font-weight:bold">10</span>,
</span></span><span style="display:flex;"><span>  amount: <span style="color:#458;font-weight:bold">100</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>fn(bar); <span style="color:#998;font-style:italic">// 正确
</span></span></span></code></pre></div><p>上面示例中，对象<code>bar</code>满足类<code>Foo</code>的实例结构，只是多了一个属性<code>amount</code>。所以，它可以当作参数，传入函数<code>fn()</code>。</p>
<p><strong>如果两个类的实例结构相同，那么这两个类就是兼容的，可以用在对方的使用场合。</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Person {
</span></span><span style="display:flex;"><span>  name: <span style="color:#458;font-weight:bold">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Customer {
</span></span><span style="display:flex;"><span>  name: <span style="color:#458;font-weight:bold">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 正确
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> cust:<span style="color:#458;font-weight:bold">Customer</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> Person();
</span></span></code></pre></div><p>上面示例中，<code>Person</code>和<code>Customer</code>是两个结构相同的类，TypeScript 将它们视为相同类型，因此<code>Person</code>可以用在类型为<code>Customer</code>的场合。</p>
<p>现在修改一下代码，<code>Person</code>类添加一个属性。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Person {
</span></span><span style="display:flex;"><span>  name: <span style="color:#458;font-weight:bold">string</span>;
</span></span><span style="display:flex;"><span>  age: <span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Customer {
</span></span><span style="display:flex;"><span>  name: <span style="color:#458;font-weight:bold">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 正确
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> cust:<span style="color:#458;font-weight:bold">Customer</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> Person();
</span></span></code></pre></div><p>上面示例中，<code>Person</code>类添加了一个属性<code>age</code>，跟<code>Customer</code>类的结构不再相同。但是这种情况下，TypeScript 依然认为，<code>Person</code>属于<code>Customer</code>类型。</p>
<p>这是因为根据“结构类型原则”，只要<code>Person</code>类具有<code>name</code>属性，就满足<code>Customer</code>类型的实例结构，所以可以代替它。反过来就不行，如果<code>Customer</code>类多出一个属性，就会报错。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Person {
</span></span><span style="display:flex;"><span>  name: <span style="color:#458;font-weight:bold">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Customer {
</span></span><span style="display:flex;"><span>  name: <span style="color:#458;font-weight:bold">string</span>;
</span></span><span style="display:flex;"><span>  age: <span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> cust:<span style="color:#458;font-weight:bold">Customer</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> Person();
</span></span></code></pre></div><p>上面示例中，<code>Person</code>类比<code>Customer</code>类少一个属性<code>age</code>，它就不满足<code>Customer</code>类型的实例结构，就报错了。因为在使用<code>Customer</code>类型的情况下，可能会用到它的<code>age</code>属性，而<code>Person</code>类就没有这个属性。</p>
<p>总之，只要 A 类具有 B 类的结构，哪怕还有额外的属性和方法，TypeScript 也认为 A 兼容 B 的类型。</p>
<p>不仅是类，如果某个对象跟某个 class 的实例结构相同，TypeScript 也认为两者的类型相同。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Person {
</span></span><span style="display:flex;"><span>  name: <span style="color:#458;font-weight:bold">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> obj <span style="color:#000;font-weight:bold">=</span> { name<span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#39;John&#39;</span> };
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> p:<span style="color:#458;font-weight:bold">Person</span> <span style="color:#000;font-weight:bold">=</span> obj; <span style="color:#998;font-style:italic">// 正确
</span></span></span></code></pre></div><p>上面示例中，对象<code>obj</code>并不是<code>Person</code>的实例，但是赋值给变量<code>p</code>不会报错，TypeScript 认为<code>obj</code>也属于<code>Person</code>类型，因为它们的属性相同。</p>
<p>由于这种情况，运算符<code>instanceof</code>不适用于判断某个对象是否跟某个 class 属于同一类型。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span>obj <span style="color:#000;font-weight:bold">instanceof</span> Person <span style="color:#998;font-style:italic">// false
</span></span></span></code></pre></div><p>上面示例中，运算符<code>instanceof</code>确认变量<code>obj</code>不是 Person 的实例，但是两者的类型是相同的。</p>
<p>空类不包含任何成员，任何其他类都可以看作与空类结构相同。因此，凡是类型为空类的地方，所有类（包括对象）都可以使用。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Empty {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> fn(x:<span style="color:#458;font-weight:bold">Empty</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>fn({});
</span></span><span style="display:flex;"><span>fn(<span style="color:#0086b3">window</span>);
</span></span><span style="display:flex;"><span>fn(fn);
</span></span></code></pre></div><p>上面示例中，函数<code>fn()</code>的参数是一个空类，这意味着任何对象都可以用作<code>fn()</code>的参数。</p>
<p><strong>注意，确定两个类的兼容关系时，只检查实例成员，不考虑静态成员和构造方法。</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Point {
</span></span><span style="display:flex;"><span>  x: <span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>  y: <span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">static</span> t: <span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">constructor</span>(x:<span style="color:#458;font-weight:bold">number</span>) {}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Position {
</span></span><span style="display:flex;"><span>  x: <span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>  y: <span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>  z: <span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">constructor</span>(x:<span style="color:#458;font-weight:bold">string</span>) {}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> point:<span style="color:#458;font-weight:bold">Point</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> Position(<span style="color:#d14">&#39;&#39;</span>);
</span></span></code></pre></div><p>上面示例中，<code>Point</code>与<code>Position</code>的静态属性和构造方法都不一样，但因为<code>Point</code>的实例成员与<code>Position</code>相同，所以<code>Position</code>兼容<code>Point</code>。</p>
<p>如果类中存在私有成员（private）或保护成员（protected），那么确定兼容关系时，TypeScript 要求私有成员和保护成员来自同一个类，这意味着两个类需要存在继承关系。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 情况一
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">private</span> name <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> a:<span style="color:#458;font-weight:bold">A</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> B();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 情况二
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">protected</span> name <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">protected</span> name <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;b&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> a:<span style="color:#458;font-weight:bold">A</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> B();
</span></span></code></pre></div><p>上面示例中，<code>A</code>和<code>B</code>都有私有成员（或保护成员）<code>name</code>，这时只有在<code>B</code>继承<code>A</code>的情况下（<code>class B extends A</code>），<code>B</code>才兼容<code>A</code>。</p>
<h2 id="类的继承">类的继承</h2>
<p>类（这里又称“子类”）可以使用 extends 关键字继承另一个类（这里又称“基类”）的所有属性和方法。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  greet() {
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#d14">&#39;Hello, world!&#39;</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> b <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> B();
</span></span><span style="display:flex;"><span>b.greet() <span style="color:#998;font-style:italic">// &#34;Hello, world!&#34;
</span></span></span></code></pre></div><p>上面示例中，子类<code>B</code>继承了基类<code>A</code>，因此就拥有了<code>greet()</code>方法，不需要再次在类的内部定义这个方法了。</p>
<p>根据结构类型原则，子类也可以用于类型为基类的场合。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> a:<span style="color:#458;font-weight:bold">A</span> <span style="color:#000;font-weight:bold">=</span> b;
</span></span><span style="display:flex;"><span>a.greet()
</span></span></code></pre></div><p>上面示例中，变量<code>a</code>的类型是基类，但是可以赋值为子类的实例。</p>
<p>子类可以覆盖基类的同名方法。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>  greet(name?: <span style="color:#458;font-weight:bold">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> (name <span style="color:#000;font-weight:bold">===</span> <span style="color:#000;font-weight:bold">undefined</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#000;font-weight:bold">super</span>.greet();
</span></span><span style="display:flex;"><span>    } <span style="color:#000;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>      console.log(<span style="color:#d14">`Hello, </span><span style="color:#d14">${</span>name<span style="color:#d14">}</span><span style="color:#d14">`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，子类<code>B</code>定义了一个方法<code>greet()</code>，覆盖了基类<code>A</code>的同名方法。其中，参数<code>name</code>省略时，就调用基类<code>A</code>的<code>greet()</code>方法，这里可以写成<code>super.greet()</code>，使用<code>super</code>关键字指代基类是常见做法。</p>
<p>但是，子类的同名方法不能与基类的类型定义相冲突。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  greet() {
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#d14">&#39;Hello, world!&#39;</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  greet(name:<span style="color:#458;font-weight:bold">string</span>) {
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#d14">`Hello, </span><span style="color:#d14">${</span>name<span style="color:#d14">}</span><span style="color:#d14">`</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，子类<code>B</code>的<code>greet()</code>有一个<code>name</code>参数，跟基类<code>A</code>的<code>greet()</code>定义不兼容，因此就报错了。</p>
<p>如果基类包括保护成员（<code>protected</code>修饰符），子类可以将该成员的可访问性设置为公开（<code>public</code>修饰符），也可以保持保护成员不变，但是不能改用私有成员（<code>private</code>修饰符），详见后文。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">protected</span> x: <span style="color:#458;font-weight:bold">string</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;&#39;</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">protected</span> y: <span style="color:#458;font-weight:bold">string</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;&#39;</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">protected</span> z: <span style="color:#458;font-weight:bold">string</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// 正确
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  <span style="color:#000;font-weight:bold">public</span> x:<span style="color:#458;font-weight:bold">string</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// 正确
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  <span style="color:#000;font-weight:bold">protected</span> y:<span style="color:#458;font-weight:bold">string</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  <span style="color:#000;font-weight:bold">private</span> z: <span style="color:#458;font-weight:bold">string</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，子类<code>B</code>将基类<code>A</code>的受保护成员改成私有成员，就会报错。</p>
<p>注意，<code>extends</code>关键字后面不一定是类名，可以是一个表达式，只要它的类型是构造函数就可以了。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 例一
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">class</span> MyArray <span style="color:#000;font-weight:bold">extends</span> <span style="color:#0086b3">Array</span>&lt;<span style="color:#000080">number</span>&gt; {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 例二
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">class</span> MyError <span style="color:#000;font-weight:bold">extends</span> <span style="color:#0086b3">Error</span> {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 例三
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  greeting() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#d14">&#39;Hello from A&#39;</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B {
</span></span><span style="display:flex;"><span>  greeting() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#d14">&#39;Hello from B&#39;</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">interface</span> Greeter {
</span></span><span style="display:flex;"><span>  greeting()<span style="color:#000;font-weight:bold">:</span> <span style="color:#458;font-weight:bold">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">interface</span> GreeterConstructor {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">new</span> ()<span style="color:#000;font-weight:bold">:</span> Greeter;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> getGreeterBase()<span style="color:#000;font-weight:bold">:</span>GreeterConstructor {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">Math</span>.random() <span style="color:#000;font-weight:bold">&gt;=</span> <span style="color:#099">0.5</span> <span style="color:#000;font-weight:bold">?</span> A : <span style="color:#458;font-weight:bold">B</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Test <span style="color:#000;font-weight:bold">extends</span> getGreeterBase() {
</span></span><span style="display:flex;"><span>  sayHello() {
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#000;font-weight:bold">this</span>.greeting());
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，例一和例二的<code>extends</code>关键字后面都是构造函数，例三的<code>extends</code>关键字后面是一个表达式，执行后得到的也是一个构造函数。</p>
<p>对于那些只设置了类型、没有初值的顶层属性，有一个细节需要注意。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">interface</span> Animal {
</span></span><span style="display:flex;"><span>  animalStuff: <span style="color:#458;font-weight:bold">any</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">interface</span> Dog <span style="color:#000;font-weight:bold">extends</span> Animal {
</span></span><span style="display:flex;"><span>  dogStuff: <span style="color:#458;font-weight:bold">any</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> AnimalHouse {
</span></span><span style="display:flex;"><span>  resident: <span style="color:#458;font-weight:bold">Animal</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">constructor</span>(animal:<span style="color:#458;font-weight:bold">Animal</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.resident <span style="color:#000;font-weight:bold">=</span> animal;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> DogHouse <span style="color:#000;font-weight:bold">extends</span> AnimalHouse {
</span></span><span style="display:flex;"><span>  resident: <span style="color:#458;font-weight:bold">Dog</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">constructor</span>(dog:<span style="color:#458;font-weight:bold">Dog</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">super</span>(dog);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，类<code>DogHouse</code>的顶层成员<code>resident</code>只设置了类型（<code>Dog</code>），没有设置初值。这段代码在不同的编译设置下，编译结果不一样。</p>
<p>如果编译设置的<code>target</code>设成大于等于<code>ES2022</code>，或者<code>useDefineForClassFields</code>设成<code>true</code>，那么下面代码的执行结果是不一样的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> dog <span style="color:#000;font-weight:bold">=</span> {
</span></span><span style="display:flex;"><span>  animalStuff<span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#39;animal&#39;</span>,
</span></span><span style="display:flex;"><span>  dogStuff<span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#39;dog&#39;</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> dogHouse <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> DogHouse(dog);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>console.log(dogHouse.resident) <span style="color:#998;font-style:italic">// undefined
</span></span></span></code></pre></div><p>上面示例中，<code>DogHouse</code>实例的属性<code>resident</code>输出的是<code>undefined</code>，而不是预料的<code>dog</code>。原因在于 ES2022 标准的 Class Fields 部分，与早期的 TypeScript 实现不一致，导致子类的那些只设置类型、没有设置初值的顶层成员在基类中被赋值后，会在子类被重置为<code>undefined</code>，详细的解释参见《tsconfig.json》一章，以及官方 3.7 版本的<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#the-usedefineforclassfields-flag-and-the-declare-property-modifier">发布说明</a>。</p>
<p>解决方法就是使用<code>declare</code>命令，去声明顶层成员的类型，告诉 TypeScript 这些成员的赋值由基类实现。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> DogHouse <span style="color:#000;font-weight:bold">extends</span> AnimalHouse {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">declare</span> resident: <span style="color:#458;font-weight:bold">Dog</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">constructor</span>(dog:<span style="color:#458;font-weight:bold">Dog</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">super</span>(dog);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，<code>resident</code>属性的类型声明前面用了<code>declare</code>命令，这样就能确保在编译目标大于等于<code>ES2022</code>时（或者打开<code>useDefineForClassFields</code>时），代码行为正确。</p>
<h2 id="可访问性修饰符">可访问性修饰符</h2>
<p>类的内部成员的外部可访问性，由三个可访问性修饰符（access modifiers）控制：<code>public</code>、<code>private</code>和<code>protected</code>。</p>
<p>这三个修饰符的位置，都写在属性或方法的最前面。</p>
<h3 id="public">public</h3>
<p><code>public</code>修饰符表示这是公开成员，外部可以自由访问。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Greeter {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">public</span> greet() {
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#d14">&#34;hi!&#34;</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> g <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> Greeter();
</span></span><span style="display:flex;"><span>g.greet();
</span></span></code></pre></div><p>上面示例中，<code>greet()</code>方法前面的<code>public</code>修饰符，表示该方法可以在类的外部调用，即外部实例可以调用。</p>
<p><code>public</code>修饰符是默认修饰符，如果省略不写，实际上就带有该修饰符。因此，类的属性和方法默认都是外部可访问的。</p>
<p>正常情况下，除非为了醒目和代码可读性，<code>public</code>都是省略不写的。</p>
<h3 id="private">private</h3>
<p><code>private</code>修饰符表示私有成员，只能用在当前类的内部，类的实例和子类都不能使用该成员。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">private</span> x:<span style="color:#458;font-weight:bold">number</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> a <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> A();
</span></span><span style="display:flex;"><span>a.x <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>  showX() {
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#000;font-weight:bold">this</span>.x); <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，属性<code>x</code>前面有<code>private</code>修饰符，表示这是私有成员。因此，实例对象和子类使用该成员，都会报错。</p>
<p>注意，子类不能定义父类私有成员的同名成员。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">private</span> x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>  x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>上面示例中，<code>A</code>类有一个私有属性<code>x</code>，子类<code>B</code>就不能定义自己的属性<code>x</code>了。</p>
<p>如果在类的内部，当前类的实例可以获取私有成员。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">private</span> x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">10</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  f(obj:<span style="color:#458;font-weight:bold">A</span>) {
</span></span><span style="display:flex;"><span>    console.log(obj.x);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> a <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> A();
</span></span><span style="display:flex;"><span>a.f(a) <span style="color:#998;font-style:italic">// 10
</span></span></span></code></pre></div><p>上面示例中，在类<code>A</code>内部，<code>A</code>的实例对象可以获取私有成员<code>x</code>。</p>
<p>严格地说，<code>private</code>定义的私有成员，并不是真正意义的私有成员。一方面，编译成 JavaScript 后，<code>private</code>关键字就被剥离了，这时外部访问该成员就不会报错。另一方面，由于前一个原因，TypeScript 对于访问<code>private</code>成员没有严格禁止，使用方括号写法（<code>[]</code>）或者<code>in</code>运算符，实例对象就能访问该成员。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">private</span> x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> a <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> A();
</span></span><span style="display:flex;"><span>a[<span style="color:#d14">&#39;x&#39;</span>] <span style="color:#998;font-style:italic">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">if</span> (<span style="color:#d14">&#39;x&#39;</span> <span style="color:#000;font-weight:bold">in</span> a) { <span style="color:#998;font-style:italic">// 正确
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>上面示例中，<code>A</code>类的属性<code>x</code>是私有属性，但是实例使用方括号，就可以读取这个属性，或者使用<code>in</code>运算符检查这个属性是否存在，都可以正确执行。</p>
<p><strong>由于private存在这些问题，加上它是 ES2022 标准发布前出台的，而 ES2022 引入了自己的私有成员写法#propName。因此建议不使用private，改用 ES2022 的写法，获得真正意义的私有成员。</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  <span style="color:#a61717;background-color:#e3d2d2">#</span>x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> a <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> A();
</span></span><span style="display:flex;"><span>a[<span style="color:#d14">&#39;x&#39;</span>] <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，采用了 ES2022 的私有成员写法（属性名前加<code>#</code>），TypeScript 就正确识别了实例对象没有属性<code>x</code>，从而报错。</p>
<p>构造方法也可以是私有的，这就直接防止了使用<code>new</code>命令生成实例对象，只能在类的内部创建实例对象。</p>
<p>这时一般会有一个静态方法，充当工厂函数，强制所有实例都通过该方法生成。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Singleton {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">private</span> <span style="color:#000;font-weight:bold">static</span> instance?: <span style="color:#458;font-weight:bold">Singleton</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">private</span> <span style="color:#000;font-weight:bold">constructor</span>() {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">static</span> getInstance() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>Singleton.instance) {
</span></span><span style="display:flex;"><span>      Singleton.instance <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> Singleton();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> Singleton.instance;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> s <span style="color:#000;font-weight:bold">=</span> Singleton.getInstance();
</span></span></code></pre></div><p>上面示例使用私有构造方法，实现了单例模式。想要获得 Singleton 的实例，不能使用<code>new</code>命令，只能使用<code>getInstance()</code>方法。</p>
<h3 id="protected">protected</h3>
<p><code>protected</code>修饰符表示该成员是保护成员，只能在类的内部使用该成员，实例无法使用该成员，但是子类内部可以使用。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">protected</span> x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>  getX() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">this</span>.x;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> a <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> A();
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> b <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> B();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>a.x <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>b.getX() <span style="color:#998;font-style:italic">// 1
</span></span></span></code></pre></div><p>上面示例中，类<code>A</code>的属性<code>x</code>是保护成员，直接从实例读取该属性（<code>a.x</code>）会报错，但是子类<code>B</code>内部可以读取该属性。</p>
<p>子类不仅可以拿到父类的保护成员，还可以定义同名成员。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">protected</span> x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>  x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">2</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，子类<code>B</code>定义了父类<code>A</code>的同名成员<code>x</code>，并且父类的<code>x</code>是保护成员，子类将其改成了公开成员。<code>B</code>类的<code>x</code>属性前面没有修饰符，等同于修饰符是<code>public</code>，外界可以读取这个属性。</p>
<p>在类的外部，实例对象不能读取保护成员，但是在类的内部可以。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">protected</span> x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  f(obj:<span style="color:#458;font-weight:bold">A</span>) {
</span></span><span style="display:flex;"><span>    console.log(obj.x);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> a <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> A();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>a.x <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>a.f(a) <span style="color:#998;font-style:italic">// 1
</span></span></span></code></pre></div><p>上面示例中，属性<code>x</code>是类<code>A</code>的保护成员，在类的外部，实例对象<code>a</code>拿不到这个属性。但是，实例对象<code>a</code>传入类<code>A</code>的内部，就可以从<code>a</code>拿到<code>x</code>。</p>
<h3 id="实例属性的简写形式">实例属性的简写形式</h3>
<p>实际开发中，很多实例属性的值，是通过构造方法传入的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Point {
</span></span><span style="display:flex;"><span>  x:<span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>  y:<span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">constructor</span>(x:<span style="color:#458;font-weight:bold">number</span>, y:<span style="color:#458;font-weight:bold">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.x <span style="color:#000;font-weight:bold">=</span> x;
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.y <span style="color:#000;font-weight:bold">=</span> y;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面实例中，属性<code>x</code>和<code>y</code>的值是通过构造方法的参数传入的。</p>
<p>这样的写法等于对同一个属性要声明两次类型，一次在类的头部，另一次在构造方法的参数里面。这有些累赘，TypeScript 就提供了一种简写形式。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Point {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">constructor</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">public</span> x:<span style="color:#458;font-weight:bold">number</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">public</span> y:<span style="color:#458;font-weight:bold">number</span>
</span></span><span style="display:flex;"><span>  ) {}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> p <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> Point(<span style="color:#099">10</span>, <span style="color:#099">10</span>);
</span></span><span style="display:flex;"><span>p.x <span style="color:#998;font-style:italic">// 10
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>p.y <span style="color:#998;font-style:italic">// 10
</span></span></span></code></pre></div><p>上面示例中，构造方法的参数<code>x</code>前面有<code>public</code>修饰符，这时 TypeScript 就会自动声明一个公开属性<code>x</code>，不必在构造方法里面写任何代码，同时还会设置<code>x</code>的值为构造方法的参数值。注意，这里的<code>public</code>不能省略。</p>
<p>除了<code>public</code>修饰符，构造方法的参数名只要有<code>private</code>、<code>protected</code>、<code>readonly</code>修饰符，都会自动声明对应修饰符的实例属性。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">constructor</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">public</span> a: <span style="color:#458;font-weight:bold">number</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">protected</span> b: <span style="color:#458;font-weight:bold">number</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">private</span> c: <span style="color:#458;font-weight:bold">number</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">readonly</span> d: <span style="color:#458;font-weight:bold">number</span>
</span></span><span style="display:flex;"><span>  ) {}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 编译结果
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>    a;
</span></span><span style="display:flex;"><span>    b;
</span></span><span style="display:flex;"><span>    c;
</span></span><span style="display:flex;"><span>    d;
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">constructor</span>(a, b, c, d) {
</span></span><span style="display:flex;"><span>      <span style="color:#000;font-weight:bold">this</span>.a <span style="color:#000;font-weight:bold">=</span> a;
</span></span><span style="display:flex;"><span>      <span style="color:#000;font-weight:bold">this</span>.b <span style="color:#000;font-weight:bold">=</span> b;
</span></span><span style="display:flex;"><span>      <span style="color:#000;font-weight:bold">this</span>.c <span style="color:#000;font-weight:bold">=</span> c;
</span></span><span style="display:flex;"><span>      <span style="color:#000;font-weight:bold">this</span>.d <span style="color:#000;font-weight:bold">=</span> d;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，从编译结果可以看到，构造方法的<code>a</code>、<code>b</code>、<code>c</code>、<code>d</code>会生成对应的实例属性。</p>
<p><code>readonly</code>还可以与其他三个可访问性修饰符，一起使用。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">constructor</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">public</span> <span style="color:#000;font-weight:bold">readonly</span> x:<span style="color:#458;font-weight:bold">number</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">protected</span> <span style="color:#000;font-weight:bold">readonly</span> y:<span style="color:#458;font-weight:bold">number</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">private</span> <span style="color:#000;font-weight:bold">readonly</span> z:<span style="color:#458;font-weight:bold">number</span>
</span></span><span style="display:flex;"><span>  ) {}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="静态成员">静态成员</h2>
<p>类的内部可以使用<code>static</code>关键字，定义静态成员。</p>
<p><strong>静态成员是只能通过类本身使用的成员，不能通过实例对象使用。</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> MyClass {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">static</span> x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">static</span> printX() {
</span></span><span style="display:flex;"><span>    console.log(MyClass.x);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>MyClass.x <span style="color:#998;font-style:italic">// 0
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>MyClass.printX() <span style="color:#998;font-style:italic">// 0
</span></span></span></code></pre></div><p>上面示例中，<code>x</code>是静态属性，<code>printX()</code>是静态方法。它们都必须通过<code>MyClass</code>获取，而不能通过实例对象调用。</p>
<p><code>static</code>关键字前面可以使用 public、private、protected 修饰符。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> MyClass {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">private</span> <span style="color:#000;font-weight:bold">static</span> x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>MyClass.x <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，静态属性<code>x</code>前面有<code>private</code>修饰符，表示只能在<code>MyClass</code>内部使用，如果在外部调用这个属性就会报错。</p>
<p>静态私有属性也可以用 ES6 语法的<code>#</code>前缀表示，上面示例可以改写如下。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> MyClass {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">static</span> <span style="color:#a61717;background-color:#e3d2d2">#</span>x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>public</code>和<code>protected</code>的静态成员可以被继承。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">public</span> <span style="color:#000;font-weight:bold">static</span> x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">protected</span> <span style="color:#000;font-weight:bold">static</span> y <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">static</span> getY() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> B.y;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>B.x <span style="color:#998;font-style:italic">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>B.getY() <span style="color:#998;font-style:italic">// 1
</span></span></span></code></pre></div><p>上面示例中，类<code>A</code>的静态属性<code>x</code>和<code>y</code>都被<code>B</code>继承，公开成员<code>x</code>可以在<code>B</code>的外部获取，保护成员<code>y</code>只能在<code>B</code>的内部获取。</p>
<h2 id="泛型类">泛型类</h2>
<p>类也可以写成泛型，使用类型参数。关于泛型的详细介绍，请看《泛型》一章。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Box&lt;<span style="color:#000080">Type</span>&gt; {
</span></span><span style="display:flex;"><span>  contents: <span style="color:#458;font-weight:bold">Type</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">constructor</span>(value:<span style="color:#458;font-weight:bold">Type</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.contents <span style="color:#000;font-weight:bold">=</span> value;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> b:<span style="color:#458;font-weight:bold">Box</span>&lt;<span style="color:#000080">string</span>&gt; <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> Box(<span style="color:#d14">&#39;hello!&#39;</span>);
</span></span></code></pre></div><p>上面示例中，类<code>Box</code>有类型参数<code>Type</code>，因此属于泛型类。新建实例时，变量的类型声明需要带有类型参数的值，不过本例等号左边的<code>Box&lt;string&gt;</code>可以省略不写，因为可以从等号右边推断得到。</p>
<p>注意，静态成员不能使用泛型的类型参数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Box&lt;<span style="color:#000080">Type</span>&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">static</span> defaultContents: <span style="color:#458;font-weight:bold">Type</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>上面示例中，静态属性<code>defaultContents</code>的类型写成类型参数<code>Type</code>会报错。因为这意味着调用时必须给出类型参数（即写成<code>Box&lt;string&gt;.defaultContents</code>），并且类型参数发生变化，这个属性也会跟着变，这并不是好的做法。</p>
<h2 id="抽象类抽象成员">抽象类，抽象成员</h2>
<p>TypeScript 允许在类的定义前面，加上关键字<code>abstract</code>，表示该类不能被实例化，只能当作其他类的模板。这种类就叫做“抽象类”（abstract class）。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">abstract</span> <span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  id <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> a <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> A(); <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，直接新建抽象类的实例，会报错。</p>
<p>抽象类只能当作基类使用，用来在它的基础上定义子类。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">abstract</span> <span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  id <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>  amount <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">100</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> b <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> B();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>b.id <span style="color:#998;font-style:italic">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>b.amount <span style="color:#998;font-style:italic">// 100
</span></span></span></code></pre></div><p>上面示例中，<code>A</code>是一个抽象类，<code>B</code>是<code>A</code>的子类，继承了<code>A</code>的所有成员，并且可以定义自己的成员和实例化。</p>
<p>抽象类的子类也可以是抽象类，也就是说，抽象类可以继承其他抽象类。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">abstract</span> <span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  foo:<span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">abstract</span> <span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>  bar:<span style="color:#458;font-weight:bold">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>抽象类的内部可以有已经实现好的属性和方法，也可以有还未实现的属性和方法。后者就叫做“抽象成员”（abstract member），即属性名和方法名有<code>abstract</code>关键字，表示该方法需要子类实现。如果子类没有实现抽象成员，就会报错。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">abstract</span> <span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">abstract</span> foo:<span style="color:#458;font-weight:bold">string</span>;
</span></span><span style="display:flex;"><span>  bar:<span style="color:#458;font-weight:bold">string</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>  foo <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;b&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，抽象类<code>A</code>定义了抽象属性<code>foo</code>，子类<code>B</code>必须实现这个属性，否则会报错。</p>
<p>下面是抽象方法的例子。如果抽象类的方法前面加上<code>abstract</code>，就表明子类必须给出该方法的实现。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">abstract</span> <span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">abstract</span> execute()<span style="color:#000;font-weight:bold">:</span><span style="color:#458;font-weight:bold">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> B <span style="color:#000;font-weight:bold">extends</span> A {
</span></span><span style="display:flex;"><span>  execute() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#d14">`B executed`</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这里有几个注意点。</p>
<p>（1）抽象成员只能存在于抽象类，不能存在于普通类。</p>
<p>（2）抽象成员不能有具体实现的代码。也就是说，已经实现好的成员前面不能加<code>abstract</code>关键字。</p>
<p>（3）抽象成员前也不能有<code>private</code>修饰符，否则无法在子类中实现该成员。</p>
<p>（4）一个子类最多只能继承一个抽象类。</p>
<p>总之，抽象类的作用是，确保各种相关的子类都拥有跟基类相同的接口，可以看作是模板。其中的抽象成员都是必须由子类实现的成员，非抽象成员则表示基类已经实现的、由所有子类共享的成员。</p>
<h2 id="this-问题">this 问题</h2>
<p>类的方法经常用到<code>this</code>关键字，它表示该方法当前所在的对象。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  name <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;A&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  getName() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">this</span>.name;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> a <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> A();
</span></span><span style="display:flex;"><span>a.getName() <span style="color:#998;font-style:italic">// &#39;A&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> b <span style="color:#000;font-weight:bold">=</span> {
</span></span><span style="display:flex;"><span>  name<span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#39;b&#39;</span>,
</span></span><span style="display:flex;"><span>  getName: <span style="color:#458;font-weight:bold">a.getName</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>b.getName() <span style="color:#998;font-style:italic">// &#39;b&#39;
</span></span></span></code></pre></div><p>上面示例中，变量<code>a</code>和<code>b</code>的<code>getName()</code>是同一个方法，但是执行结果不一样，原因就是它们内部的<code>this</code>指向不一样的对象。如果<code>getName()</code>在变量<code>a</code>上运行，<code>this</code>指向<code>a</code>；如果在<code>b</code>上运行，<code>this</code>指向<code>b</code>。</p>
<p>有些场合需要给出<code>this</code>类型，但是 JavaScript 函数通常不带有<code>this</code>参数，这时 TypeScript 允许函数增加一个名为<code>this</code>的参数，放在参数列表的第一位，用来描述函数内部的<code>this</code>关键字的类型。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 编译前
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">function</span> fn(
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">this</span><span style="color:#000;font-weight:bold">:</span> SomeType,
</span></span><span style="display:flex;"><span>  x: <span style="color:#458;font-weight:bold">number</span>
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">/* ... */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 编译后
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">function</span> fn(x) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">/* ... */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，函数<code>fn()</code>的第一个参数是<code>this</code>，用来声明函数内部的<code>this</code>的类型。编译时，TypeScript 一旦发现函数的第一个参数名为<code>this</code>，则会去除这个参数，即编译结果不会带有该参数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  name <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;A&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  getName(<span style="color:#000;font-weight:bold">this</span><span style="color:#000;font-weight:bold">:</span> A) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">this</span>.name;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> a <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> A();
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> b <span style="color:#000;font-weight:bold">=</span> a.getName;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>b() <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，类<code>A</code>的<code>getName()</code>添加了<code>this</code>参数，如果直接调用这个方法，<code>this</code>的类型就会跟声明的类型不一致，从而报错。</p>
<p><code>this</code>参数的类型可以声明为各种对象。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> foo(
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">this</span><span style="color:#000;font-weight:bold">:</span> { name: <span style="color:#458;font-weight:bold">string</span> }
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">this</span>.name <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;Jack&#39;</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">this</span>.name <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>foo.call({ name: <span style="color:#458;font-weight:bold">123</span> }); <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，参数<code>this</code>的类型是一个带有<code>name</code>属性的对象，不符合这个条件的<code>this</code>都会报错。</p>
<p>TypeScript 提供了一个<code>noImplicitThis</code>编译选项。如果打开了这个设置项，如果<code>this</code>的值推断为<code>any</code>类型，就会报错。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// noImplicitThis 打开
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Rectangle {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">constructor</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">public</span> width:<span style="color:#458;font-weight:bold">number</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">public</span> height:<span style="color:#458;font-weight:bold">number</span>
</span></span><span style="display:flex;"><span>  ) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  getAreaFunction() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">function</span> () {
</span></span><span style="display:flex;"><span>      <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">this</span>.width <span style="color:#000;font-weight:bold">*</span> <span style="color:#000;font-weight:bold">this</span>.height; <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    };
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，<code>getAreaFunction()</code>方法返回一个函数，这个函数里面用到了<code>this</code>，但是这个<code>this</code>跟<code>Rectangle</code>这个类没关系，它的类型推断为<code>any</code>，所以就报错了。</p>
<p>在类的内部，<code>this</code>本身也可以当作类型使用，表示当前类的实例对象。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Box {
</span></span><span style="display:flex;"><span>  contents:<span style="color:#458;font-weight:bold">string</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">set</span>(value:<span style="color:#458;font-weight:bold">string</span>)<span style="color:#000;font-weight:bold">:</span><span style="color:#000;font-weight:bold">this</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">this</span>.contents <span style="color:#000;font-weight:bold">=</span> value;
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，<code>set()</code>方法的返回值类型就是<code>this</code>，表示当前的实例对象。</p>
<p>注意，<code>this</code>类型不允许应用于静态成员。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> A {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">static</span> a:<span style="color:#458;font-weight:bold">this</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>上面示例中，静态属性<code>a</code>的返回值类型是<code>this</code>，就报错了。原因是<code>this</code>类型表示实例对象，但是静态成员拿不到实例对象。</p>
<p>有些方法返回一个布尔值，表示当前的<code>this</code>是否属于某种类型。这时，这些方法的返回值类型可以写成<code>this is Type</code>的形式，其中用到了<code>is</code>运算符。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> FileSystemObject {
</span></span><span style="display:flex;"><span>  isFile()<span style="color:#000;font-weight:bold">:</span> <span style="color:#000;font-weight:bold">this</span> <span style="color:#000;font-weight:bold">is</span> FileRep {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">this</span> <span style="color:#000;font-weight:bold">instanceof</span> FileRep;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  isDirectory()<span style="color:#000;font-weight:bold">:</span> <span style="color:#000;font-weight:bold">this</span> <span style="color:#000;font-weight:bold">is</span> Directory {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">this</span> <span style="color:#000;font-weight:bold">instanceof</span> Directory;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>上面示例中，两个方法的返回值类型都是布尔值，写成<code>this is Type</code>的形式，可以精确表示返回值。<code>is</code>运算符的介绍详见《类型断言》一章。</p>

        </div>

        
<div class="post-archive">
    <ul class="post-copyright">
        <li><strong>Author: </strong><a rel="author" href="http://shansec.github.io">未来可期</a></li>
        <li style="word-break:break-all"><strong>Link: </strong><a href="http://shansec.github.io/post/ts/Typescript-class%E7%B1%BB%E5%9E%8B/">http://shansec.github.io/post/ts/Typescript-class%E7%B1%BB%E5%9E%8B/</a></li>
        <li><strong>License: </strong>This work is under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>. Kindly fulfill the requirements of the aforementioned License when adapting or creating a derivative of this work.</li>
    </ul>
</div>
<br/>



        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/post/ts/Typescript-interface/">Typescript Interface</a></li>
        
        <li><a href="/post/ts/typescript-%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B/">Typescript 函数类型</a></li>
        
        <li><a href="/post/ts/typescript-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B/">Typescript 对象类型</a></li>
        
        <li><a href="/post/ts/typescript-%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B/">Typescript 数组类型</a></li>
        
        <li><a href="/post/ts/typescript-%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B/">Typescript 数组类型</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='/tags/typescript' target="_blank">typescript</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "your github repo"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
    
    

</div>

                    <footer id="footer">
    <div>
        &copy; 2024 <a href="http://shansec.github.io">未来可期的博客 By 未来可期</a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>
<style type="text/css">
div.highlight {
    position: relative;
    margin: 1em 0px;
}

.copy-code {
    display: none;
    position: absolute;
    top: 4px;
    right: 4px;
    color: rgba(255, 255, 255, 0.8);
    background: rgba(78, 78, 78, 0.8);
    border-radius: var(--radius);
    padding: 0 5px;
    font: inherit;
    user-select: none;
    cursor: pointer;
    border: 0;
    --radius: 8px;
}

div.highlight:hover .copy-code,pre:hover .copy-code {
    display: block;
}

</style>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>


    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




    <script src='/js/douban.js'></script>

                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='http://shansec.github.io/search' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="http://shansec.github.io">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>

    <section class="widget">
        <h3 class="widget-title">Latest articles</h3>
<ul class="widget-list">
    
    <li>
        <a href="http://shansec.github.io/post/ts/Typescript-declare%E5%85%B3%E9%94%AE%E5%AD%97/" title="Typescript Declare关键字" target="_blank">Typescript Declare关键字</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/Typescript-%E6%A8%A1%E5%9D%97/" title="Typescript 模块" target="_blank">Typescript 模块</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/Typescript-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/" title="Typescript 类型断言" target="_blank">Typescript 类型断言</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/Typescript-Enum%E7%B1%BB%E5%9E%8B/" title="Typescript Enum类型" target="_blank">Typescript Enum类型</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/Typescript-%E6%B3%9B%E5%9E%8B/" title="Typescript 泛型" target="_blank">Typescript 泛型</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/Typescript-class%E7%B1%BB%E5%9E%8B/" title="Typescript Class类型" target="_blank">Typescript Class类型</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/Typescript-interface/" title="Typescript Interface" target="_blank">Typescript Interface</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/typescript-%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B/" title="Typescript 函数类型" target="_blank">Typescript 函数类型</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/typescript-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B/" title="Typescript 对象类型" target="_blank">Typescript 对象类型</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/typescript-%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B/" title="Typescript 数组类型" target="_blank">Typescript 数组类型</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href='/categories/'>Categories</a></h3>
<ul class="widget-list">
    
    <li><a href="http://shansec.github.io/categories/go/">go (43)</a></li>
    
    <li><a href="http://shansec.github.io/categories/%E5%89%8D%E7%AB%AF/">前端 (66)</a></li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href='/tags/'>Tags</a></h3>
<div class="tagcloud">
    
    <a href="http://shansec.github.io/tags/CSS/">CSS</a>
    
    <a href="http://shansec.github.io/tags/HTTP/">HTTP</a>
    
    <a href="http://shansec.github.io/tags/javaScript/">javaScript</a>
    
    <a href="http://shansec.github.io/tags/CSS/">CSS</a>
    
    <a href="http://shansec.github.io/tags/docker/">docker</a>
    
    <a href="http://shansec.github.io/tags/es6/">es6</a>
    
    <a href="http://shansec.github.io/tags/go/">go</a>
    
    <a href="http://shansec.github.io/tags/go-%E5%9F%BA%E7%A1%80/">go 基础</a>
    
    <a href="http://shansec.github.io/tags/go-%E6%A0%87%E5%87%86%E5%BA%93/">go 标准库</a>
    
    <a href="http://shansec.github.io/tags/javaScript/">javaScript</a>
    
    <a href="http://shansec.github.io/tags/jwt/">jwt</a>
    
    <a href="http://shansec.github.io/tags/package/">package</a>
    
    <a href="http://shansec.github.io/tags/pinia/">pinia</a>
    
    <a href="http://shansec.github.io/tags/redis/">redis</a>
    
    <a href="http://shansec.github.io/tags/sql/">sql</a>
    
    <a href="http://shansec.github.io/tags/sqlx/">sqlx</a>
    
    <a href="http://shansec.github.io/tags/typescript/">typescript</a>
    
    <a href="http://shansec.github.io/tags/vue/">vue</a>
    
    <a href="http://shansec.github.io/tags/%E5%AD%98%E5%82%A8/">存储</a>
    
    <a href="http://shansec.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">微信小程序</a>
    
    <a href="http://shansec.github.io/tags/%E6%A0%87%E5%87%86%E5%BA%93/">标准库</a>
    
    <a href="http://shansec.github.io/tags/%E6%A1%86%E6%9E%B6/">框架</a>
    
    <a href="http://shansec.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/">计算机原理</a>
    
</div>
    </section>

    
<section class="widget">
    <h3 class="widget-title">Links</h3>
    <ul class="widget-list">
        
        <li>
            <a target="_blank" href="https://www.liwenzhou.com/" title="李文周的博客">李文周的博客</a>
        </li>
        
    </ul>
</section>


    <section class="widget">
        <h3 class="widget-title">Meta</h3>
        <ul class="widget-list">
            <li><a href="http://shansec.github.io/index.xml">RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>