<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <meta name="referrer" content="no-referrer-when-downgrade">
    

    <title>Typescript 类型断言 | 未来可期的博客</title>
    <meta property="og:title" content="Typescript 类型断言 - 未来可期的博客">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2024-06-26T10:59:25&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2024-06-26T10:59:25&#43;08:00'>
        
    <meta name="Keywords" content="golang,go语言,go语言笔记,未来可期,博客,公众号,小程序">
    <meta name="description" content="Typescript 类型断言">
        
    <meta name="author" content="未来可期">
    <meta property="og:url" content="http://shansec.github.io/post/ts/Typescript-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/">
    <link rel="shortcut icon" href='/favicon.ico'  type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
        <link rel="stylesheet" href='/css/douban.css'>
    
        <link rel="stylesheet" href='/css/other.css'>
    
</head>

<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="http://shansec.github.io">
                        未来可期的博客
                    </a>
                
                <p class="description">专注于Go语言(golang)、前端技术</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="http://shansec.github.io">Home</a>
                    
                    <a  href="http://shansec.github.io/archives/" title="归档">归档</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    <style type="text/css">
    .post-toc {
        position: fixed;
        width: 200px;
        margin-left: -210px;
        padding: 5px 10px;
        font-family: Athelas, STHeiti, Microsoft Yahei, serif;
        font-size: 12px;
        border: 1px solid rgba(0, 0, 0, .07);
        border-radius: 5px;
        background-color: rgba(255, 255, 255, 0.98);
        background-clip: padding-box;
        -webkit-box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        word-wrap: break-word;
        white-space: nowrap;
        -webkit-box-sizing: border-box;
        box-sizing: border-box;
        z-index: 999;
        cursor: pointer;
        max-height: 70%;
        overflow-y: auto;
        overflow-x: hidden;
    }

    .post-toc .post-toc-title {
        width: 100%;
        margin: 0 auto;
        font-size: 20px;
        font-weight: 400;
        text-transform: uppercase;
        text-align: center;
    }

    .post-toc .post-toc-content {
        font-size: 15px;
    }

    .post-toc .post-toc-content>nav>ul {
        margin: 10px 0;
    }

    .post-toc .post-toc-content ul {
        padding-left: 20px;
        list-style: square;
        margin: 0.5em;
        line-height: 1.8em;
    }

    .post-toc .post-toc-content ul ul {
        padding-left: 15px;
        display: none;
    }

    @media print,
    screen and (max-width:1057px) {
        .post-toc {
            display: none;
        }
    }
</style>
<div class="post-toc" style="position: absolute; top: 188px;">
    <h2 class="post-toc-title">Table of Contents</h2>
    <div class="post-toc-content">
        <nav id="TableOfContents">
  <ul>
    <li><a href="#简介">简介</a></li>
    <li><a href="#类型断言的条件">类型断言的条件</a></li>
    <li><a href="#as-const-断言">as const 断言</a></li>
    <li><a href="#非空断言">非空断言</a></li>
    <li><a href="#断言函数">断言函数</a></li>
  </ul>
</nav>
    </div>
</div>
<script type="text/javascript">
    $(document).ready(function () {
        var postToc = $(".post-toc");
        if (postToc.length) {
            var leftPos = $("#main").offset().left;
            if (leftPos < 220) {
                postToc.css({ "width": leftPos - 10, "margin-left": (0 - leftPos) })
            }

            var t = postToc.offset().top - 20,
                a = {
                    start: {
                        position: "absolute",
                        top: t
                    },
                    process: {
                        position: "fixed",
                        top: 20
                    },
                };
            $(window).scroll(function () {
                var e = $(window).scrollTop();
                e < t ? postToc.css(a.start) : postToc.css(a.process)
            })
        }

        if ($("#TableOfContents").children().length < 1) {
            $(".post-toc").remove();
        }
    })
</script>
    <article class="post">
        <header>
            <h1 class="post-title">Typescript 类型断言</h1>
        </header>
        
  <time datetime="2024-06-26T02:59:25Z" class="post-meta meta-date dt-published">
    2024-06-26
  </time>


<div class="post-meta meta-category">
  <span>&nbsp;|</span>
  
    <a href='/categories/%E5%89%8D%E7%AB%AF' target="_blank">前端</a>
  
</div>


        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">&nbsp;|
                <span id="busuanzi_value_page_pv"></span> <span>reads</span>
            </span>
        </div>
        
        
        <div class="post-content">
            <h2 id="简介">简介</h2>
<p>对于没有类型声明的值，TypeScript 会进行类型推断，很多时候得到的结果，未必是开发者想要的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> T <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;a&#39;</span><span style="color:#000;font-weight:bold">|</span><span style="color:#d14">&#39;b&#39;</span><span style="color:#000;font-weight:bold">|</span><span style="color:#d14">&#39;c&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> foo <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> bar:<span style="color:#458;font-weight:bold">T</span> <span style="color:#000;font-weight:bold">=</span> foo; <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，最后一行报错，原因是 TypeScript 推断变量<code>foo</code>的类型是<code>string</code>，而变量<code>bar</code>的类型是<code>'a'|'b'|'c'</code>，前者是后者的父类型。父类型不能赋值给子类型，所以就报错了。</p>
<p>TypeScript 提供了“类型断言”这样一种手段，允许开发者在代码中“断言”某个值的类型，告诉编译器此处的值是什么类型。TypeScript 一旦发现存在类型断言，就不再对该值进行类型推断，而是直接采用断言给出的类型。</p>
<p>这种做法的实质是，允许开发者在某个位置“绕过”编译器的类型推断，让本来通不过类型检查的代码能够通过，避免编译器报错。这样虽然削弱了 TypeScript 类型系统的严格性，但是为开发者带来了方便，毕竟开发者比编译器更了解自己的代码。</p>
<p>回到上面的例子，解决方法就是进行类型断言，在赋值时断言变量<code>foo</code>的类型。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> T <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;a&#39;</span><span style="color:#000;font-weight:bold">|</span><span style="color:#d14">&#39;b&#39;</span><span style="color:#000;font-weight:bold">|</span><span style="color:#d14">&#39;c&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> foo <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> bar:<span style="color:#458;font-weight:bold">T</span> <span style="color:#000;font-weight:bold">=</span> foo <span style="color:#000;font-weight:bold">as</span> T; <span style="color:#998;font-style:italic">// 正确
</span></span></span></code></pre></div><p>上面示例中，最后一行的<code>foo as T</code>表示告诉编译器，变量<code>foo</code>的类型断言为<code>T</code>，所以这一行不再需要类型推断了，编译器直接把<code>foo</code>的类型当作<code>T</code>，就不会报错了。</p>
<p>总之，类型断言并不是真的改变一个值的类型，而是提示编译器，应该如何处理这个值。</p>
<p>类型断言有两种语法。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 语法一：&lt;类型&gt;值
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>&lt;<span style="color:#000080">Type</span>&gt;value
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 语法二：值 as 类型
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>value <span style="color:#000;font-weight:bold">as</span> Type
</span></span></code></pre></div><p>上面两种语法是等价的，<code>value</code>表示值，<code>Type</code>表示类型。早期只有语法一，后来因为 TypeScript 开始支持 React 的 JSX 语法（尖括号表示 HTML 元素），为了避免两者冲突，就引入了语法二。目前，推荐使用语法二。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 语法一
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">let</span> bar:<span style="color:#458;font-weight:bold">T</span> <span style="color:#000;font-weight:bold">=</span> &lt;<span style="color:#000080">T</span>&gt;foo;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 语法二
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">let</span> bar:<span style="color:#458;font-weight:bold">T</span> <span style="color:#000;font-weight:bold">=</span> foo <span style="color:#000;font-weight:bold">as</span> T;
</span></span></code></pre></div><p>上面示例是两种类型断言的语法，其中的语法一因为跟 JSX 语法冲突，使用时必须关闭 TypeScript 的 React 支持，否则会无法识别。由于这个原因，现在一般都使用语法二。</p>
<p>下面看一个例子。《对象》一章提到过，对象类型有严格字面量检查，如果存在额外的属性会报错。</p>
<pre tabindex="0"><code>// 报错
const p:{ x: number } = { x: 0, y: 0 };
</code></pre><p>上面示例中，等号右侧是一个对象字面量，多出了属性<code>y</code>，导致报错。解决方法就是使用类型断言，可以用两种不同的断言。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 正确
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> p0<span style="color:#000;font-weight:bold">:</span>{ x: <span style="color:#458;font-weight:bold">number</span> } <span style="color:#000;font-weight:bold">=</span>
</span></span><span style="display:flex;"><span>  { x: <span style="color:#458;font-weight:bold">0</span>, y: <span style="color:#458;font-weight:bold">0</span> } <span style="color:#000;font-weight:bold">as</span> { x: <span style="color:#458;font-weight:bold">number</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 正确
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> p1<span style="color:#000;font-weight:bold">:</span>{ x: <span style="color:#458;font-weight:bold">number</span> } <span style="color:#000;font-weight:bold">=</span>
</span></span><span style="display:flex;"><span>  { x: <span style="color:#458;font-weight:bold">0</span>, y: <span style="color:#458;font-weight:bold">0</span> } <span style="color:#000;font-weight:bold">as</span> { x: <span style="color:#458;font-weight:bold">number</span>; y: <span style="color:#458;font-weight:bold">number</span> };
</span></span></code></pre></div><p>上面示例中，两种类型断言都是正确的。第一种断言将类型改成与等号左边一致，第二种断言使得等号右边的类型是左边类型的子类型，子类型可以赋值给父类型，同时因为存在类型断言，就没有严格字面量检查了，所以不报错。</p>
<p>下面是一个网页编程的实际例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> username <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">document</span>.getElementById(<span style="color:#d14">&#39;username&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">if</span> (username) {
</span></span><span style="display:flex;"><span>  (username <span style="color:#000;font-weight:bold">as</span> HTMLInputElement).value; <span style="color:#998;font-style:italic">// 正确
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>上面示例中，变量<code>username</code>的类型是<code>HTMLElement | null</code>，排除了<code>null</code>的情况以后，HTMLElement 类型是没有<code>value</code>属性的。如果<code>username</code>是一个输入框，那么就可以通过类型断言，将它的类型改成<code>HTMLInputElement</code>，就可以读取<code>value</code>属性。</p>
<p>注意，上例的类型断言的圆括号是必需的，否则<code>username</code>会被断言成<code>HTMLInputElement.value</code>，从而报错。</p>
<p>类型断言不应滥用，因为它改变了 TypeScript 的类型检查，很可能埋下错误的隐患。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> data:<span style="color:#458;font-weight:bold">object</span> <span style="color:#000;font-weight:bold">=</span> {
</span></span><span style="display:flex;"><span>  a: <span style="color:#458;font-weight:bold">1</span>,
</span></span><span style="display:flex;"><span>  b: <span style="color:#458;font-weight:bold">2</span>,
</span></span><span style="display:flex;"><span>  c: <span style="color:#458;font-weight:bold">3</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>data.length; <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>(data <span style="color:#000;font-weight:bold">as</span> <span style="color:#0086b3">Array</span>&lt;<span style="color:#000080">string</span>&gt;).length; <span style="color:#998;font-style:italic">// 正确
</span></span></span></code></pre></div><p>上面示例中，变量<code>data</code>是一个对象，没有<code>length</code>属性。但是通过类型断言，可以将它的类型断言为数组，这样使用<code>length</code>属性就能通过类型检查。但是，编译后的代码在运行时依然会报错，所以类型断言可以让错误的代码通过编译。</p>
<p>类型断言的一大用处是，指定 unknown 类型的变量的具体类型。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> value:<span style="color:#458;font-weight:bold">unknown</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;Hello World&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> s1:<span style="color:#458;font-weight:bold">string</span> <span style="color:#000;font-weight:bold">=</span> value; <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> s2:<span style="color:#458;font-weight:bold">string</span> <span style="color:#000;font-weight:bold">=</span> value <span style="color:#000;font-weight:bold">as</span> <span style="color:#458;font-weight:bold">string</span>; <span style="color:#998;font-style:italic">// 正确
</span></span></span></code></pre></div><p>上面示例中，unknown 类型的变量<code>value</code>不能直接赋值给其他类型的变量，但是可以将它断言为其他类型，这样就可以赋值给别的变量了。</p>
<p>另外，类型断言也适合指定联合类型的值的具体类型。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> s1:<span style="color:#458;font-weight:bold">number</span><span style="color:#000;font-weight:bold">|</span><span style="color:#458;font-weight:bold">string</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;hello&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> s2:<span style="color:#458;font-weight:bold">number</span> <span style="color:#000;font-weight:bold">=</span> s1 <span style="color:#000;font-weight:bold">as</span> <span style="color:#458;font-weight:bold">number</span>;
</span></span></code></pre></div><p>上面示例中，变量<code>s1</code>是联合类型，可以断言其为联合类型里面的一种具体类型，再将其赋值给变量<code>s2</code>。</p>
<h2 id="类型断言的条件">类型断言的条件</h2>
<p>类型断言并不意味着，可以把某个值断言为任意类型。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> n <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> m:<span style="color:#458;font-weight:bold">string</span> <span style="color:#000;font-weight:bold">=</span> n <span style="color:#000;font-weight:bold">as</span> <span style="color:#458;font-weight:bold">string</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，变量<code>n</code>是数值，无法把它断言成字符串，TypeScript 会报错。</p>
<p>类型断言的使用前提是，值的实际类型与断言的类型必须满足一个条件。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span>expr <span style="color:#000;font-weight:bold">as</span> T
</span></span></code></pre></div><p>上面代码中，<code>expr</code>是实际的值，<code>T</code>是类型断言，它们必须满足下面的条件：<code>expr</code>是<code>T</code>的子类型，或者<code>T</code>是<code>expr</code>的子类型。</p>
<p>也就是说，类型断言要求实际的类型与断言的类型兼容，实际类型可以断言为一个更加宽泛的类型（父类型），也可以断言为一个更加精确的类型（子类型），但不能断言为一个完全无关的类型。</p>
<p>但是，如果真的要断言成一个完全无关的类型，也是可以做到的。**那就是连续进行两次类型断言，先断言成 unknown 类型或 any 类型，然后再断言为目标类型。**因为<code>any</code>类型和<code>unknown</code>类型是所有其他类型的父类型，所以可以作为两种完全无关的类型的中介。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 或者写成 &lt;T&gt;&lt;unknown&gt;expr
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>expr <span style="color:#000;font-weight:bold">as</span> <span style="color:#458;font-weight:bold">unknown</span> <span style="color:#000;font-weight:bold">as</span> T
</span></span></code></pre></div><p>上面代码中，<code>expr</code>连续进行了两次类型断言，第一次断言为<code>unknown</code>类型，第二次断言为<code>T</code>类型。这样的话，<code>expr</code>就可以断言成任意类型<code>T</code>，而不报错。</p>
<p>下面是本小节开头那个例子的改写。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> n <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> m:<span style="color:#458;font-weight:bold">string</span> <span style="color:#000;font-weight:bold">=</span> n <span style="color:#000;font-weight:bold">as</span> <span style="color:#458;font-weight:bold">unknown</span> <span style="color:#000;font-weight:bold">as</span> <span style="color:#458;font-weight:bold">string</span>; <span style="color:#998;font-style:italic">// 正确
</span></span></span></code></pre></div><p>上面示例中，通过两次类型断言，变量<code>n</code>的类型就从数值，变成了完全无关的字符串，从而赋值时不会报错。</p>
<h2 id="as-const-断言">as const 断言</h2>
<p>如果没有声明变量类型，<strong>let 命令声明的变量，会被类型推断为 TypeScript 内置的基本类型之一；const 命令声明的变量，则被推断为值类型常量。</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 类型推断为基本类型 string
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">let</span> s1 <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;JavaScript&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 类型推断为字符串 “JavaScript”
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> s2 <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;JavaScript&#39;</span>;
</span></span></code></pre></div><p>上面示例中，变量<code>s1</code>的类型被推断为<code>string</code>，变量<code>s2</code>的类型推断为值类型<code>JavaScript</code>。后者是前者的子类型，相当于 const 命令有更强的限定作用，可以缩小变量的类型范围。</p>
<p>有些时候，let 变量会出现一些意想不到的报错，变更成 const 变量就能消除报错。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> s <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;JavaScript&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> Lang <span style="color:#000;font-weight:bold">=</span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">|</span><span style="color:#d14">&#39;JavaScript&#39;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">|</span><span style="color:#d14">&#39;TypeScript&#39;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">|</span><span style="color:#d14">&#39;Python&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> setLang(language:<span style="color:#458;font-weight:bold">Lang</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">/* ... */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>setLang(s); <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，最后一行报错，原因是函数<code>setLang()</code>的参数<code>language</code>类型是<code>Lang</code>，这是一个联合类型。但是，传入的字符串<code>s</code>的类型被推断为<code>string</code>，属于<code>Lang</code>的父类型。父类型不能替代子类型，导致报错。</p>
<p>一种解决方法就是把 let 命令改成 const 命令。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> s <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;JavaScript&#39;</span>;
</span></span></code></pre></div><p>这样的话，变量<code>s</code>的类型就是值类型<code>JavaScript</code>，它是联合类型<code>Lang</code>的子类型，传入函数<code>setLang()</code>就不会报错。</p>
<p>另一种解决方法是使用类型断言。TypeScript 提供了一种特殊的类型断言<code>as const</code>，用于告诉编译器，推断类型时，可以将这个值推断为常量，即把 let 变量断言为 const 变量，从而把内置的基本类型变更为值类型。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> s <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;JavaScript&#39;</span> <span style="color:#000;font-weight:bold">as</span> <span style="color:#000;font-weight:bold">const</span>;
</span></span><span style="display:flex;"><span>setLang(s);  <span style="color:#998;font-style:italic">// 正确
</span></span></span></code></pre></div><p>上面示例中，变量<code>s</code>虽然是用 let 命令声明的，但是使用了<code>as const</code>断言以后，就等同于是用 const 命令声明的，变量<code>s</code>的类型会被推断为值类型<code>JavaScript</code>。</p>
<p>使用了<code>as const</code>断言以后，let 变量就不能再改变值了。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> s <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;JavaScript&#39;</span> <span style="color:#000;font-weight:bold">as</span> <span style="color:#000;font-weight:bold">const</span>;
</span></span><span style="display:flex;"><span>s <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;Python&#39;</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，let 命令声明的变量<code>s</code>，使用<code>as const</code>断言以后，就不能改变值了，否则报错。</p>
<p><strong>注意，as const断言只能用于字面量，不能用于变量。</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> s <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;JavaScript&#39;</span>;
</span></span><span style="display:flex;"><span>setLang(s <span style="color:#000;font-weight:bold">as</span> <span style="color:#000;font-weight:bold">const</span>); <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，<code>as const</code>断言用于变量<code>s</code>，就报错了。下面的写法可以更清晰地看出这一点。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> s1 <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;JavaScript&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> s2 <span style="color:#000;font-weight:bold">=</span> s1 <span style="color:#000;font-weight:bold">as</span> <span style="color:#000;font-weight:bold">const</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>另外，<code>as const</code>也不能用于表达式。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> s <span style="color:#000;font-weight:bold">=</span> (<span style="color:#d14">&#39;Java&#39;</span> <span style="color:#000;font-weight:bold">+</span> <span style="color:#d14">&#39;Script&#39;</span>) <span style="color:#000;font-weight:bold">as</span> <span style="color:#000;font-weight:bold">const</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，<code>as const</code>用于表达式，导致报错。</p>
<p><code>as const</code>也可以写成前置的形式。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 后置形式
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>expr <span style="color:#000;font-weight:bold">as</span> <span style="color:#000;font-weight:bold">const</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 前置形式
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>&lt;<span style="color:#000080">const</span>&gt;expr
</span></span></code></pre></div><p><code>as const</code>断言可以用于整个对象，也可以用于对象的单个属性，这时它的类型缩小效果是不一样的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> v1 <span style="color:#000;font-weight:bold">=</span> {
</span></span><span style="display:flex;"><span>  x: <span style="color:#458;font-weight:bold">1</span>,
</span></span><span style="display:flex;"><span>  y: <span style="color:#458;font-weight:bold">2</span>,
</span></span><span style="display:flex;"><span>}; <span style="color:#998;font-style:italic">// 类型是 { x: number; y: number; }
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> v2 <span style="color:#000;font-weight:bold">=</span> {
</span></span><span style="display:flex;"><span>  x: <span style="color:#458;font-weight:bold">1</span> <span style="color:#000;font-weight:bold">as</span> <span style="color:#000;font-weight:bold">const</span>,
</span></span><span style="display:flex;"><span>  y: <span style="color:#458;font-weight:bold">2</span>,
</span></span><span style="display:flex;"><span>}; <span style="color:#998;font-style:italic">// 类型是 { x: 1; y: number; }
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> v3 <span style="color:#000;font-weight:bold">=</span> {
</span></span><span style="display:flex;"><span>  x: <span style="color:#458;font-weight:bold">1</span>,
</span></span><span style="display:flex;"><span>  y: <span style="color:#458;font-weight:bold">2</span>,
</span></span><span style="display:flex;"><span>} <span style="color:#000;font-weight:bold">as</span> <span style="color:#000;font-weight:bold">const</span>; <span style="color:#998;font-style:italic">// 类型是 { readonly x: 1; readonly y: 2; }
</span></span></span></code></pre></div><p>上面示例中，第二种写法是对属性<code>x</code>缩小类型，第三种写法是对整个对象缩小类型。</p>
<p>总之，<code>as const</code>会将字面量的类型断言为不可变类型，缩小成 TypeScript 允许的最小类型。</p>
<p>下面是数组的例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// a1 的类型推断为 number[]
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> a1 <span style="color:#000;font-weight:bold">=</span> [<span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// a2 的类型推断为 readonly [1, 2, 3]
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> a2 <span style="color:#000;font-weight:bold">=</span> [<span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>] <span style="color:#000;font-weight:bold">as</span> <span style="color:#000;font-weight:bold">const</span>;
</span></span></code></pre></div><p>上面示例中，数组字面量使用<code>as const</code>断言后，类型推断就变成了只读元组。</p>
<p>由于<code>as const</code>会将数组变成只读元组，所以很适合用于函数的 rest 参数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> add(x:<span style="color:#458;font-weight:bold">number</span>, y:<span style="color:#458;font-weight:bold">number</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> x <span style="color:#000;font-weight:bold">+</span> y;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> nums <span style="color:#000;font-weight:bold">=</span> [<span style="color:#099">1</span>, <span style="color:#099">2</span>];
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> total <span style="color:#000;font-weight:bold">=</span> add(...nums); <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，变量<code>nums</code>的类型推断为<code>number[]</code>，导致使用扩展运算符<code>...</code>传入函数<code>add()</code>会报错，因为<code>add()</code>只能接受两个参数，而<code>...nums</code>并不能保证参数的个数。</p>
<p>事实上，对于固定参数个数的函数，如果传入的参数包含扩展运算符，那么扩展运算符只能用于元组。只有当函数定义使用了 rest 参数，扩展运算符才能用于数组。</p>
<p>解决方法就是使用<code>as const</code>断言，将数组变成元组。</p>
<pre tabindex="0"><code>const nums = [1, 2] as const;
const total = add(...nums); // 正确
</code></pre><p>上面示例中，使用<code>as const</code>断言后，变量<code>nums</code>的类型会被推断为<code>readonly [1, 2]</code>，使用扩展运算符展开后，正好符合函数<code>add()</code>的参数类型。</p>
<p>Enum 成员也可以使用<code>as const</code>断言。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">enum</span> Foo {
</span></span><span style="display:flex;"><span>  X,
</span></span><span style="display:flex;"><span>  Y,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> e1 <span style="color:#000;font-weight:bold">=</span> Foo.X;            <span style="color:#998;font-style:italic">// Foo
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">let</span> e2 <span style="color:#000;font-weight:bold">=</span> Foo.X <span style="color:#000;font-weight:bold">as</span> <span style="color:#000;font-weight:bold">const</span>;   <span style="color:#998;font-style:italic">// Foo.X
</span></span></span></code></pre></div><p>上面示例中，如果不使用<code>as const</code>断言，变量<code>e1</code>的类型被推断为整个 Enum 类型；使用了<code>as const</code>断言以后，变量<code>e2</code>的类型被推断为 Enum 的某个成员，这意味着它不能变更为其他成员。</p>
<h2 id="非空断言">非空断言</h2>
<p>对于那些可能为空的变量（即可能等于<code>undefined</code>或<code>null</code>），TypeScript 提供了非空断言，保证这些变量不会为空，写法是在变量名后面加上感叹号<code>!</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> f(x?:<span style="color:#458;font-weight:bold">number</span><span style="color:#000;font-weight:bold">|</span><span style="color:#000;font-weight:bold">null</span>) {
</span></span><span style="display:flex;"><span>  validateNumber(x); <span style="color:#998;font-style:italic">// 自定义函数，确保 x 是数值
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  console.log(x<span style="color:#000;font-weight:bold">!</span>.toFixed());
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> validateNumber(e?:<span style="color:#458;font-weight:bold">number</span><span style="color:#000;font-weight:bold">|</span><span style="color:#000;font-weight:bold">null</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">typeof</span> e <span style="color:#000;font-weight:bold">!==</span> <span style="color:#d14">&#39;number&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">throw</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Error</span>(<span style="color:#d14">&#39;Not a number&#39;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，函数<code>f()</code>的参数<code>x</code>的类型是<code>number|null</code>，即可能为空。如果为空，就不存在<code>x.toFixed()</code>方法，这样写会报错。但是，开发者可以确认，经过<code>validateNumber()</code>的前置检验，变量<code>x</code>肯定不会为空，这时就可以使用非空断言，为函数体内部的变量<code>x</code>加上后缀<code>!</code>，<code>x!.toFixed()</code>编译就不会报错了。</p>
<p>非空断言在实际编程中很有用，有时可以省去一些额外的判断。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> root <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">document</span>.getElementById(<span style="color:#d14">&#39;root&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>root.addEventListener(<span style="color:#d14">&#39;click&#39;</span>, e <span style="color:#000;font-weight:bold">=&gt;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">/* ... */</span>
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><p>上面示例中，<code>getElementById()</code>有可能返回空值<code>null</code>，即变量<code>root</code>可能为空，这时对它调用<code>addEventListener()</code>方法就会报错，通不过编译。但是，开发者如果可以确认<code>root</code>元素肯定会在网页中存在，这时就可以使用非空断言。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> root <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">document</span>.getElementById(<span style="color:#d14">&#39;root&#39;</span>)<span style="color:#000;font-weight:bold">!</span>;
</span></span></code></pre></div><p>上面示例中，<code>getElementById()</code>方法加上后缀<code>!</code>，表示这个方法肯定返回非空结果。</p>
<p>不过，非空断言会造成安全隐患，只有在确定一个表达式的值不为空时才能使用。比较保险的做法还是手动检查一下是否为空。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> root <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">document</span>.getElementById(<span style="color:#d14">&#39;root&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">if</span> (root <span style="color:#000;font-weight:bold">===</span> <span style="color:#000;font-weight:bold">null</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">throw</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Error</span>(<span style="color:#d14">&#39;Unable to find DOM element #root&#39;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>root.addEventListener(<span style="color:#d14">&#39;click&#39;</span>, e <span style="color:#000;font-weight:bold">=&gt;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">/* ... */</span>
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><p>上面示例中，如果<code>root</code>为空会抛错，比非空断言更保险一点。</p>
<p>非空断言还可以用于赋值断言。TypeScript 有一个编译设置，要求类的属性必须初始化（即有初始值），如果不对属性赋值就会报错。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Point {
</span></span><span style="display:flex;"><span>  x:<span style="color:#458;font-weight:bold">number</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  y:<span style="color:#458;font-weight:bold">number</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">constructor</span>(x:<span style="color:#458;font-weight:bold">number</span>, y:<span style="color:#458;font-weight:bold">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，属性<code>x</code>和<code>y</code>会报错，因为 TypeScript 认为它们没有初始化。</p>
<p>这时就可以使用非空断言，表示这两个属性肯定会有值，这样就不会报错了。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Point {
</span></span><span style="display:flex;"><span>  x<span style="color:#000;font-weight:bold">!:</span><span style="color:#458;font-weight:bold">number</span>; <span style="color:#998;font-style:italic">// 正确
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  y<span style="color:#000;font-weight:bold">!:</span><span style="color:#458;font-weight:bold">number</span>; <span style="color:#998;font-style:italic">// 正确
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">constructor</span>(x:<span style="color:#458;font-weight:bold">number</span>, y:<span style="color:#458;font-weight:bold">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>另外，非空断言只有在打开编译选项<code>strictNullChecks</code>时才有意义。如果不打开这个选项，编译器就不会检查某个变量是否可能为<code>undefined</code>或<code>null</code>。</p>
<h2 id="断言函数">断言函数</h2>
<p>断言函数是一种特殊函数，用于保证函数参数符合某种类型。如果函数参数达不到要求，就会抛出错误，中断程序执行；如果达到要求，就不进行任何操作，让代码按照正常流程运行。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> isString(value:<span style="color:#458;font-weight:bold">unknown</span>)<span style="color:#000;font-weight:bold">:</span><span style="color:#000;font-weight:bold">void</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">typeof</span> value <span style="color:#000;font-weight:bold">!==</span> <span style="color:#d14">&#39;string&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">throw</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Error</span>(<span style="color:#d14">&#39;Not a string&#39;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，函数<code>isString()</code>就是一个断言函数，用来保证参数<code>value</code>是一个字符串，否则就会抛出错误，中断程序的执行。</p>
<p>下面是它的用法。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> toUpper(x: <span style="color:#458;font-weight:bold">string</span><span style="color:#000;font-weight:bold">|</span><span style="color:#458;font-weight:bold">number</span>) {
</span></span><span style="display:flex;"><span>  isString(x);
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> x.toUpperCase();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，函数<code>toUpper()</code>的参数<code>x</code>，可能是字符串，也可能是数值。但是，函数体的最后一行调用<code>toUpperCase()</code>方法，必须保证<code>x</code>是字符串，否则报错。所以，这一行前面调用断言函数<code>isString()</code>，调用以后 TypeScript 就能确定，变量<code>x</code>一定是字符串，不是数值，也就不报错了。</p>
<p>传统的断言函数<code>isString()</code>的写法有一个缺点，它的参数类型是<code>unknown</code>，返回值类型是<code>void</code>（即没有返回值）。单单从这样的类型声明，很难看出<code>isString()</code>是一个断言函数。</p>
<p>为了更清晰地表达断言函数，TypeScript 3.7 引入了新的类型写法。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> isString(value:<span style="color:#458;font-weight:bold">unknown</span>)<span style="color:#000;font-weight:bold">:</span><span style="color:#000;font-weight:bold">asserts</span> value <span style="color:#000;font-weight:bold">is</span> <span style="color:#458;font-weight:bold">string</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">typeof</span> value <span style="color:#000;font-weight:bold">!==</span> <span style="color:#d14">&#39;string&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">throw</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Error</span>(<span style="color:#d14">&#39;Not a string&#39;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，函数<code>isString()</code>的返回值类型写成<code>asserts value is string</code>，其中<code>asserts</code>和<code>is</code>都是关键词，<code>value</code>是函数的参数名，<code>string</code>是函数参数的预期类型。它的意思是，该函数用来断言参数<code>value</code>的类型是<code>string</code>，如果达不到要求，程序就会在这里中断。</p>
<p>使用了断言函数的新写法以后，TypeScript 就会自动识别，只要执行了该函数，对应的变量都为断言的类型。</p>
<p>注意，函数返回值的断言写法，只是用来更清晰地表达函数意图，真正的检查是需要开发者自己部署的。而且，如果内部的检查与断言不一致，TypeScript 也不会报错。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> isString(value:<span style="color:#458;font-weight:bold">unknown</span>)<span style="color:#000;font-weight:bold">:</span><span style="color:#000;font-weight:bold">asserts</span> value <span style="color:#000;font-weight:bold">is</span> <span style="color:#458;font-weight:bold">string</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">typeof</span> value <span style="color:#000;font-weight:bold">!==</span> <span style="color:#d14">&#39;number&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">throw</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Error</span>(<span style="color:#d14">&#39;Not a number&#39;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，函数的断言是参数<code>value</code>类型为字符串，但是实际上，内部检查的却是它是否为数值，如果不是就抛错。这段代码能够正常通过编译，表示 TypeScript 并不会检查断言与实际的类型检查是否一致。</p>
<p>另外，断言函数的<code>asserts</code>语句等同于<code>void</code>类型，所以如果返回除了<code>undefined</code>和<code>null</code>以外的值，都会报错。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> isString(value:<span style="color:#458;font-weight:bold">unknown</span>)<span style="color:#000;font-weight:bold">:</span><span style="color:#000;font-weight:bold">asserts</span> value <span style="color:#000;font-weight:bold">is</span> <span style="color:#458;font-weight:bold">string</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">typeof</span> value <span style="color:#000;font-weight:bold">!==</span> <span style="color:#d14">&#39;string&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">throw</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Error</span>(<span style="color:#d14">&#39;Not a string&#39;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">true</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>上面示例中，断言函数返回了<code>true</code>，导致报错。</p>
<p>下面是另一个例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> AccessLevel <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;r&#39;</span> <span style="color:#000;font-weight:bold">|</span> <span style="color:#d14">&#39;w&#39;</span> <span style="color:#000;font-weight:bold">|</span> <span style="color:#d14">&#39;rw&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> allowsReadAccess(
</span></span><span style="display:flex;"><span>  level:<span style="color:#458;font-weight:bold">AccessLevel</span>
</span></span><span style="display:flex;"><span>)<span style="color:#000;font-weight:bold">:</span><span style="color:#000;font-weight:bold">asserts</span> level <span style="color:#000;font-weight:bold">is</span> <span style="color:#d14">&#39;r&#39;</span> <span style="color:#000;font-weight:bold">|</span> <span style="color:#d14">&#39;rw&#39;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>level.includes(<span style="color:#d14">&#39;r&#39;</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">throw</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Error</span>(<span style="color:#d14">&#39;Read not allowed&#39;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，函数<code>allowsReadAccess()</code>用来断言参数<code>level</code>一定等于<code>r</code>或<code>rw</code>。</p>
<p>如果要断言参数非空，可以使用工具类型<code>NonNullable&lt;T&gt;</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> assertIsDefined&lt;<span style="color:#000080">T</span>&gt;(
</span></span><span style="display:flex;"><span>  value:<span style="color:#458;font-weight:bold">T</span>
</span></span><span style="display:flex;"><span>)<span style="color:#000;font-weight:bold">:</span><span style="color:#000;font-weight:bold">asserts</span> value <span style="color:#000;font-weight:bold">is</span> NonNullable&lt;<span style="color:#000080">T</span>&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">if</span> (value <span style="color:#000;font-weight:bold">===</span> <span style="color:#000;font-weight:bold">undefined</span> <span style="color:#000;font-weight:bold">||</span> value <span style="color:#000;font-weight:bold">===</span> <span style="color:#000;font-weight:bold">null</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">throw</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Error</span>(<span style="color:#d14">`</span><span style="color:#d14">${</span>value<span style="color:#d14">}</span><span style="color:#d14"> is not defined`</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，工具类型<code>NonNullable&lt;T&gt;</code>对应类型<code>T</code>去除空类型后的剩余类型。</p>
<p>如果要将断言函数用于函数表达式，可以采用下面的写法。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 写法一
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> assertIsNumber <span style="color:#000;font-weight:bold">=</span> (
</span></span><span style="display:flex;"><span>  value:<span style="color:#458;font-weight:bold">unknown</span>
</span></span><span style="display:flex;"><span>)<span style="color:#000;font-weight:bold">:</span><span style="color:#000;font-weight:bold">asserts</span> value <span style="color:#000;font-weight:bold">is</span> <span style="color:#458;font-weight:bold">number</span> <span style="color:#000;font-weight:bold">=&gt;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">typeof</span> value <span style="color:#000;font-weight:bold">!==</span> <span style="color:#d14">&#39;number&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">throw</span> <span style="color:#0086b3">Error</span>(<span style="color:#d14">&#39;Not a number&#39;</span>);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 写法二
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">type</span> AssertIsNumber <span style="color:#000;font-weight:bold">=</span>
</span></span><span style="display:flex;"><span>  (value:<span style="color:#458;font-weight:bold">unknown</span>) <span style="color:#000;font-weight:bold">=&gt;</span> <span style="color:#000;font-weight:bold">asserts</span> value <span style="color:#000;font-weight:bold">is</span> <span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> assertIsNumber:<span style="color:#458;font-weight:bold">AssertIsNumber</span> <span style="color:#000;font-weight:bold">=</span> (value) <span style="color:#000;font-weight:bold">=&gt;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">typeof</span> value <span style="color:#000;font-weight:bold">!==</span> <span style="color:#d14">&#39;number&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">throw</span> <span style="color:#0086b3">Error</span>(<span style="color:#d14">&#39;Not a number&#39;</span>);
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>注意，断言函数与类型保护函数（type guard）是两种不同的函数。它们的区别是，断言函数不返回值，而类型保护函数总是返回一个布尔值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> isString(
</span></span><span style="display:flex;"><span>  value:<span style="color:#458;font-weight:bold">unknown</span>
</span></span><span style="display:flex;"><span>)<span style="color:#000;font-weight:bold">:</span>value <span style="color:#000;font-weight:bold">is</span> <span style="color:#458;font-weight:bold">string</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">typeof</span> value <span style="color:#000;font-weight:bold">===</span> <span style="color:#d14">&#39;string&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例就是一个类型保护函数<code>isString()</code>，作用是检查参数<code>value</code>是否为字符串。如果是的，返回<code>true</code>，否则返回<code>false</code>。该函数的返回值类型是<code>value is string</code>，其中的<code>is</code>是一个类型运算符，如果左侧的值符合右侧的类型，则返回<code>true</code>，否则返回<code>false</code>。</p>
<p>如果要断言某个参数保证为真（即不等于<code>false</code>、<code>undefined</code>和<code>null</code>），TypeScript 提供了断言函数的一种简写形式。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> assert(x:<span style="color:#458;font-weight:bold">unknown</span>)<span style="color:#000;font-weight:bold">:</span><span style="color:#000;font-weight:bold">asserts</span> x {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>上面示例中，函数<code>assert()</code>的断言部分，<code>asserts x</code>省略了谓语和宾语，表示参数<code>x</code>保证为真（<code>true</code>）。</p>
<p>同样的，参数为真的实际检查需要开发者自己实现。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> assert(x:<span style="color:#458;font-weight:bold">unknown</span>)<span style="color:#000;font-weight:bold">:</span><span style="color:#000;font-weight:bold">asserts</span> x {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>x) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">throw</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Error</span>(<span style="color:#d14">`</span><span style="color:#d14">${</span>x<span style="color:#d14">}</span><span style="color:#d14"> should be a truthy value.`</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这种断言函数的简写形式，通常用来检查某个操作是否成功。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> Person <span style="color:#000;font-weight:bold">=</span> {
</span></span><span style="display:flex;"><span>  name: <span style="color:#458;font-weight:bold">string</span>;
</span></span><span style="display:flex;"><span>  email?: <span style="color:#458;font-weight:bold">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> loadPerson()<span style="color:#000;font-weight:bold">:</span> Person <span style="color:#000;font-weight:bold">|</span> <span style="color:#000;font-weight:bold">null</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">null</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> person <span style="color:#000;font-weight:bold">=</span> loadPerson();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> assert(
</span></span><span style="display:flex;"><span>  condition: <span style="color:#458;font-weight:bold">unknown</span>,
</span></span><span style="display:flex;"><span>  message: <span style="color:#458;font-weight:bold">string</span>
</span></span><span style="display:flex;"><span>)<span style="color:#000;font-weight:bold">:</span><span style="color:#000;font-weight:bold">asserts</span> condition {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>condition) <span style="color:#000;font-weight:bold">throw</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Error</span>(message);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Error: Person is not defined
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>assert(person, <span style="color:#d14">&#39;Person is not defined&#39;</span>); 
</span></span><span style="display:flex;"><span>console.log(person.name);
</span></span></code></pre></div><p>上面示例中，只有<code>loadPerson()</code>返回结果为真（即操作成功），<code>assert()</code>才不会报错。</p>

        </div>

        
<div class="post-archive">
    <ul class="post-copyright">
        <li><strong>Author: </strong><a rel="author" href="http://shansec.github.io">未来可期</a></li>
        <li style="word-break:break-all"><strong>Link: </strong><a href="http://shansec.github.io/post/ts/Typescript-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/">http://shansec.github.io/post/ts/Typescript-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/</a></li>
        <li><strong>License: </strong>This work is under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>. Kindly fulfill the requirements of the aforementioned License when adapting or creating a derivative of this work.</li>
    </ul>
</div>
<br/>



        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/post/ts/Typescript-Enum%E7%B1%BB%E5%9E%8B/">Typescript Enum类型</a></li>
        
        <li><a href="/post/ts/Typescript-%E6%B3%9B%E5%9E%8B/">Typescript 泛型</a></li>
        
        <li><a href="/post/ts/Typescript-class%E7%B1%BB%E5%9E%8B/">Typescript Class类型</a></li>
        
        <li><a href="/post/ts/Typescript-interface/">Typescript Interface</a></li>
        
        <li><a href="/post/ts/typescript-%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B/">Typescript 函数类型</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='/tags/typescript' target="_blank">typescript</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "your github repo"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
    
    

</div>

                    <footer id="footer">
    <div>
        &copy; 2024 <a href="http://shansec.github.io">未来可期的博客 By 未来可期</a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>
<style type="text/css">
div.highlight {
    position: relative;
    margin: 1em 0px;
}

.copy-code {
    display: none;
    position: absolute;
    top: 4px;
    right: 4px;
    color: rgba(255, 255, 255, 0.8);
    background: rgba(78, 78, 78, 0.8);
    border-radius: var(--radius);
    padding: 0 5px;
    font: inherit;
    user-select: none;
    cursor: pointer;
    border: 0;
    --radius: 8px;
}

div.highlight:hover .copy-code,pre:hover .copy-code {
    display: block;
}

</style>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>


    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




    <script src='/js/douban.js'></script>

                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='http://shansec.github.io/search' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="http://shansec.github.io">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>

    <section class="widget">
        <h3 class="widget-title">Latest articles</h3>
<ul class="widget-list">
    
    <li>
        <a href="http://shansec.github.io/post/ts/Typescript-%E6%B3%A8%E9%87%8A%E6%8C%87%E4%BB%A4/" title="Typescript 注释指令" target="_blank">Typescript 注释指令</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/Typescript-%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7/" title="Typescript 类型工具" target="_blank">Typescript 类型工具</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/Typescript-%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84/" title="Typescript 类型映射" target="_blank">Typescript 类型映射</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/Typescript-%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%E7%AC%A6/" title="Typescript 类型运算符" target="_blank">Typescript 类型运算符</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/Typescript-%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6/" title="Typescript 类型声明文件" target="_blank">Typescript 类型声明文件</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/Typescript-declare%E5%85%B3%E9%94%AE%E5%AD%97/" title="Typescript Declare关键字" target="_blank">Typescript Declare关键字</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/Typescript-%E6%A8%A1%E5%9D%97/" title="Typescript 模块" target="_blank">Typescript 模块</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/Typescript-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/" title="Typescript 类型断言" target="_blank">Typescript 类型断言</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/Typescript-Enum%E7%B1%BB%E5%9E%8B/" title="Typescript Enum类型" target="_blank">Typescript Enum类型</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/Typescript-%E6%B3%9B%E5%9E%8B/" title="Typescript 泛型" target="_blank">Typescript 泛型</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href='/categories/'>Categories</a></h3>
<ul class="widget-list">
    
    <li><a href="http://shansec.github.io/categories/go/">go (43)</a></li>
    
    <li><a href="http://shansec.github.io/categories/%E5%89%8D%E7%AB%AF/">前端 (71)</a></li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href='/tags/'>Tags</a></h3>
<div class="tagcloud">
    
    <a href="http://shansec.github.io/tags/CSS/">CSS</a>
    
    <a href="http://shansec.github.io/tags/HTTP/">HTTP</a>
    
    <a href="http://shansec.github.io/tags/javaScript/">javaScript</a>
    
    <a href="http://shansec.github.io/tags/CSS/">CSS</a>
    
    <a href="http://shansec.github.io/tags/docker/">docker</a>
    
    <a href="http://shansec.github.io/tags/es6/">es6</a>
    
    <a href="http://shansec.github.io/tags/go/">go</a>
    
    <a href="http://shansec.github.io/tags/go-%E5%9F%BA%E7%A1%80/">go 基础</a>
    
    <a href="http://shansec.github.io/tags/go-%E6%A0%87%E5%87%86%E5%BA%93/">go 标准库</a>
    
    <a href="http://shansec.github.io/tags/javaScript/">javaScript</a>
    
    <a href="http://shansec.github.io/tags/jwt/">jwt</a>
    
    <a href="http://shansec.github.io/tags/package/">package</a>
    
    <a href="http://shansec.github.io/tags/pinia/">pinia</a>
    
    <a href="http://shansec.github.io/tags/redis/">redis</a>
    
    <a href="http://shansec.github.io/tags/sql/">sql</a>
    
    <a href="http://shansec.github.io/tags/sqlx/">sqlx</a>
    
    <a href="http://shansec.github.io/tags/typescript/">typescript</a>
    
    <a href="http://shansec.github.io/tags/vue/">vue</a>
    
    <a href="http://shansec.github.io/tags/%E5%AD%98%E5%82%A8/">存储</a>
    
    <a href="http://shansec.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">微信小程序</a>
    
    <a href="http://shansec.github.io/tags/%E6%A0%87%E5%87%86%E5%BA%93/">标准库</a>
    
    <a href="http://shansec.github.io/tags/%E6%A1%86%E6%9E%B6/">框架</a>
    
    <a href="http://shansec.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/">计算机原理</a>
    
</div>
    </section>

    
<section class="widget">
    <h3 class="widget-title">Links</h3>
    <ul class="widget-list">
        
        <li>
            <a target="_blank" href="https://www.liwenzhou.com/" title="李文周的博客">李文周的博客</a>
        </li>
        
    </ul>
</section>


    <section class="widget">
        <h3 class="widget-title">Meta</h3>
        <ul class="widget-list">
            <li><a href="http://shansec.github.io/index.xml">RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>