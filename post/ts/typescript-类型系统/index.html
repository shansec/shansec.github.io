<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <meta name="referrer" content="no-referrer-when-downgrade">
    

    <title>Typescript 类型系统 | 未来可期的博客</title>
    <meta property="og:title" content="Typescript 类型系统 - 未来可期的博客">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2024-06-22T11:16:19&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2024-06-22T11:16:19&#43;08:00'>
        
    <meta name="Keywords" content="golang,go语言,go语言笔记,未来可期,博客,公众号,小程序">
    <meta name="description" content="Typescript 类型系统">
        
    <meta name="author" content="未来可期">
    <meta property="og:url" content="http://shansec.github.io/post/ts/typescript-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/">
    <link rel="shortcut icon" href='/favicon.ico'  type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
        <link rel="stylesheet" href='/css/douban.css'>
    
        <link rel="stylesheet" href='/css/other.css'>
    
</head>

<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="http://shansec.github.io">
                        未来可期的博客
                    </a>
                
                <p class="description">专注于Go语言(golang)、前端技术</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="http://shansec.github.io">Home</a>
                    
                    <a  href="http://shansec.github.io/archives/" title="归档">归档</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    <style type="text/css">
    .post-toc {
        position: fixed;
        width: 200px;
        margin-left: -210px;
        padding: 5px 10px;
        font-family: Athelas, STHeiti, Microsoft Yahei, serif;
        font-size: 12px;
        border: 1px solid rgba(0, 0, 0, .07);
        border-radius: 5px;
        background-color: rgba(255, 255, 255, 0.98);
        background-clip: padding-box;
        -webkit-box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        word-wrap: break-word;
        white-space: nowrap;
        -webkit-box-sizing: border-box;
        box-sizing: border-box;
        z-index: 999;
        cursor: pointer;
        max-height: 70%;
        overflow-y: auto;
        overflow-x: hidden;
    }

    .post-toc .post-toc-title {
        width: 100%;
        margin: 0 auto;
        font-size: 20px;
        font-weight: 400;
        text-transform: uppercase;
        text-align: center;
    }

    .post-toc .post-toc-content {
        font-size: 15px;
    }

    .post-toc .post-toc-content>nav>ul {
        margin: 10px 0;
    }

    .post-toc .post-toc-content ul {
        padding-left: 20px;
        list-style: square;
        margin: 0.5em;
        line-height: 1.8em;
    }

    .post-toc .post-toc-content ul ul {
        padding-left: 15px;
        display: none;
    }

    @media print,
    screen and (max-width:1057px) {
        .post-toc {
            display: none;
        }
    }
</style>
<div class="post-toc" style="position: absolute; top: 188px;">
    <h2 class="post-toc-title">Table of Contents</h2>
    <div class="post-toc-content">
        <nav id="TableOfContents">
  <ul>
    <li><a href="#基本类型">基本类型</a>
      <ul>
        <li><a href="#概述">概述</a></li>
        <li><a href="#boolean-类型">boolean 类型</a></li>
        <li><a href="#string-类型">string 类型</a></li>
        <li><a href="#number-类型">number 类型</a></li>
        <li><a href="#bigint-类型">bigint 类型</a></li>
        <li><a href="#symbol-类型">symbol 类型</a></li>
        <li><a href="#object-类型">object 类型</a></li>
        <li><a href="#undefined-类型null-类型">undefined 类型，null 类型</a></li>
      </ul>
    </li>
    <li><a href="#包装对象类型">包装对象类型</a>
      <ul>
        <li><a href="#包装对象的概念">包装对象的概念</a></li>
        <li><a href="#包装对象类型与字面量类型">包装对象类型与字面量类型</a></li>
      </ul>
    </li>
    <li><a href="#object-类型与-object-类型">Object 类型与 object 类型</a>
      <ul>
        <li><a href="#object-类型-1">Object 类型</a></li>
        <li><a href="#object-类型-2">object 类型</a></li>
      </ul>
    </li>
    <li><a href="#undefined-和-null-的特殊性">undefined 和 null 的特殊性</a></li>
    <li><a href="#值类型">值类型</a></li>
    <li><a href="#联合类型">联合类型</a></li>
    <li><a href="#交叉类型">交叉类型</a></li>
    <li><a href="#type-命令">type 命令</a></li>
    <li><a href="#typeof-运算符">typeof 运算符</a></li>
    <li><a href="#块级类型声明">块级类型声明</a></li>
    <li><a href="#类型的兼容">类型的兼容</a></li>
  </ul>
</nav>
    </div>
</div>
<script type="text/javascript">
    $(document).ready(function () {
        var postToc = $(".post-toc");
        if (postToc.length) {
            var leftPos = $("#main").offset().left;
            if (leftPos < 220) {
                postToc.css({ "width": leftPos - 10, "margin-left": (0 - leftPos) })
            }

            var t = postToc.offset().top - 20,
                a = {
                    start: {
                        position: "absolute",
                        top: t
                    },
                    process: {
                        position: "fixed",
                        top: 20
                    },
                };
            $(window).scroll(function () {
                var e = $(window).scrollTop();
                e < t ? postToc.css(a.start) : postToc.css(a.process)
            })
        }

        if ($("#TableOfContents").children().length < 1) {
            $(".post-toc").remove();
        }
    })
</script>
    <article class="post">
        <header>
            <h1 class="post-title">Typescript 类型系统</h1>
        </header>
        
  <time datetime="2024-06-22T03:16:19Z" class="post-meta meta-date dt-published">
    2024-06-22
  </time>


<div class="post-meta meta-category">
  <span>&nbsp;|</span>
  
    <a href='/categories/%E5%89%8D%E7%AB%AF' target="_blank">前端</a>
  
</div>


        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">&nbsp;|
                <span id="busuanzi_value_page_pv"></span> <span>reads</span>
            </span>
        </div>
        
        
        <div class="post-content">
            <p>TypeScript 继承了 JavaScript 的类型，在这个基础上，定义了一套自己的类型系统。</p>
<h2 id="基本类型">基本类型</h2>
<h3 id="概述">概述</h3>
<p>JavaScript 语言（注意，不是 TypeScript）将值分成8种类型。</p>
<ul>
<li>boolean</li>
<li>string</li>
<li>number</li>
<li>bigint</li>
<li>symbol</li>
<li>object</li>
<li>undefined</li>
<li>null</li>
</ul>
<p>TypeScript 继承了 JavaScript 的类型设计，以上8种类型可以看作 TypeScript 的基本类型。</p>
<p>注意，上面所有类型的名称都是小写字母，首字母大写的<code>Number</code>、<code>String</code>、<code>Boolean</code>等在 JavaScript 语言中都是内置对象，而不是类型名称。</p>
<p>另外，undefined 和 null 既可以作为值，也可以作为类型，取决于在哪里使用它们。</p>
<p>这8种基本类型是 TypeScript 类型系统的基础，复杂类型由它们组合而成。</p>
<p>以下是它们的简单介绍。</p>
<h3 id="boolean-类型">boolean 类型</h3>
<p><code>boolean</code>类型只包含<code>true</code>和<code>false</code>两个布尔值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> x:<span style="color:#458;font-weight:bold">boolean</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">true</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> y:<span style="color:#458;font-weight:bold">boolean</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">false</span>;
</span></span></code></pre></div><p>上面示例中，变量<code>x</code>和<code>y</code>就属于 boolean 类型。</p>
<h3 id="string-类型">string 类型</h3>
<p><code>string</code>类型包含所有字符串。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> x:<span style="color:#458;font-weight:bold">string</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;hello&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> y:<span style="color:#458;font-weight:bold">string</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">`</span><span style="color:#d14">${</span>x<span style="color:#d14">}</span><span style="color:#d14"> world`</span>;
</span></span></code></pre></div><p>上面示例中，普通字符串和模板字符串都属于 string 类型。</p>
<h3 id="number-类型">number 类型</h3>
<p><code>number</code>类型包含所有整数和浮点数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> x:<span style="color:#458;font-weight:bold">number</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">123</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> y:<span style="color:#458;font-weight:bold">number</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">3.14</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> z:<span style="color:#458;font-weight:bold">number</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0xffff</span>;
</span></span></code></pre></div><p>上面示例中，整数、浮点数和非十进制数都属于 number 类型。</p>
<h3 id="bigint-类型">bigint 类型</h3>
<p>bigint 类型包含所有的大整数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> x:<span style="color:#458;font-weight:bold">bigint</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">123</span>n;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> y:<span style="color:#458;font-weight:bold">bigint</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0xffff</span>n;
</span></span></code></pre></div><p>上面示例中，变量<code>x</code>和<code>y</code>就属于 bigint 类型。</p>
<p>bigint 与 number 类型不兼容。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> x:<span style="color:#458;font-weight:bold">bigint</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">123</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> y:<span style="color:#458;font-weight:bold">bigint</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">3.14</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，<code>bigint</code>类型赋值为整数和小数，都会报错。</p>
<p>注意，bigint 类型是 ES2020 标准引入的。如果使用这个类型，TypeScript 编译的目标 JavaScript 版本不能低于 ES2020（即编译参数<code>target</code>不低于<code>es2020</code>）。</p>
<h3 id="symbol-类型">symbol 类型</h3>
<p>symbol 类型包含所有的 Symbol 值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> x:<span style="color:#458;font-weight:bold">symbol</span> <span style="color:#000;font-weight:bold">=</span> Symbol();
</span></span></code></pre></div><p>上面示例中，<code>Symbol()</code>函数的返回值就是 symbol 类型。</p>
<p>symbol 类型的详细介绍，参见《Symbol》一章。</p>
<h3 id="object-类型">object 类型</h3>
<p>根据 JavaScript 的设计，object 类型包含了所有对象、数组和函数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> x:<span style="color:#458;font-weight:bold">object</span> <span style="color:#000;font-weight:bold">=</span> { foo: <span style="color:#458;font-weight:bold">123</span> };
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> y:<span style="color:#458;font-weight:bold">object</span> <span style="color:#000;font-weight:bold">=</span> [<span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>];
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> z:<span style="color:#458;font-weight:bold">object</span> <span style="color:#000;font-weight:bold">=</span> (n:<span style="color:#458;font-weight:bold">number</span>) <span style="color:#000;font-weight:bold">=&gt;</span> n <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>;
</span></span></code></pre></div><p>上面示例中，对象、数组、函数都属于 object 类型。</p>
<h3 id="undefined-类型null-类型">undefined 类型，null 类型</h3>
<p>undefined 和 null 是两种独立类型，它们各自都只有一个值。</p>
<p>undefined 类型只包含一个值<code>undefined</code>，表示未定义（即还未给出定义，以后可能会有定义）。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> x:<span style="color:#458;font-weight:bold">undefined</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">undefined</span>;
</span></span></code></pre></div><p>上面示例中，变量<code>x</code>就属于 undefined 类型。两个<code>undefined</code>里面，第一个是类型，第二个是值。</p>
<p>null 类型也只包含一个值<code>null</code>，表示为空（即此处没有值）。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> x:<span style="color:#458;font-weight:bold">null</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">null</span>;
</span></span></code></pre></div><p>上面示例中，变量<code>x</code>就属于 null 类型。</p>
<p>注意，如果没有声明类型的变量，被赋值为<code>undefined</code>或<code>null</code>，在关闭编译设置<code>noImplicitAny</code>和<code>strictNullChecks</code>时，它们的类型会被推断为<code>any</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 关闭 noImplicitAny 和 strictNullChecks
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> a <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">undefined</span>;   <span style="color:#998;font-style:italic">// any
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> b <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">undefined</span>; <span style="color:#998;font-style:italic">// any
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> c <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">null</span>;        <span style="color:#998;font-style:italic">// any
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> d <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">null</span>;      <span style="color:#998;font-style:italic">// any
</span></span></span></code></pre></div><p>如果希望避免这种情况，则需要打开编译选项<code>strictNullChecks</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 打开编译设置 strictNullChecks
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> a <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">undefined</span>;   <span style="color:#998;font-style:italic">// undefined
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> b <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">undefined</span>; <span style="color:#998;font-style:italic">// undefined
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> c <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">null</span>;        <span style="color:#998;font-style:italic">// null
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> d <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">null</span>;      <span style="color:#998;font-style:italic">// null
</span></span></span></code></pre></div><p>上面示例中，打开编译设置<code>strictNullChecks</code>以后，赋值为<code>undefined</code>的变量会被推断为<code>undefined</code>类型，赋值为<code>null</code>的变量会被推断为<code>null</code>类型。</p>
<h2 id="包装对象类型">包装对象类型</h2>
<h3 id="包装对象的概念">包装对象的概念</h3>
<p>JavaScript 的8种类型之中，<code>undefined</code>和<code>null</code>其实是两个特殊值，<code>object</code>属于复合类型，剩下的五种属于原始类型（primitive value），代表最基本的、不可再分的值。</p>
<ul>
<li>boolean</li>
<li>string</li>
<li>number</li>
<li>bigint</li>
<li>symbol</li>
</ul>
<p>上面这五种原始类型的值，都有对应的包装对象（wrapper object）。所谓“包装对象”，指的是这些值在需要时，会自动产生的对象。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#d14">&#39;hello&#39;</span>.charAt(<span style="color:#099">1</span>) <span style="color:#998;font-style:italic">// &#39;e&#39;
</span></span></span></code></pre></div><p>上面示例中，字符串<code>hello</code>执行了<code>charAt()</code>方法。但是，在 JavaScript 语言中，只有对象才有方法，原始类型的值本身没有方法。这行代码之所以可以运行，就是因为在调用方法时，字符串会自动转为包装对象，<code>charAt()</code>方法其实是定义在包装对象上。</p>
<p>这样的设计大大方便了字符串处理，省去了将原始类型的值手动转成对象实例的麻烦。</p>
<p>五种包装对象之中，symbol 类型和 bigint 类型无法直接获取它们的包装对象（即<code>Symbol()</code>和<code>BigInt()</code>不能作为构造函数使用），但是剩下三种可以。</p>
<ul>
<li><code>Boolean()</code></li>
<li><code>String()</code></li>
<li><code>Number()</code></li>
</ul>
<p>以上三个构造函数，执行后可以直接获取某个原始类型值的包装对象。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> s <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">String</span>(<span style="color:#d14">&#39;hello&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">typeof</span> s <span style="color:#998;font-style:italic">// &#39;object&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>s.charAt(<span style="color:#099">1</span>) <span style="color:#998;font-style:italic">// &#39;e&#39;
</span></span></span></code></pre></div><p>上面示例中，<code>s</code>就是字符串<code>hello</code>的包装对象，<code>typeof</code>运算符返回<code>object</code>，不是<code>string</code>，但是本质上它还是字符串，可以使用所有的字符串方法。</p>
<p>注意，<code>String()</code>只有当作构造函数使用时（即带有<code>new</code>命令调用），才会返回包装对象。如果当作普通函数使用（不带有<code>new</code>命令），返回就是一个普通字符串。其他两个构造函数<code>Number()</code>和<code>Boolean()</code>也是如此。</p>
<h3 id="包装对象类型与字面量类型">包装对象类型与字面量类型</h3>
<p>由于包装对象的存在，导致每一个原始类型的值都有包装对象和字面量两种情况。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#d14">&#39;hello&#39;</span> <span style="color:#998;font-style:italic">// 字面量
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">String</span>(<span style="color:#d14">&#39;hello&#39;</span>) <span style="color:#998;font-style:italic">// 包装对象
</span></span></span></code></pre></div><p>上面示例中，第一行是字面量，第二行是包装对象，它们都是字符串。</p>
<p>为了区分这两种情况，TypeScript 对五种原始类型分别提供了大写和小写两种类型。</p>
<ul>
<li>Boolean 和 boolean</li>
<li>String 和 string</li>
<li>Number 和 number</li>
<li>BigInt 和 bigint</li>
<li>Symbol 和 symbol</li>
</ul>
<p>其中，大写类型同时包含包装对象和字面量两种情况，小写类型只包含字面量，不包含包装对象。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> s1:<span style="color:#458;font-weight:bold">String</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;hello&#39;</span>; <span style="color:#998;font-style:italic">// 正确
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> s2:<span style="color:#458;font-weight:bold">String</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">String</span>(<span style="color:#d14">&#39;hello&#39;</span>); <span style="color:#998;font-style:italic">// 正确
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> s3:<span style="color:#458;font-weight:bold">string</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;hello&#39;</span>; <span style="color:#998;font-style:italic">// 正确
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> s4:<span style="color:#458;font-weight:bold">string</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">String</span>(<span style="color:#d14">&#39;hello&#39;</span>); <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，<code>String</code>类型可以赋值为字符串的字面量，也可以赋值为包装对象。但是，<code>string</code>类型只能赋值为字面量，赋值为包装对象就会报错。</p>
<p>**建议只使用小写类型，不使用大写类型。**因为绝大部分使用原始类型的场合，都是使用字面量，不使用包装对象。而且，TypeScript 把很多内置方法的参数，定义成小写类型，使用大写类型会报错。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> n1:<span style="color:#458;font-weight:bold">number</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> n2:<span style="color:#458;font-weight:bold">Number</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0086b3">Math</span>.abs(n1) <span style="color:#998;font-style:italic">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#0086b3">Math</span>.abs(n2) <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，<code>Math.abs()</code>方法的参数类型被定义成小写的<code>number</code>，传入大写的<code>Number</code>类型就会报错。</p>
<p>上一小节说过，<code>Symbol()</code>和<code>BigInt()</code>这两个函数不能当作构造函数使用，所以没有办法直接获得 symbol 类型和 bigint 类型的包装对象，除非使用下面的写法。但是，它们没有使用场景，因此<code>Symbol</code>和<code>BigInt</code>这两个类型虽然存在，但是完全没有使用的理由。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> a <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">Object</span>(Symbol());
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> b <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">Object</span>(BigInt());
</span></span></code></pre></div><p>上面示例中，得到的就是 Symbol 和 BigInt 的包装对象，但是没有使用的意义。</p>
<p>注意，目前在 TypeScript 里面，<code>symbol</code>和<code>Symbol</code>两种写法没有差异，<code>bigint</code>和<code>BigInt</code>也是如此，不知道是否属于官方的疏忽。建议始终使用小写的<code>symbol</code>和<code>bigint</code>，不使用大写的<code>Symbol</code>和<code>BigInt</code>。</p>
<h2 id="object-类型与-object-类型">Object 类型与 object 类型</h2>
<p>TypeScript 的对象类型也有大写<code>Object</code>和小写<code>object</code>两种。</p>
<h3 id="object-类型-1">Object 类型</h3>
<p>大写的<code>Object</code>类型代表 JavaScript 语言里面的广义对象。所有可以转成对象的值，都是<code>Object</code>类型，这囊括了几乎所有的值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> obj:<span style="color:#458;font-weight:bold">Object</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>obj <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">true</span>;
</span></span><span style="display:flex;"><span>obj <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;hi&#39;</span>;
</span></span><span style="display:flex;"><span>obj <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>obj <span style="color:#000;font-weight:bold">=</span> { foo: <span style="color:#458;font-weight:bold">123</span> };
</span></span><span style="display:flex;"><span>obj <span style="color:#000;font-weight:bold">=</span> [<span style="color:#099">1</span>, <span style="color:#099">2</span>];
</span></span><span style="display:flex;"><span>obj <span style="color:#000;font-weight:bold">=</span> (a:<span style="color:#458;font-weight:bold">number</span>) <span style="color:#000;font-weight:bold">=&gt;</span> a <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>;
</span></span></code></pre></div><p>上面示例中，原始类型值、对象、数组、函数都是合法的<code>Object</code>类型。</p>
<p>事实上，除了<code>undefined</code>和<code>null</code>这两个值不能转为对象，其他任何值都可以赋值给<code>Object</code>类型。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> obj:<span style="color:#458;font-weight:bold">Object</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>obj <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">undefined</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>obj <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">null</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，<code>undefined</code>和<code>null</code>赋值给<code>Object</code>类型，就会报错。</p>
<p>另外，空对象<code>{}</code>是<code>Object</code>类型的简写形式，所以使用<code>Object</code>时常常用空对象代替。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> obj<span style="color:#000;font-weight:bold">:</span>{};
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>obj <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">true</span>;
</span></span><span style="display:flex;"><span>obj <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;hi&#39;</span>;
</span></span><span style="display:flex;"><span>obj <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>obj <span style="color:#000;font-weight:bold">=</span> { foo<span style="color:#000;font-weight:bold">:</span> <span style="color:#099">123</span> };
</span></span><span style="display:flex;"><span>obj <span style="color:#000;font-weight:bold">=</span> [<span style="color:#099">1</span>, <span style="color:#099">2</span>];
</span></span><span style="display:flex;"><span>obj <span style="color:#000;font-weight:bold">=</span> (a<span style="color:#000;font-weight:bold">:</span>number) =&gt; a <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>;
</span></span></code></pre></div><p>上面示例中，变量<code>obj</code>的类型是空对象<code>{}</code>，就代表<code>Object</code>类型。</p>
<p>显然，无所不包的<code>Object</code>类型既不符合直觉，也不方便使用。</p>
<h3 id="object-类型-2">object 类型</h3>
<p>小写的<code>object</code>类型代表 JavaScript 里面的狭义对象，即可以用字面量表示的对象，只包含对象、数组和函数，不包括原始类型的值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> obj:<span style="color:#458;font-weight:bold">object</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>obj <span style="color:#000;font-weight:bold">=</span> { foo: <span style="color:#458;font-weight:bold">123</span> };
</span></span><span style="display:flex;"><span>obj <span style="color:#000;font-weight:bold">=</span> [<span style="color:#099">1</span>, <span style="color:#099">2</span>];
</span></span><span style="display:flex;"><span>obj <span style="color:#000;font-weight:bold">=</span> (a:<span style="color:#458;font-weight:bold">number</span>) <span style="color:#000;font-weight:bold">=&gt;</span> a <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>obj <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">true</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>obj <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;hi&#39;</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>obj <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，<code>object</code>类型不包含原始类型值，只包含对象、数组和函数。</p>
<p>大多数时候，我们使用对象类型，只希望包含真正的对象，不希望包含原始类型。所以，建议总是使用小写类型<code>object</code>，不使用大写类型<code>Object</code>。</p>
<p>注意，无论是大写的<code>Object</code>类型，还是小写的<code>object</code>类型，都只包含 JavaScript 内置对象原生的属性和方法，用户自定义的属性和方法都不存在于这两个类型之中。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> o1:<span style="color:#458;font-weight:bold">Object</span> <span style="color:#000;font-weight:bold">=</span> { foo: <span style="color:#458;font-weight:bold">0</span> };
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> o2:<span style="color:#458;font-weight:bold">object</span> <span style="color:#000;font-weight:bold">=</span> { foo: <span style="color:#458;font-weight:bold">0</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>o1.toString() <span style="color:#998;font-style:italic">// 正确
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>o1.foo <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>o2.toString() <span style="color:#998;font-style:italic">// 正确
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>o2.foo <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，<code>toString()</code>是对象的原生方法，可以正确访问。<code>foo</code>是自定义属性，访问就会报错。如何描述对象的自定义属性，详见《对象类型》一章。</p>
<h2 id="undefined-和-null-的特殊性">undefined 和 null 的特殊性</h2>
<p><code>undefined</code>和<code>null</code>既是值，又是类型。</p>
<p>作为值，它们有一个特殊的地方：任何其他类型的变量都可以赋值为<code>undefined</code>或<code>null</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> age:<span style="color:#458;font-weight:bold">number</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">24</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>age <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">null</span>;      <span style="color:#998;font-style:italic">// 正确
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>age <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">undefined</span>; <span style="color:#998;font-style:italic">// 正确
</span></span></span></code></pre></div><p>上面代码中，变量<code>age</code>的类型是<code>number</code>，但是赋值为<code>null</code>或<code>undefined</code>并不报错。</p>
<p>这并不是因为<code>undefined</code>和<code>null</code>包含在<code>number</code>类型里面，而是故意这样设计，任何类型的变量都可以赋值为<code>undefined</code>和<code>null</code>，以便跟 JavaScript 的行为保持一致。</p>
<p>JavaScript 的行为是，变量如果等于<code>undefined</code>就表示还没有赋值，如果等于<code>null</code>就表示值为空。所以，TypeScript 就允许了任何类型的变量都可以赋值为这两个值。</p>
<p>但是有时候，这并不是开发者想要的行为，也不利于发挥类型系统的优势。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> obj:<span style="color:#458;font-weight:bold">object</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">undefined</span>;
</span></span><span style="display:flex;"><span>obj.toString() <span style="color:#998;font-style:italic">// 编译不报错，运行就报错
</span></span></span></code></pre></div><p>上面示例中，变量<code>obj</code>等于<code>undefined</code>，编译不会报错。但是，实际执行时，调用<code>obj.toString()</code>就报错了，因为<code>undefined</code>不是对象，没有这个方法。</p>
<p>为了避免这种情况，及早发现错误，TypeScript 提供了一个编译选项<code>strictNullChecks</code>。只要打开这个选项，<code>undefined</code>和<code>null</code>就不能赋值给其他类型的变量（除了<code>any</code>类型和<code>unknown</code>类型）。</p>
<p>下面是 tsc 命令打开这个编译选项的例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// tsc --strictNullChecks app.ts
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> age:<span style="color:#458;font-weight:bold">number</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">24</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>age <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">null</span>;      <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>age <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">undefined</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，打开<code>--strictNullChecks</code>以后，<code>number</code>类型的变量<code>age</code>就不能赋值为<code>undefined</code>和<code>null</code>。</p>
<p>这个选项在配置文件<code>tsconfig.json</code>的写法如下。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#000080">&#34;compilerOptions&#34;</span>: {
</span></span><span style="display:flex;"><span>    <span style="color:#000080">&#34;strictNullChecks&#34;</span>: <span style="color:#000;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>打开<code>strictNullChecks</code>以后，<code>undefined</code>和<code>null</code>这两种值也不能互相赋值了。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 打开 strictNullChecks
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> x:<span style="color:#458;font-weight:bold">undefined</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">null</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">let</span> y:<span style="color:#458;font-weight:bold">null</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">undefined</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，<code>undefined</code>类型的变量赋值为<code>null</code>，或者<code>null</code>类型的变量赋值为<code>undefined</code>，都会报错。</p>
<p>总之，打开<code>strictNullChecks</code>以后，<code>undefined</code>和<code>null</code>只能赋值给自身，或者<code>any</code>类型和<code>unknown</code>类型的变量。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> x:<span style="color:#458;font-weight:bold">any</span>     <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> y:<span style="color:#458;font-weight:bold">unknown</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">null</span>;
</span></span></code></pre></div><h2 id="值类型">值类型</h2>
<p>TypeScript 规定，单个值也是一种类型，称为“值类型”。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> x<span style="color:#000;font-weight:bold">:</span><span style="color:#d14">&#39;hello&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;hello&#39;</span>; <span style="color:#998;font-style:italic">// 正确
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>x <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;world&#39;</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，变量<code>x</code>的类型是字符串<code>hello</code>，导致它只能赋值为这个字符串，赋值为其他字符串就会报错。</p>
<p><strong>TypeScript 推断类型时，遇到const命令声明的变量，如果代码里面没有注明类型，就会推断该变量是值类型。</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// x 的类型是 &#34;https&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> x <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;https&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// y 的类型是 string
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> y:<span style="color:#458;font-weight:bold">string</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;https&#39;</span>;
</span></span></code></pre></div><p>上面示例中，变量<code>x</code>是<code>const</code>命令声明的，TypeScript 就会推断它的类型是值<code>https</code>，而不是<code>string</code>类型。</p>
<p>这样推断是合理的，因为<code>const</code>命令声明的变量，一旦声明就不能改变，相当于常量。值类型就意味着不能赋为其他值。</p>
<p>注意，<code>const</code>命令声明的变量，如果赋值为对象，并不会推断为值类型。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// x 的类型是 { foo: number }
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> x <span style="color:#000;font-weight:bold">=</span> { foo: <span style="color:#458;font-weight:bold">1</span> };
</span></span></code></pre></div><p>上面示例中，变量<code>x</code>没有被推断为值类型，而是推断属性<code>foo</code>的类型是<code>number</code>。这是因为 JavaScript 里面，<code>const</code>变量赋值为对象时，属性值是可以改变的。</p>
<p>值类型可能会出现一些很奇怪的报错。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> x:<span style="color:#458;font-weight:bold">5</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">4</span> <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，等号左侧的类型是数值<code>5</code>，等号右侧<code>4 + 1</code>的类型，TypeScript 推测为<code>number</code>。由于<code>5</code>是<code>number</code>的子类型，<code>number</code>是<code>5</code>的父类型，父类型不能赋值给子类型，所以报错了（详见本章后文）。</p>
<p>但是，反过来是可以的，子类型可以赋值给父类型。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> x:<span style="color:#458;font-weight:bold">5</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">5</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> y:<span style="color:#458;font-weight:bold">number</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">4</span> <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x <span style="color:#000;font-weight:bold">=</span> y; <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>y <span style="color:#000;font-weight:bold">=</span> x; <span style="color:#998;font-style:italic">// 正确
</span></span></span></code></pre></div><p>上面示例中，变量<code>x</code>属于子类型，变量<code>y</code>属于父类型。子类型<code>x</code>不能赋值为父类型<code>y</code>，但是反过来是可以的。</p>
<p>如果一定要让子类型可以赋值为父类型的值，就要用到类型断言（详见《类型断言》一章）。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> x:<span style="color:#458;font-weight:bold">5</span> <span style="color:#000;font-weight:bold">=</span> (<span style="color:#099">4</span> <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>) <span style="color:#000;font-weight:bold">as</span> <span style="color:#099">5</span>; <span style="color:#998;font-style:italic">// 正确
</span></span></span></code></pre></div><p>上面示例中，在<code>4 + 1</code>后面加上<code>as 5</code>，就是告诉编译器，可以把<code>4 + 1</code>的类型视为值类型<code>5</code>，这样就不会报错了。</p>
<p>只包含单个值的值类型，用处不大。实际开发中，往往将多个值结合，作为联合类型使用。</p>
<h2 id="联合类型">联合类型</h2>
<p>联合类型（union types）指的是多个类型组成的一个新类型，使用符号<code>|</code>表示。</p>
<p>联合类型<code>A|B</code>表示，任何一个类型只要属于<code>A</code>或<code>B</code>，就属于联合类型<code>A|B</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> x:<span style="color:#458;font-weight:bold">string</span><span style="color:#000;font-weight:bold">|</span><span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">123</span>; <span style="color:#998;font-style:italic">// 正确
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>x <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;abc&#39;</span>; <span style="color:#998;font-style:italic">// 正确
</span></span></span></code></pre></div><p>上面示例中，变量<code>x</code>就是联合类型<code>string|number</code>，表示它的值既可以是字符串，也可以是数值。</p>
<p>联合类型可以与值类型相结合，表示一个变量的值有若干种可能。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> setting:<span style="color:#458;font-weight:bold">true</span><span style="color:#000;font-weight:bold">|</span><span style="color:#000;font-weight:bold">false</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> gender<span style="color:#000;font-weight:bold">:</span><span style="color:#d14">&#39;male&#39;</span><span style="color:#000;font-weight:bold">|</span><span style="color:#d14">&#39;female&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> rainbowColor<span style="color:#000;font-weight:bold">:</span><span style="color:#d14">&#39;赤&#39;</span><span style="color:#000;font-weight:bold">|</span><span style="color:#d14">&#39;橙&#39;</span><span style="color:#000;font-weight:bold">|</span><span style="color:#d14">&#39;黄&#39;</span><span style="color:#000;font-weight:bold">|</span><span style="color:#d14">&#39;绿&#39;</span><span style="color:#000;font-weight:bold">|</span><span style="color:#d14">&#39;青&#39;</span><span style="color:#000;font-weight:bold">|</span><span style="color:#d14">&#39;蓝&#39;</span><span style="color:#000;font-weight:bold">|</span><span style="color:#d14">&#39;紫&#39;</span>;
</span></span></code></pre></div><p>上面的示例都是由值类型组成的联合类型，非常清晰地表达了变量的取值范围。其中，<code>true|false</code>其实就是布尔类型<code>boolean</code>。</p>
<p>前面提到，打开编译选项<code>strictNullChecks</code>后，其他类型的变量不能赋值为<code>undefined</code>或<code>null</code>。这时，如果某个变量确实可能包含空值，就可以采用联合类型的写法。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> name:<span style="color:#458;font-weight:bold">string</span><span style="color:#000;font-weight:bold">|</span><span style="color:#000;font-weight:bold">null</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>name <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;John&#39;</span>;
</span></span><span style="display:flex;"><span>name <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">null</span>;
</span></span></code></pre></div><p>上面示例中，变量<code>name</code>的值可以是字符串，也可以是<code>null</code>。</p>
<p>联合类型的第一个成员前面，也可以加上竖杠<code>|</code>，这样便于多行书写。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> x<span style="color:#000;font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">|</span> <span style="color:#d14">&#39;one&#39;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">|</span> <span style="color:#d14">&#39;two&#39;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">|</span> <span style="color:#d14">&#39;three&#39;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">|</span> <span style="color:#d14">&#39;four&#39;</span>;
</span></span></code></pre></div><p>上面示例中，联合类型的第一个成员<code>one</code>前面，加上了竖杠。</p>
<p>如果一个变量有多种类型，读取该变量时，往往需要进行“类型缩小”（type narrowing），区分该值到底属于哪一种类型，然后再进一步处理。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> printId(
</span></span><span style="display:flex;"><span>  id:<span style="color:#458;font-weight:bold">number</span><span style="color:#000;font-weight:bold">|</span><span style="color:#458;font-weight:bold">string</span>
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>    console.log(id.toUpperCase()); <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>上面示例中，参数变量<code>id</code>可能是数值，也可能是字符串，这时直接对这个变量调用<code>toUpperCase()</code>方法会报错，因为这个方法只存在于字符串，不存在于数值。</p>
<p>解决方法就是对参数<code>id</code>做一下类型缩小，确定它的类型以后再进行处理。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> printId(
</span></span><span style="display:flex;"><span>  id:<span style="color:#458;font-weight:bold">number</span><span style="color:#000;font-weight:bold">|</span><span style="color:#458;font-weight:bold">string</span>
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">typeof</span> id <span style="color:#000;font-weight:bold">===</span> <span style="color:#d14">&#39;string&#39;</span>) {
</span></span><span style="display:flex;"><span>    console.log(id.toUpperCase());
</span></span><span style="display:flex;"><span>  } <span style="color:#000;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>    console.log(id);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，函数体内部会判断一下变量<code>id</code>的类型，如果是字符串，就对其执行<code>toUpperCase()</code>方法。</p>
<p>“类型缩小”是 TypeScript 处理联合类型的标准方法，凡是遇到可能为多种类型的场合，都需要先缩小类型，再进行处理。实际上，联合类型本身可以看成是一种“类型放大”（type widening），处理时就需要“类型缩小”（type narrowing）。</p>
<p>下面是“类型缩小”的另一个例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> getPort(
</span></span><span style="display:flex;"><span>  scheme<span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#39;http&#39;</span><span style="color:#000;font-weight:bold">|</span><span style="color:#d14">&#39;https&#39;</span>
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">switch</span> (scheme) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">case</span> <span style="color:#d14">&#39;http&#39;</span><span style="color:#000;font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">80</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">case</span> <span style="color:#d14">&#39;https&#39;</span><span style="color:#000;font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">443</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，函数体内部对参数变量<code>scheme</code>进行类型缩小，根据不同的值类型，返回不同的结果。</p>
<h2 id="交叉类型">交叉类型</h2>
<p>交叉类型（intersection types）指的多个类型组成的一个新类型，使用符号<code>&amp;</code>表示。</p>
<p>交叉类型<code>A&amp;B</code>表示，任何一个类型必须同时属于<code>A</code>和<code>B</code>，才属于交叉类型<code>A&amp;B</code>，即交叉类型同时满足<code>A</code>和<code>B</code>的特征。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> x:<span style="color:#458;font-weight:bold">number</span><span style="color:#000;font-weight:bold">&amp;</span><span style="color:#458;font-weight:bold">string</span>;
</span></span></code></pre></div><p>上面示例中，变量<code>x</code>同时是数值和字符串，这当然是不可能的，所以 TypeScript 会认为<code>x</code>的类型实际是<code>never</code>。</p>
<p>交叉类型的主要用途是表示对象的合成。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> obj<span style="color:#000;font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>  { foo: <span style="color:#458;font-weight:bold">string</span> } <span style="color:#000;font-weight:bold">&amp;</span>
</span></span><span style="display:flex;"><span>  { bar: <span style="color:#458;font-weight:bold">string</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>obj <span style="color:#000;font-weight:bold">=</span> {
</span></span><span style="display:flex;"><span>  foo<span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#39;hello&#39;</span>,
</span></span><span style="display:flex;"><span>  bar<span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#39;world&#39;</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>上面示例中，变量<code>obj</code>同时具有属性<code>foo</code>和属性<code>bar</code>。</p>
<p>交叉类型常常用来为对象类型添加新属性。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> A <span style="color:#000;font-weight:bold">=</span> { foo: <span style="color:#458;font-weight:bold">number</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> B <span style="color:#000;font-weight:bold">=</span> A <span style="color:#000;font-weight:bold">&amp;</span> { bar: <span style="color:#458;font-weight:bold">number</span> };
</span></span></code></pre></div><p>上面示例中，类型<code>B</code>是一个交叉类型，用来在<code>A</code>的基础上增加了属性<code>bar</code>。</p>
<h2 id="type-命令">type 命令</h2>
<p><code>type</code>命令用来定义一个类型的别名。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> Age <span style="color:#000;font-weight:bold">=</span> <span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> age:<span style="color:#458;font-weight:bold">Age</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">55</span>;
</span></span></code></pre></div><p>上面示例中，<code>type</code>命令为<code>number</code>类型定义了一个别名<code>Age</code>。这样就能像使用<code>number</code>一样，使用<code>Age</code>作为类型。</p>
<p>别名可以让类型的名字变得更有意义，也能增加代码的可读性，还可以使复杂类型用起来更方便，便于以后修改变量的类型。</p>
<p>别名不允许重名。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> Color <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;red&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> Color <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;blue&#39;</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，同一个别名<code>Color</code>声明了两次，就报错了。</p>
<p>别名的作用域是块级作用域。这意味着，代码块内部定义的别名，影响不到外部。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> Color <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;red&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">if</span> (<span style="color:#0086b3">Math</span>.random() <span style="color:#000;font-weight:bold">&lt;</span> <span style="color:#099">0.5</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">type</span> Color <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;blue&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，<code>if</code>代码块内部的类型别名<code>Color</code>，跟外部的<code>Color</code>是不一样的。</p>
<p>别名支持使用表达式，也可以在定义一个别名时，使用另一个别名，即别名允许嵌套。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> World <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;world&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> Greeting <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">`hello </span><span style="color:#d14">${</span>World<span style="color:#d14">}</span><span style="color:#d14">`</span>;
</span></span></code></pre></div><p>上面示例中，别名<code>Greeting</code>使用了模板字符串，读取另一个别名<code>World</code>。</p>
<p><code>type</code>命令属于类型相关的代码，编译成 JavaScript 的时候，会被全部删除。</p>
<h2 id="typeof-运算符">typeof 运算符</h2>
<p>JavaScript 语言中，typeof 运算符是一个一元运算符，返回一个字符串，代表操作数的类型。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">typeof</span> <span style="color:#d14">&#39;foo&#39;</span>; <span style="color:#998;font-style:italic">// &#39;string&#39;
</span></span></span></code></pre></div><p>上面示例中，<code>typeof</code>运算符返回字符串<code>foo</code>的类型是<code>string</code>。</p>
<p>注意，这时 typeof 的操作数是一个值。</p>
<p>JavaScript 里面，<code>typeof</code>运算符只可能返回八种结果，而且都是字符串。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">typeof</span> <span style="color:#000;font-weight:bold">undefined</span>; <span style="color:#998;font-style:italic">// &#34;undefined&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">typeof</span> <span style="color:#000;font-weight:bold">true</span>; <span style="color:#998;font-style:italic">// &#34;boolean&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">typeof</span> <span style="color:#099">1337</span>; <span style="color:#998;font-style:italic">// &#34;number&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">typeof</span> <span style="color:#d14">&#34;foo&#34;</span>; <span style="color:#998;font-style:italic">// &#34;string&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">typeof</span> {}; <span style="color:#998;font-style:italic">// &#34;object&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">typeof</span> <span style="color:#0086b3">parseInt</span>; <span style="color:#998;font-style:italic">// &#34;function&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">typeof</span> Symbol(); <span style="color:#998;font-style:italic">// &#34;symbol&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">typeof</span> <span style="color:#099">127</span>n <span style="color:#998;font-style:italic">// &#34;bigint&#34;
</span></span></span></code></pre></div><p>上面示例是<code>typeof</code>运算符在 JavaScript 语言里面，可能返回的八种结果。</p>
<p>TypeScript 将<code>typeof</code>运算符移植到了类型运算，它的操作数依然是一个值，但是返回的不是字符串，而是该值的 TypeScript 类型。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> a <span style="color:#000;font-weight:bold">=</span> { x: <span style="color:#458;font-weight:bold">0</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> T0 <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">typeof</span> a;   <span style="color:#998;font-style:italic">// { x: number }
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">type</span> T1 <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">typeof</span> a.x; <span style="color:#998;font-style:italic">// number
</span></span></span></code></pre></div><p>上面示例中，<code>typeof a</code>表示返回变量<code>a</code>的 TypeScript 类型（<code>{ x: number }</code>）。同理，<code>typeof a.x</code>返回的是属性<code>x</code>的类型（<code>number</code>）。</p>
<p>这种用法的<code>typeof</code>返回的是 TypeScript 类型，所以只能用在类型运算之中（即跟类型相关的代码之中），不能用在值运算。</p>
<p>也就是说，同一段代码可能存在两种<code>typeof</code>运算符，一种用在值相关的 JavaScript 代码部分，另一种用在类型相关的 TypeScript 代码部分。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> a <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> b:<span style="color:#458;font-weight:bold">typeof</span> a;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">typeof</span> a <span style="color:#000;font-weight:bold">===</span> <span style="color:#d14">&#39;number&#39;</span>) {
</span></span><span style="display:flex;"><span>  b <span style="color:#000;font-weight:bold">=</span> a;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，用到了两个<code>typeof</code>，第一个是类型运算，第二个是值运算。它们是不一样的，不要混淆。</p>
<p>JavaScript 的 typeof 遵守 JavaScript 规则，TypeScript 的 typeof 遵守 TypeScript 规则。它们的一个重要区别在于，编译后，前者会保留，后者会被全部删除。</p>
<p>上例的代码编译结果如下。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> a <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> b;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">typeof</span> a <span style="color:#000;font-weight:bold">===</span> <span style="color:#d14">&#39;number&#39;</span>) {
</span></span><span style="display:flex;"><span>    b <span style="color:#000;font-weight:bold">=</span> a;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，只保留了原始代码的第二个 typeof，删除了第一个 typeof。</p>
<p>由于编译时不会进行 JavaScript 的值运算，所以TypeScript 规定，typeof 的参数只能是标识符，不能是需要运算的表达式。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> T <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">typeof</span> <span style="color:#0086b3">Date</span>(); <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例会报错，原因是 typeof 的参数不能是一个值的运算式，而<code>Date()</code>需要运算才知道结果。</p>
<p>另外，<code>typeof</code>命令的参数不能是类型。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> Age <span style="color:#000;font-weight:bold">=</span> <span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> MyAge <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">typeof</span> Age; <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，<code>Age</code>是一个类型别名，用作<code>typeof</code>命令的参数就会报错。</p>
<p>typeof 是一个很重要的 TypeScript 运算符，有些场合不知道某个变量<code>foo</code>的类型，这时使用<code>typeof foo</code>就可以获得它的类型。</p>
<h2 id="块级类型声明">块级类型声明</h2>
<p>TypeScript 支持块级类型声明，即类型可以声明在代码块（用大括号表示）里面，并且只在当前代码块有效。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">true</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">type</span> T <span style="color:#000;font-weight:bold">=</span> <span style="color:#458;font-weight:bold">number</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">let</span> v:<span style="color:#458;font-weight:bold">T</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">5</span>;
</span></span><span style="display:flex;"><span>} <span style="color:#000;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">type</span> T <span style="color:#000;font-weight:bold">=</span> <span style="color:#458;font-weight:bold">string</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">let</span> v:<span style="color:#458;font-weight:bold">T</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;hello&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，存在两个代码块，其中分别有一个类型<code>T</code>的声明。这两个声明都只在自己的代码块内部有效，在代码块外部无效。</p>
<h2 id="类型的兼容">类型的兼容</h2>
<p>TypeScript 的类型存在兼容关系，某些类型可以兼容其他类型。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> T <span style="color:#000;font-weight:bold">=</span> <span style="color:#458;font-weight:bold">number</span><span style="color:#000;font-weight:bold">|</span><span style="color:#458;font-weight:bold">string</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> a:<span style="color:#458;font-weight:bold">number</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> b:<span style="color:#458;font-weight:bold">T</span> <span style="color:#000;font-weight:bold">=</span> a;
</span></span></code></pre></div><p>上面示例中，变量<code>a</code>和<code>b</code>的类型是不一样的，但是变量<code>a</code>赋值给变量<code>b</code>并不会报错。这时，我们就认为，<code>b</code>的类型兼容<code>a</code>的类型。</p>
<p>TypeScript 为这种情况定义了一个专门术语。如果类型<code>A</code>的值可以赋值给类型<code>B</code>，那么类型<code>A</code>就称为类型<code>B</code>的子类型（subtype）。在上例中，类型<code>number</code>就是类型<code>number|string</code>的子类型。</p>
<p>TypeScript 的一个规则是，凡是可以使用父类型的地方，都可以使用子类型，但是反过来不行。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> a<span style="color:#000;font-weight:bold">:</span><span style="color:#d14">&#39;hi&#39;</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;hi&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">let</span> b:<span style="color:#458;font-weight:bold">string</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;hello&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>b <span style="color:#000;font-weight:bold">=</span> a; <span style="color:#998;font-style:italic">// 正确
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>a <span style="color:#000;font-weight:bold">=</span> b; <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，<code>hi</code>是<code>string</code>的子类型，<code>string</code>是<code>hi</code>的父类型。所以，变量<code>a</code>可以赋值给变量<code>b</code>，但是反过来就会报错。</p>
<p>之所以有这样的规则，是因为子类型继承了父类型的所有特征，所以可以用在父类型的场合。但是，子类型还可能有一些父类型没有的特征，所以父类型不能用在子类型的场合。</p>

        </div>

        
<div class="post-archive">
    <ul class="post-copyright">
        <li><strong>Author: </strong><a rel="author" href="http://shansec.github.io">未来可期</a></li>
        <li style="word-break:break-all"><strong>Link: </strong><a href="http://shansec.github.io/post/ts/typescript-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/">http://shansec.github.io/post/ts/typescript-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/</a></li>
        <li><strong>License: </strong>This work is under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>. Kindly fulfill the requirements of the aforementioned License when adapting or creating a derivative of this work.</li>
    </ul>
</div>
<br/>



        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/post/ts/typescript-any%E7%B1%BB%E5%9E%8B%E5%92%8Cunknown%E7%B1%BB%E5%9E%8B%E5%92%8Cnever%E7%B1%BB%E5%9E%8B/">Typescript Any类型和unknown类型和never类型</a></li>
        
        <li><a href="/post/ts/typescript-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/">Typescript 基本用法</a></li>
        
        <li><a href="/post/blog/%E5%A6%82%E4%BD%95%E4%B8%BA-Vue3-%E7%BB%84%E4%BB%B6%E6%A0%87%E6%B3%A8-TS-%E7%B1%BB%E5%9E%8B%E7%9C%8B%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86/">何为 Vue3 组件标注 TS 类型，看这篇文章就够了！</a></li>
        
        <li><a href="/post/es6/%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E6%89%A9%E5%B1%95/">运算符的扩展</a></li>
        
        <li><a href="/post/es6/%E8%A3%85%E9%A5%B0%E5%99%A8/">装饰器</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='/tags/typescript' target="_blank">typescript</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "your github repo"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
    
    

</div>

                    <footer id="footer">
    <div>
        &copy; 2024 <a href="http://shansec.github.io">未来可期的博客 By 未来可期</a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>
<style type="text/css">
div.highlight {
    position: relative;
    margin: 1em 0px;
}

.copy-code {
    display: none;
    position: absolute;
    top: 4px;
    right: 4px;
    color: rgba(255, 255, 255, 0.8);
    background: rgba(78, 78, 78, 0.8);
    border-radius: var(--radius);
    padding: 0 5px;
    font: inherit;
    user-select: none;
    cursor: pointer;
    border: 0;
    --radius: 8px;
}

div.highlight:hover .copy-code,pre:hover .copy-code {
    display: block;
}

</style>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>


    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




    <script src='/js/douban.js'></script>

                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='http://shansec.github.io/search' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="http://shansec.github.io">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>

    <section class="widget">
        <h3 class="widget-title">Latest articles</h3>
<ul class="widget-list">
    
    <li>
        <a href="http://shansec.github.io/post/ts/Typescript-interface/" title="Typescript Interface" target="_blank">Typescript Interface</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/typescript-%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B/" title="Typescript 函数类型" target="_blank">Typescript 函数类型</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/typescript-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B/" title="Typescript 对象类型" target="_blank">Typescript 对象类型</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/typescript-%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B/" title="Typescript 数组类型" target="_blank">Typescript 数组类型</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/typescript-%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B/" title="Typescript 数组类型" target="_blank">Typescript 数组类型</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/typescript-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/" title="Typescript 类型系统" target="_blank">Typescript 类型系统</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/typescript-any%E7%B1%BB%E5%9E%8B%E5%92%8Cunknown%E7%B1%BB%E5%9E%8B%E5%92%8Cnever%E7%B1%BB%E5%9E%8B/" title="Typescript Any类型和unknown类型和never类型" target="_blank">Typescript Any类型和unknown类型和never类型</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/ts/typescript-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/" title="Typescript 基本用法" target="_blank">Typescript 基本用法</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/es6/%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E6%89%A9%E5%B1%95/" title="运算符的扩展" target="_blank">运算符的扩展</a>
    </li>
    
    <li>
        <a href="http://shansec.github.io/post/es6/%E8%A3%85%E9%A5%B0%E5%99%A8/" title="装饰器" target="_blank">装饰器</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href='/categories/'>Categories</a></h3>
<ul class="widget-list">
    
    <li><a href="http://shansec.github.io/categories/go/">go (43)</a></li>
    
    <li><a href="http://shansec.github.io/categories/%E5%89%8D%E7%AB%AF/">前端 (59)</a></li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href='/tags/'>Tags</a></h3>
<div class="tagcloud">
    
    <a href="http://shansec.github.io/tags/CSS/">CSS</a>
    
    <a href="http://shansec.github.io/tags/HTTP/">HTTP</a>
    
    <a href="http://shansec.github.io/tags/javaScript/">javaScript</a>
    
    <a href="http://shansec.github.io/tags/CSS/">CSS</a>
    
    <a href="http://shansec.github.io/tags/docker/">docker</a>
    
    <a href="http://shansec.github.io/tags/es6/">es6</a>
    
    <a href="http://shansec.github.io/tags/go/">go</a>
    
    <a href="http://shansec.github.io/tags/go-%E5%9F%BA%E7%A1%80/">go 基础</a>
    
    <a href="http://shansec.github.io/tags/go-%E6%A0%87%E5%87%86%E5%BA%93/">go 标准库</a>
    
    <a href="http://shansec.github.io/tags/javaScript/">javaScript</a>
    
    <a href="http://shansec.github.io/tags/jwt/">jwt</a>
    
    <a href="http://shansec.github.io/tags/package/">package</a>
    
    <a href="http://shansec.github.io/tags/pinia/">pinia</a>
    
    <a href="http://shansec.github.io/tags/redis/">redis</a>
    
    <a href="http://shansec.github.io/tags/sql/">sql</a>
    
    <a href="http://shansec.github.io/tags/sqlx/">sqlx</a>
    
    <a href="http://shansec.github.io/tags/typescript/">typescript</a>
    
    <a href="http://shansec.github.io/tags/vue/">vue</a>
    
    <a href="http://shansec.github.io/tags/%E5%AD%98%E5%82%A8/">存储</a>
    
    <a href="http://shansec.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">微信小程序</a>
    
    <a href="http://shansec.github.io/tags/%E6%A0%87%E5%87%86%E5%BA%93/">标准库</a>
    
    <a href="http://shansec.github.io/tags/%E6%A1%86%E6%9E%B6/">框架</a>
    
    <a href="http://shansec.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/">计算机原理</a>
    
</div>
    </section>

    
<section class="widget">
    <h3 class="widget-title">Links</h3>
    <ul class="widget-list">
        
        <li>
            <a target="_blank" href="https://www.liwenzhou.com/" title="李文周的博客">李文周的博客</a>
        </li>
        
    </ul>
</section>


    <section class="widget">
        <h3 class="widget-title">Meta</h3>
        <ul class="widget-list">
            <li><a href="http://shansec.github.io/index.xml">RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>